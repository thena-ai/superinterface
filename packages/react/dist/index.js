function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function get(target, property, receiver) {
            var base = _super_prop_base(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of(object);
        if (object === null) break;
    }
    return object;
}
function _to_array(arr) {
    return _array_with_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function _ts_values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = function(cb, mod) {
    return function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
};
var __copyProps = function(to, from, except, desc) {
    if (from && (typeof from === "undefined" ? "undefined" : _type_of(from)) === "object" || typeof from === "function") {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            var _loop = function() {
                var key2 = _step.value;
                if (!__hasOwnProp.call(to, key2) && key2 !== except) __defProp(to, key2, {
                    get: function() {
                        return from[key2];
                    },
                    enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable
                });
            };
            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return to;
};
var __toESM = function(mod, isNodeMode, target) {
    return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod);
};
// ../../node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({
    "../../node_modules/@babel/parser/lib/index.js": function(exports) {
        "use strict";
        var _templateObject;
        var _templateObject2;
        var _templateObject3;
        var _templateObject4;
        var _templateObject5;
        function _taggedTemplateLiteral(e, t) {
            return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
                raw: {
                    value: Object.freeze(t)
                }
            }));
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function _objectWithoutPropertiesLoose9(r, e) {
            if (null == r) return {};
            var t = {};
            for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
                if (e.includes(n)) continue;
                t[n] = r[n];
            }
            return t;
        }
        var Position = function Position(line, col, index) {
            _class_call_check(this, Position);
            this.line = void 0;
            this.column = void 0;
            this.index = void 0;
            this.line = line;
            this.column = col;
            this.index = index;
        };
        var SourceLocation = function SourceLocation(start, end) {
            _class_call_check(this, SourceLocation);
            this.start = void 0;
            this.end = void 0;
            this.filename = void 0;
            this.identifierName = void 0;
            this.start = start;
            this.end = end;
        };
        function createPositionWithColumnOffset(position, columnOffset) {
            var line = position.line, column = position.column, index = position.index;
            return new Position(line, column + columnOffset, index + columnOffset);
        }
        var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
        var ModuleErrors = {
            ImportMetaOutsideModule: {
                message: "import.meta may appear only with 'sourceType: \"module\"'",
                code: code
            },
            ImportOutsideModule: {
                message: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
                code: code
            }
        };
        var NodeDescriptions = {
            ArrayPattern: "array destructuring pattern",
            AssignmentExpression: "assignment expression",
            AssignmentPattern: "assignment expression",
            ArrowFunctionExpression: "arrow function expression",
            ConditionalExpression: "conditional expression",
            CatchClause: "catch clause",
            ForOfStatement: "for-of statement",
            ForInStatement: "for-in statement",
            ForStatement: "for-loop",
            FormalParameters: "function parameter list",
            Identifier: "identifier",
            ImportSpecifier: "import specifier",
            ImportDefaultSpecifier: "import default specifier",
            ImportNamespaceSpecifier: "import namespace specifier",
            ObjectPattern: "object destructuring pattern",
            ParenthesizedExpression: "parenthesized expression",
            RestElement: "rest element",
            UpdateExpression: {
                true: "prefix operation",
                false: "postfix operation"
            },
            VariableDeclarator: "variable declaration",
            YieldExpression: "yield expression"
        };
        var toNodeDescription = function(node) {
            return node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression["".concat(node.prefix)] : NodeDescriptions[node.type];
        };
        var StandardErrors = {
            AccessorIsGenerator: function(_ref3) {
                var kind = _ref3.kind;
                return "A ".concat(kind, "ter cannot be a generator.");
            },
            ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
            AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
            AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
            AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
            AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
            AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
            AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
            AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
            BadGetterArity: "A 'get' accessor must not have any formal parameters.",
            BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
            BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
            ConstructorClassField: "Classes may not have a field named 'constructor'.",
            ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
            ConstructorIsAccessor: "Class constructor may not be an accessor.",
            ConstructorIsAsync: "Constructor can't be an async function.",
            ConstructorIsGenerator: "Constructor can't be a generator.",
            DeclarationMissingInitializer: function(_ref4) {
                var kind = _ref4.kind;
                return "Missing initializer in ".concat(kind, " declaration.");
            },
            DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
            DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
            DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
            DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
            DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
            DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
            DecoratorStaticBlock: "Decorators can't be used with a static block.",
            DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
            DeletePrivateField: "Deleting a private field is not allowed.",
            DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
            DuplicateConstructor: "Duplicate constructor in the same class.",
            DuplicateDefaultExport: "Only one default export allowed per module.",
            DuplicateExport: function(_ref5) {
                var exportName = _ref5.exportName;
                return "`".concat(exportName, "` has already been exported. Exported identifiers must be unique.");
            },
            DuplicateProto: "Redefinition of __proto__ property.",
            DuplicateRegExpFlags: "Duplicate regular expression flag.",
            DynamicImportPhaseRequiresImportExpressions: function(_ref6) {
                var phase = _ref6.phase;
                return "'import.".concat(phase, "(...)' can only be parsed when using the 'createImportExpressions' option.");
            },
            ElementAfterRest: "Rest element must be last element.",
            EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
            ExportBindingIsString: function(_ref7) {
                var localName = _ref7.localName, exportName = _ref7.exportName;
                return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(localName, "' as '").concat(exportName, "' } from 'some-module'`?");
            },
            ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
            ForInOfLoopInitializer: function(_ref8) {
                var type = _ref8.type;
                return "'".concat(type === "ForInStatement" ? "for-in" : "for-of", "' loop variable declaration may not have an initializer.");
            },
            ForInUsing: "For-in loop may not start with 'using' declaration.",
            ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
            ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
            GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
            IllegalBreakContinue: function(_ref9) {
                var type = _ref9.type;
                return "Unsyntactic ".concat(type === "BreakStatement" ? "break" : "continue", ".");
            },
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
            IllegalReturn: "'return' outside of function.",
            ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
            ImportBindingIsString: function(_ref10) {
                var importName = _ref10.importName;
                return 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "'.concat(importName, '" as foo }`?');
            },
            ImportCallArity: "`import()` requires exactly one or two arguments.",
            ImportCallNotNewExpression: "Cannot use new with import(...).",
            ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
            ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
            ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
            ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
            IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
            InvalidBigIntLiteral: "Invalid BigIntLiteral.",
            InvalidCodePoint: "Code point out of bounds.",
            InvalidCoverInitializedName: "Invalid shorthand property initializer.",
            InvalidDecimal: "Invalid decimal.",
            InvalidDigit: function(_ref11) {
                var radix = _ref11.radix;
                return "Expected number in radix ".concat(radix, ".");
            },
            InvalidEscapeSequence: "Bad character escape sequence.",
            InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
            InvalidEscapedReservedWord: function(_ref12) {
                var reservedWord = _ref12.reservedWord;
                return "Escape sequence in keyword ".concat(reservedWord, ".");
            },
            InvalidIdentifier: function(_ref13) {
                var identifierName = _ref13.identifierName;
                return "Invalid identifier ".concat(identifierName, ".");
            },
            InvalidLhs: function(_ref14) {
                var ancestor = _ref14.ancestor;
                return "Invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
            },
            InvalidLhsBinding: function(_ref15) {
                var ancestor = _ref15.ancestor;
                return "Binding invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
            },
            InvalidLhsOptionalChaining: function(_ref16) {
                var ancestor = _ref16.ancestor;
                return "Invalid optional chaining in the left-hand side of ".concat(toNodeDescription(ancestor), ".");
            },
            InvalidNumber: "Invalid number.",
            InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
            InvalidOrUnexpectedToken: function(_ref17) {
                var unexpected = _ref17.unexpected;
                return "Unexpected character '".concat(unexpected, "'.");
            },
            InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
            InvalidPrivateFieldResolution: function(_ref18) {
                var identifierName = _ref18.identifierName;
                return "Private name #".concat(identifierName, " is not defined.");
            },
            InvalidPropertyBindingPattern: "Binding member expression.",
            InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
            InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
            LabelRedeclaration: function(_ref19) {
                var labelName = _ref19.labelName;
                return "Label '".concat(labelName, "' is already declared.");
            },
            LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
            LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
            MalformedRegExpFlags: "Invalid regular expression flag.",
            MissingClassName: "A class name is required.",
            MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
            MissingSemicolon: "Missing semicolon.",
            MissingPlugin: function(_ref20) {
                var missingPlugin = _ref20.missingPlugin;
                return "This experimental syntax requires enabling the parser plugin: ".concat(missingPlugin.map(function(name) {
                    return JSON.stringify(name);
                }).join(", "), ".");
            },
            MissingOneOfPlugins: function(_ref21) {
                var missingPlugin = _ref21.missingPlugin;
                return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(missingPlugin.map(function(name) {
                    return JSON.stringify(name);
                }).join(", "), ".");
            },
            MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
            MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
            ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
            ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
            ModuleAttributesWithDuplicateKeys: function(_ref22) {
                var key2 = _ref22.key;
                return 'Duplicate key "'.concat(key2, '" is not allowed in module attributes.');
            },
            ModuleExportNameHasLoneSurrogate: function(_ref23) {
                var surrogateCharCode = _ref23.surrogateCharCode;
                return "An export name cannot include a lone surrogate, found '\\u".concat(surrogateCharCode.toString(16), "'.");
            },
            ModuleExportUndefined: function(_ref24) {
                var localName = _ref24.localName;
                return "Export '".concat(localName, "' is not defined.");
            },
            MultipleDefaultsInSwitch: "Multiple default clauses.",
            NewlineAfterThrow: "Illegal newline after throw.",
            NoCatchOrFinally: "Missing catch or finally clause.",
            NumberIdentifier: "Identifier directly after number.",
            NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
            ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
            OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
            OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
            OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
            ParamDupe: "Argument name clash.",
            PatternHasAccessor: "Object pattern can't contain getter or setter.",
            PatternHasMethod: "Object pattern can't contain methods.",
            PrivateInExpectedIn: function(_ref25) {
                var identifierName = _ref25.identifierName;
                return "Private names are only allowed in property accesses (`obj.#".concat(identifierName, "`) or in `in` expressions (`#").concat(identifierName, " in obj`).");
            },
            PrivateNameRedeclaration: function(_ref26) {
                var identifierName = _ref26.identifierName;
                return "Duplicate private name #".concat(identifierName, ".");
            },
            RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
            RecordNoProto: "'__proto__' is not allowed in Record expressions.",
            RestTrailingComma: "Unexpected trailing comma after rest element.",
            SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
            SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
            SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
            StaticPrototype: "Classes may not have static property named prototype.",
            SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
            SuperPrivateField: "Private fields can't be accessed on super.",
            TrailingDecorator: "Decorators must be attached to a class element.",
            TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
            UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
            UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
            UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
            UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
            UnexpectedKeyword: function(_ref27) {
                var keyword = _ref27.keyword;
                return "Unexpected keyword '".concat(keyword, "'.");
            },
            UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
            UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
            UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
            UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
            UnexpectedPrivateField: "Unexpected private name.",
            UnexpectedReservedWord: function(_ref28) {
                var reservedWord = _ref28.reservedWord;
                return "Unexpected reserved word '".concat(reservedWord, "'.");
            },
            UnexpectedSuper: "'super' is only allowed in object methods and classes.",
            UnexpectedToken: function(_ref29) {
                var expected = _ref29.expected, unexpected = _ref29.unexpected;
                return "Unexpected token".concat(unexpected ? " '".concat(unexpected, "'.") : "").concat(expected ? ', expected "'.concat(expected, '"') : "");
            },
            UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
            UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
            UnsupportedBind: "Binding should be performed on object property.",
            UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
            UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
            UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
            UnsupportedMetaProperty: function(_ref30) {
                var target = _ref30.target, onlyValidPropertyName = _ref30.onlyValidPropertyName;
                return "The only valid meta property for ".concat(target, " is ").concat(target, ".").concat(onlyValidPropertyName, ".");
            },
            UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
            UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
            UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
            UnterminatedComment: "Unterminated comment.",
            UnterminatedRegExp: "Unterminated regular expression.",
            UnterminatedString: "Unterminated string constant.",
            UnterminatedTemplate: "Unterminated template.",
            UsingDeclarationExport: "Using declaration cannot be exported.",
            UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
            VarRedeclaration: function(_ref31) {
                var identifierName = _ref31.identifierName;
                return "Identifier '".concat(identifierName, "' has already been declared.");
            },
            YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
            YieldInParameter: "Yield expression is not allowed in formal parameters.",
            ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
        };
        var StrictModeErrors = {
            StrictDelete: "Deleting local variable in strict mode.",
            StrictEvalArguments: function(_ref32) {
                var referenceName = _ref32.referenceName;
                return "Assigning to '".concat(referenceName, "' in strict mode.");
            },
            StrictEvalArgumentsBinding: function(_ref33) {
                var bindingName = _ref33.bindingName;
                return "Binding '".concat(bindingName, "' in strict mode.");
            },
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
            StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
            StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
            StrictWith: "'with' in strict mode."
        };
        var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set([
            "ArrowFunctionExpression",
            "AssignmentExpression",
            "ConditionalExpression",
            "YieldExpression"
        ]);
        var PipelineOperatorErrors = {
            PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
            PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
            PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
            PipeTopicUnconfiguredToken: function(_ref34) {
                var token = _ref34.token;
                return "Invalid topic token ".concat(token, ". In order to use ").concat(token, ' as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "').concat(token, '" }.');
            },
            PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
            PipeUnparenthesizedBody: function(_ref35) {
                var type = _ref35.type;
                return "Hack-style pipe body cannot be an unparenthesized ".concat(toNodeDescription({
                    type: type
                }), "; please wrap it in parentheses.");
            },
            PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
            PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
            PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
            PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
            PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
            PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
        };
        var _excluded9 = [
            "message"
        ];
        function defineHidden(obj, key2, value) {
            Object.defineProperty(obj, key2, {
                enumerable: false,
                configurable: true,
                value: value
            });
        }
        function toParseErrorConstructor(_ref36) {
            var toMessage = _ref36.toMessage, code2 = _ref36.code, reasonCode = _ref36.reasonCode, syntaxPlugin = _ref36.syntaxPlugin;
            var hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
            {
                var oldReasonCodes = {
                    AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
                    AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
                    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
                    SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
                    SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
                    SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
                };
                if (oldReasonCodes[reasonCode]) {
                    reasonCode = oldReasonCodes[reasonCode];
                }
            }
            return function constructor(loc, details) {
                var error = new SyntaxError();
                error.code = code2;
                error.reasonCode = reasonCode;
                error.loc = loc;
                error.pos = loc.index;
                error.syntaxPlugin = syntaxPlugin;
                if (hasMissingPlugin) {
                    error.missingPlugin = details.missingPlugin;
                }
                defineHidden(error, "clone", function clone() {
                    var overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    var _overrides$loc;
                    var _ref = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc, line = _ref.line, column = _ref.column, index = _ref.index;
                    return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
                });
                defineHidden(error, "details", details);
                Object.defineProperty(error, "message", {
                    configurable: true,
                    get: function get() {
                        var message = "".concat(toMessage(details), " (").concat(loc.line, ":").concat(loc.column, ")");
                        this.message = message;
                        return message;
                    },
                    set: function set(value) {
                        Object.defineProperty(this, "message", {
                            value: value,
                            writable: true
                        });
                    }
                });
                return error;
            };
        }
        function ParseErrorEnum(argument, syntaxPlugin) {
            if (Array.isArray(argument)) {
                return function(parseErrorTemplates) {
                    return ParseErrorEnum(parseErrorTemplates, argument[0]);
                };
            }
            var ParseErrorConstructors = {};
            var _loop = function _loop2() {
                var template = argument[reasonCode];
                var _ref = typeof template === "string" ? {
                    message: function() {
                        return template;
                    }
                } : typeof template === "function" ? {
                    message: template
                } : template, message = _ref.message, rest = _objectWithoutPropertiesLoose9(_ref, _excluded9);
                var toMessage = typeof message === "string" ? function() {
                    return message;
                } : message;
                ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
                    code: "BABEL_PARSER_SYNTAX_ERROR",
                    reasonCode: reasonCode,
                    toMessage: toMessage
                }, syntaxPlugin ? {
                    syntaxPlugin: syntaxPlugin
                } : {}, rest));
            };
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.keys(argument)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var reasonCode = _step.value;
                    _loop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return ParseErrorConstructors;
        }
        var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(_templateObject || (_templateObject = _taggedTemplateLiteral([
            "pipelineOperator"
        ])))(PipelineOperatorErrors));
        var defineProperty = Object.defineProperty;
        var toUnenumerable = function(object, key2) {
            if (object) {
                defineProperty(object, key2, {
                    enumerable: false,
                    value: object[key2]
                });
            }
        };
        function toESTreeLocation(node) {
            toUnenumerable(node.loc.start, "index");
            toUnenumerable(node.loc.end, "index");
            return node;
        }
        var estree = function(superClass) {
            var ESTreeParserMixin = /*#__PURE__*/ function(superClass) {
                _inherits(ESTreeParserMixin, superClass);
                function ESTreeParserMixin() {
                    _class_call_check(this, ESTreeParserMixin);
                    return _call_super(this, ESTreeParserMixin, arguments);
                }
                _create_class(ESTreeParserMixin, [
                    {
                        key: "parse",
                        value: function parse() {
                            var file = toESTreeLocation(_get(_get_prototype_of(ESTreeParserMixin.prototype), "parse", this).call(this));
                            if (this.options.tokens) {
                                file.tokens = file.tokens.map(toESTreeLocation);
                            }
                            return file;
                        }
                    },
                    {
                        key: "parseRegExpLiteral",
                        value: function parseRegExpLiteral(_ref37) {
                            var pattern = _ref37.pattern, flags = _ref37.flags;
                            var regex = null;
                            try {
                                regex = new RegExp(pattern, flags);
                            } catch (_10) {}
                            var node = this.estreeParseLiteral(regex);
                            node.regex = {
                                pattern: pattern,
                                flags: flags
                            };
                            return node;
                        }
                    },
                    {
                        key: "parseBigIntLiteral",
                        value: function parseBigIntLiteral(value) {
                            var bigInt;
                            try {
                                bigInt = BigInt(value);
                            } catch (_unused) {
                                bigInt = null;
                            }
                            var node = this.estreeParseLiteral(bigInt);
                            node.bigint = String(node.value || value);
                            return node;
                        }
                    },
                    {
                        key: "parseDecimalLiteral",
                        value: function parseDecimalLiteral(value) {
                            var decimal = null;
                            var node = this.estreeParseLiteral(decimal);
                            node.decimal = String(node.value || value);
                            return node;
                        }
                    },
                    {
                        key: "estreeParseLiteral",
                        value: function estreeParseLiteral(value) {
                            return this.parseLiteral(value, "Literal");
                        }
                    },
                    {
                        key: "parseStringLiteral",
                        value: function parseStringLiteral(value) {
                            return this.estreeParseLiteral(value);
                        }
                    },
                    {
                        key: "parseNumericLiteral",
                        value: function parseNumericLiteral(value) {
                            return this.estreeParseLiteral(value);
                        }
                    },
                    {
                        key: "parseNullLiteral",
                        value: function parseNullLiteral() {
                            return this.estreeParseLiteral(null);
                        }
                    },
                    {
                        key: "parseBooleanLiteral",
                        value: function parseBooleanLiteral(value) {
                            return this.estreeParseLiteral(value);
                        }
                    },
                    {
                        key: "directiveToStmt",
                        value: function directiveToStmt(directive) {
                            var expression = directive.value;
                            delete directive.value;
                            expression.type = "Literal";
                            expression.raw = expression.extra.raw;
                            expression.value = expression.extra.expressionValue;
                            var stmt = directive;
                            stmt.type = "ExpressionStatement";
                            stmt.expression = expression;
                            stmt.directive = expression.extra.rawValue;
                            delete expression.extra;
                            return stmt;
                        }
                    },
                    {
                        key: "initFunction",
                        value: function initFunction(node, isAsync) {
                            _get(_get_prototype_of(ESTreeParserMixin.prototype), "initFunction", this).call(this, node, isAsync);
                            node.expression = false;
                        }
                    },
                    {
                        key: "checkDeclaration",
                        value: function checkDeclaration(node) {
                            if (node != null && this.isObjectProperty(node)) {
                                this.checkDeclaration(node.value);
                            } else {
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "checkDeclaration", this).call(this, node);
                            }
                        }
                    },
                    {
                        key: "getObjectOrClassMethodParams",
                        value: function getObjectOrClassMethodParams(method) {
                            return method.value.params;
                        }
                    },
                    {
                        key: "isValidDirective",
                        value: function isValidDirective(stmt) {
                            var _stmt$expression$extr;
                            return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
                        }
                    },
                    {
                        key: "parseBlockBody",
                        value: function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
                            var _this = this;
                            _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseBlockBody", this).call(this, node, allowDirectives, topLevel, end, afterBlockParse);
                            var directiveStatements = node.directives.map(function(d) {
                                return _this.directiveToStmt(d);
                            });
                            node.body = directiveStatements.concat(node.body);
                            delete node.directives;
                        }
                    },
                    {
                        key: "pushClassMethod",
                        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                            this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
                            if (method.typeParameters) {
                                method.value.typeParameters = method.typeParameters;
                                delete method.typeParameters;
                            }
                            classBody.body.push(method);
                        }
                    },
                    {
                        key: "parsePrivateName",
                        value: function parsePrivateName() {
                            var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parsePrivateName", this).call(this);
                            {
                                if (!this.getPluginOption("estree", "classFeatures")) {
                                    return node;
                                }
                            }
                            return this.convertPrivateNameToPrivateIdentifier(node);
                        }
                    },
                    {
                        key: "convertPrivateNameToPrivateIdentifier",
                        value: function convertPrivateNameToPrivateIdentifier(node) {
                            var name = _get(_get_prototype_of(ESTreeParserMixin.prototype), "getPrivateNameSV", this).call(this, node);
                            node = node;
                            delete node.id;
                            node.name = name;
                            node.type = "PrivateIdentifier";
                            return node;
                        }
                    },
                    {
                        key: "isPrivateName",
                        value: function isPrivateName(node) {
                            {
                                if (!this.getPluginOption("estree", "classFeatures")) {
                                    return _get(_get_prototype_of(ESTreeParserMixin.prototype), "isPrivateName", this).call(this, node);
                                }
                            }
                            return node.type === "PrivateIdentifier";
                        }
                    },
                    {
                        key: "getPrivateNameSV",
                        value: function getPrivateNameSV(node) {
                            {
                                if (!this.getPluginOption("estree", "classFeatures")) {
                                    return _get(_get_prototype_of(ESTreeParserMixin.prototype), "getPrivateNameSV", this).call(this, node);
                                }
                            }
                            return node.name;
                        }
                    },
                    {
                        key: "parseLiteral",
                        value: function parseLiteral(value, type) {
                            var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseLiteral", this).call(this, value, type);
                            node.raw = node.extra.raw;
                            delete node.extra;
                            return node;
                        }
                    },
                    {
                        key: "parseFunctionBody",
                        value: function parseFunctionBody(node, allowExpression) {
                            var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseFunctionBody", this).call(this, node, allowExpression, isMethod);
                            node.expression = node.body.type !== "BlockStatement";
                        }
                    },
                    {
                        key: "parseMethod",
                        value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
                            var inClassScope = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                            var funcNode = this.startNode();
                            funcNode.kind = node.kind;
                            funcNode = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseMethod", this).call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
                            funcNode.type = "FunctionExpression";
                            delete funcNode.kind;
                            node.value = funcNode;
                            if (type === "ClassPrivateMethod") {
                                node.computed = false;
                            }
                            return this.finishNode(node, "MethodDefinition");
                        }
                    },
                    {
                        key: "nameIsConstructor",
                        value: function nameIsConstructor(key2) {
                            if (key2.type === "Literal") return key2.value === "constructor";
                            return _get(_get_prototype_of(ESTreeParserMixin.prototype), "nameIsConstructor", this).call(this, key2);
                        }
                    },
                    {
                        key: "parseClassProperty",
                        value: function parseClassProperty() {
                            var propertyNode = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseClassProperty", this).apply(this, arguments);
                            {
                                if (!this.getPluginOption("estree", "classFeatures")) {
                                    return propertyNode;
                                }
                            }
                            propertyNode.type = "PropertyDefinition";
                            return propertyNode;
                        }
                    },
                    {
                        key: "parseClassPrivateProperty",
                        value: function parseClassPrivateProperty() {
                            var propertyNode = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseClassPrivateProperty", this).apply(this, arguments);
                            {
                                if (!this.getPluginOption("estree", "classFeatures")) {
                                    return propertyNode;
                                }
                            }
                            propertyNode.type = "PropertyDefinition";
                            propertyNode.computed = false;
                            return propertyNode;
                        }
                    },
                    {
                        key: "parseObjectMethod",
                        value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
                            var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseObjectMethod", this).call(this, prop, isGenerator, isAsync, isPattern, isAccessor);
                            if (node) {
                                node.type = "Property";
                                if (node.kind === "method") {
                                    node.kind = "init";
                                }
                                node.shorthand = false;
                            }
                            return node;
                        }
                    },
                    {
                        key: "parseObjectProperty",
                        value: function parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
                            var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseObjectProperty", this).call(this, prop, startLoc, isPattern, refExpressionErrors);
                            if (node) {
                                node.kind = "init";
                                node.type = "Property";
                            }
                            return node;
                        }
                    },
                    {
                        key: "isValidLVal",
                        value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
                            return type === "Property" ? "value" : _get(_get_prototype_of(ESTreeParserMixin.prototype), "isValidLVal", this).call(this, type, isUnparenthesizedInAssign, binding);
                        }
                    },
                    {
                        key: "isAssignable",
                        value: function isAssignable(node, isBinding) {
                            if (node != null && this.isObjectProperty(node)) {
                                return this.isAssignable(node.value, isBinding);
                            }
                            return _get(_get_prototype_of(ESTreeParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
                        }
                    },
                    {
                        key: "toAssignable",
                        value: function toAssignable(node) {
                            var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                            if (node != null && this.isObjectProperty(node)) {
                                var key2 = node.key, value = node.value;
                                if (this.isPrivateName(key2)) {
                                    this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start);
                                }
                                this.toAssignable(value, isLHS);
                            } else {
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                            }
                        }
                    },
                    {
                        key: "toAssignableObjectExpressionProp",
                        value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
                            if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
                                this.raise(Errors.PatternHasAccessor, prop.key);
                            } else if (prop.type === "Property" && prop.method) {
                                this.raise(Errors.PatternHasMethod, prop.key);
                            } else {
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "toAssignableObjectExpressionProp", this).call(this, prop, isLast, isLHS);
                            }
                        }
                    },
                    {
                        key: "finishCallExpression",
                        value: function finishCallExpression(unfinished, optional) {
                            var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "finishCallExpression", this).call(this, unfinished, optional);
                            if (node.callee.type === "Import") {
                                var _ref, _ref2;
                                node.type = "ImportExpression";
                                node.source = node.arguments[0];
                                node.options = (_ref = node.arguments[1]) != null ? _ref : null;
                                node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
                                delete node.arguments;
                                delete node.callee;
                            }
                            return node;
                        }
                    },
                    {
                        key: "toReferencedArguments",
                        value: function toReferencedArguments(node) {
                            if (node.type === "ImportExpression") {
                                return;
                            }
                            _get(_get_prototype_of(ESTreeParserMixin.prototype), "toReferencedArguments", this).call(this, node);
                        }
                    },
                    {
                        key: "parseExport",
                        value: function parseExport(unfinished, decorators) {
                            var exportStartLoc = this.state.lastTokStartLoc;
                            var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseExport", this).call(this, unfinished, decorators);
                            switch(node.type){
                                case "ExportAllDeclaration":
                                    node.exported = null;
                                    break;
                                case "ExportNamedDeclaration":
                                    if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                                        node.type = "ExportAllDeclaration";
                                        node.exported = node.specifiers[0].exported;
                                        delete node.specifiers;
                                    }
                                case "ExportDefaultDeclaration":
                                    {
                                        var _declaration$decorato;
                                        var declaration = node.declaration;
                                        if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                                            this.resetStartLocation(node, exportStartLoc);
                                        }
                                    }
                                    break;
                            }
                            return node;
                        }
                    },
                    {
                        key: "parseSubscript",
                        value: function parseSubscript(base, startLoc, noCalls, state) {
                            var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, state);
                            if (state.optionalChainMember) {
                                if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
                                    node.type = node.type.substring(8);
                                }
                                if (state.stop) {
                                    var chain = this.startNodeAtNode(node);
                                    chain.expression = node;
                                    return this.finishNode(chain, "ChainExpression");
                                }
                            } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
                                node.optional = false;
                            }
                            return node;
                        }
                    },
                    {
                        key: "isOptionalMemberExpression",
                        value: function isOptionalMemberExpression(node) {
                            if (node.type === "ChainExpression") {
                                return node.expression.type === "MemberExpression";
                            }
                            return _get(_get_prototype_of(ESTreeParserMixin.prototype), "isOptionalMemberExpression", this).call(this, node);
                        }
                    },
                    {
                        key: "hasPropertyAsPrivateName",
                        value: function hasPropertyAsPrivateName(node) {
                            if (node.type === "ChainExpression") {
                                node = node.expression;
                            }
                            return _get(_get_prototype_of(ESTreeParserMixin.prototype), "hasPropertyAsPrivateName", this).call(this, node);
                        }
                    },
                    {
                        key: "isObjectProperty",
                        value: function isObjectProperty(node) {
                            return node.type === "Property" && node.kind === "init" && !node.method;
                        }
                    },
                    {
                        key: "isObjectMethod",
                        value: function isObjectMethod(node) {
                            return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
                        }
                    },
                    {
                        key: "finishNodeAt",
                        value: function finishNodeAt(node, type, endLoc) {
                            return toESTreeLocation(_get(_get_prototype_of(ESTreeParserMixin.prototype), "finishNodeAt", this).call(this, node, type, endLoc));
                        }
                    },
                    {
                        key: "resetStartLocation",
                        value: function resetStartLocation(node, startLoc) {
                            _get(_get_prototype_of(ESTreeParserMixin.prototype), "resetStartLocation", this).call(this, node, startLoc);
                            toESTreeLocation(node);
                        }
                    },
                    {
                        key: "resetEndLocation",
                        value: function resetEndLocation(node) {
                            var endLoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                            _get(_get_prototype_of(ESTreeParserMixin.prototype), "resetEndLocation", this).call(this, node, endLoc);
                            toESTreeLocation(node);
                        }
                    }
                ]);
                return ESTreeParserMixin;
            }(superClass);
            return ESTreeParserMixin;
        };
        var TokContext = function TokContext(token, preserveSpace) {
            _class_call_check(this, TokContext);
            this.token = void 0;
            this.preserveSpace = void 0;
            this.token = token;
            this.preserveSpace = !!preserveSpace;
        };
        var types = {
            brace: new TokContext("{"),
            j_oTag: new TokContext("<tag"),
            j_cTag: new TokContext("</tag"),
            j_expr: new TokContext("<tag>...</tag>", true)
        };
        {
            types.template = new TokContext("`", true);
        }
        var beforeExpr = true;
        var startsExpr = true;
        var isLoop = true;
        var isAssign = true;
        var prefix = true;
        var postfix = true;
        var ExportedTokenType = function ExportedTokenType(label) {
            _class_call_check(this, ExportedTokenType);
            var conf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.label = void 0;
            this.keyword = void 0;
            this.beforeExpr = void 0;
            this.startsExpr = void 0;
            this.rightAssociative = void 0;
            this.isLoop = void 0;
            this.isAssign = void 0;
            this.prefix = void 0;
            this.postfix = void 0;
            this.binop = void 0;
            this.label = label;
            this.keyword = conf.keyword;
            this.beforeExpr = !!conf.beforeExpr;
            this.startsExpr = !!conf.startsExpr;
            this.rightAssociative = !!conf.rightAssociative;
            this.isLoop = !!conf.isLoop;
            this.isAssign = !!conf.isAssign;
            this.prefix = !!conf.prefix;
            this.postfix = !!conf.postfix;
            this.binop = conf.binop != null ? conf.binop : null;
            {
                this.updateContext = null;
            }
        };
        var keywords$1 = /* @__PURE__ */ new Map();
        function createKeyword(name) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            options.keyword = name;
            var token = createToken(name, options);
            keywords$1.set(name, token);
            return token;
        }
        function createBinop(name, binop) {
            return createToken(name, {
                beforeExpr: beforeExpr,
                binop: binop
            });
        }
        var tokenTypeCounter = -1;
        var tokenTypes = [];
        var tokenLabels = [];
        var tokenBinops = [];
        var tokenBeforeExprs = [];
        var tokenStartsExprs = [];
        var tokenPrefixes = [];
        function createToken(name) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
            ++tokenTypeCounter;
            tokenLabels.push(name);
            tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
            tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
            tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
            tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
            tokenTypes.push(new ExportedTokenType(name, options));
            return tokenTypeCounter;
        }
        function createKeywordLike(name) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
            ++tokenTypeCounter;
            keywords$1.set(name, tokenTypeCounter);
            tokenLabels.push(name);
            tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
            tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
            tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
            tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
            tokenTypes.push(new ExportedTokenType("name", options));
            return tokenTypeCounter;
        }
        var tt = {
            bracketL: createToken("[", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            bracketHashL: createToken("#[", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            bracketBarL: createToken("[|", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            bracketR: createToken("]"),
            bracketBarR: createToken("|]"),
            braceL: createToken("{", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            braceBarL: createToken("{|", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            braceHashL: createToken("#{", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            braceR: createToken("}"),
            braceBarR: createToken("|}"),
            parenL: createToken("(", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            parenR: createToken(")"),
            comma: createToken(",", {
                beforeExpr: beforeExpr
            }),
            semi: createToken(";", {
                beforeExpr: beforeExpr
            }),
            colon: createToken(":", {
                beforeExpr: beforeExpr
            }),
            doubleColon: createToken("::", {
                beforeExpr: beforeExpr
            }),
            dot: createToken("."),
            question: createToken("?", {
                beforeExpr: beforeExpr
            }),
            questionDot: createToken("?."),
            arrow: createToken("=>", {
                beforeExpr: beforeExpr
            }),
            template: createToken("template"),
            ellipsis: createToken("...", {
                beforeExpr: beforeExpr
            }),
            backQuote: createToken("`", {
                startsExpr: startsExpr
            }),
            dollarBraceL: createToken("${", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            templateTail: createToken("...`", {
                startsExpr: startsExpr
            }),
            templateNonTail: createToken("...${", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            at: createToken("@"),
            hash: createToken("#", {
                startsExpr: startsExpr
            }),
            interpreterDirective: createToken("#!..."),
            eq: createToken("=", {
                beforeExpr: beforeExpr,
                isAssign: isAssign
            }),
            assign: createToken("_=", {
                beforeExpr: beforeExpr,
                isAssign: isAssign
            }),
            slashAssign: createToken("_=", {
                beforeExpr: beforeExpr,
                isAssign: isAssign
            }),
            xorAssign: createToken("_=", {
                beforeExpr: beforeExpr,
                isAssign: isAssign
            }),
            moduloAssign: createToken("_=", {
                beforeExpr: beforeExpr,
                isAssign: isAssign
            }),
            incDec: createToken("++/--", {
                prefix: prefix,
                postfix: postfix,
                startsExpr: startsExpr
            }),
            bang: createToken("!", {
                beforeExpr: beforeExpr,
                prefix: prefix,
                startsExpr: startsExpr
            }),
            tilde: createToken("~", {
                beforeExpr: beforeExpr,
                prefix: prefix,
                startsExpr: startsExpr
            }),
            doubleCaret: createToken("^^", {
                startsExpr: startsExpr
            }),
            doubleAt: createToken("@@", {
                startsExpr: startsExpr
            }),
            pipeline: createBinop("|>", 0),
            nullishCoalescing: createBinop("??", 1),
            logicalOR: createBinop("||", 1),
            logicalAND: createBinop("&&", 2),
            bitwiseOR: createBinop("|", 3),
            bitwiseXOR: createBinop("^", 4),
            bitwiseAND: createBinop("&", 5),
            equality: createBinop("==/!=/===/!==", 6),
            lt: createBinop("</>/<=/>=", 7),
            gt: createBinop("</>/<=/>=", 7),
            relational: createBinop("</>/<=/>=", 7),
            bitShift: createBinop("<</>>/>>>", 8),
            bitShiftL: createBinop("<</>>/>>>", 8),
            bitShiftR: createBinop("<</>>/>>>", 8),
            plusMin: createToken("+/-", {
                beforeExpr: beforeExpr,
                binop: 9,
                prefix: prefix,
                startsExpr: startsExpr
            }),
            modulo: createToken("%", {
                binop: 10,
                startsExpr: startsExpr
            }),
            star: createToken("*", {
                binop: 10
            }),
            slash: createBinop("/", 10),
            exponent: createToken("**", {
                beforeExpr: beforeExpr,
                binop: 11,
                rightAssociative: true
            }),
            _in: createKeyword("in", {
                beforeExpr: beforeExpr,
                binop: 7
            }),
            _instanceof: createKeyword("instanceof", {
                beforeExpr: beforeExpr,
                binop: 7
            }),
            _break: createKeyword("break"),
            _case: createKeyword("case", {
                beforeExpr: beforeExpr
            }),
            _catch: createKeyword("catch"),
            _continue: createKeyword("continue"),
            _debugger: createKeyword("debugger"),
            _default: createKeyword("default", {
                beforeExpr: beforeExpr
            }),
            _else: createKeyword("else", {
                beforeExpr: beforeExpr
            }),
            _finally: createKeyword("finally"),
            _function: createKeyword("function", {
                startsExpr: startsExpr
            }),
            _if: createKeyword("if"),
            _return: createKeyword("return", {
                beforeExpr: beforeExpr
            }),
            _switch: createKeyword("switch"),
            _throw: createKeyword("throw", {
                beforeExpr: beforeExpr,
                prefix: prefix,
                startsExpr: startsExpr
            }),
            _try: createKeyword("try"),
            _var: createKeyword("var"),
            _const: createKeyword("const"),
            _with: createKeyword("with"),
            _new: createKeyword("new", {
                beforeExpr: beforeExpr,
                startsExpr: startsExpr
            }),
            _this: createKeyword("this", {
                startsExpr: startsExpr
            }),
            _super: createKeyword("super", {
                startsExpr: startsExpr
            }),
            _class: createKeyword("class", {
                startsExpr: startsExpr
            }),
            _extends: createKeyword("extends", {
                beforeExpr: beforeExpr
            }),
            _export: createKeyword("export"),
            _import: createKeyword("import", {
                startsExpr: startsExpr
            }),
            _null: createKeyword("null", {
                startsExpr: startsExpr
            }),
            _true: createKeyword("true", {
                startsExpr: startsExpr
            }),
            _false: createKeyword("false", {
                startsExpr: startsExpr
            }),
            _typeof: createKeyword("typeof", {
                beforeExpr: beforeExpr,
                prefix: prefix,
                startsExpr: startsExpr
            }),
            _void: createKeyword("void", {
                beforeExpr: beforeExpr,
                prefix: prefix,
                startsExpr: startsExpr
            }),
            _delete: createKeyword("delete", {
                beforeExpr: beforeExpr,
                prefix: prefix,
                startsExpr: startsExpr
            }),
            _do: createKeyword("do", {
                isLoop: isLoop,
                beforeExpr: beforeExpr
            }),
            _for: createKeyword("for", {
                isLoop: isLoop
            }),
            _while: createKeyword("while", {
                isLoop: isLoop
            }),
            _as: createKeywordLike("as", {
                startsExpr: startsExpr
            }),
            _assert: createKeywordLike("assert", {
                startsExpr: startsExpr
            }),
            _async: createKeywordLike("async", {
                startsExpr: startsExpr
            }),
            _await: createKeywordLike("await", {
                startsExpr: startsExpr
            }),
            _defer: createKeywordLike("defer", {
                startsExpr: startsExpr
            }),
            _from: createKeywordLike("from", {
                startsExpr: startsExpr
            }),
            _get: createKeywordLike("get", {
                startsExpr: startsExpr
            }),
            _let: createKeywordLike("let", {
                startsExpr: startsExpr
            }),
            _meta: createKeywordLike("meta", {
                startsExpr: startsExpr
            }),
            _of: createKeywordLike("of", {
                startsExpr: startsExpr
            }),
            _sent: createKeywordLike("sent", {
                startsExpr: startsExpr
            }),
            _set: createKeywordLike("set", {
                startsExpr: startsExpr
            }),
            _source: createKeywordLike("source", {
                startsExpr: startsExpr
            }),
            _static: createKeywordLike("static", {
                startsExpr: startsExpr
            }),
            _using: createKeywordLike("using", {
                startsExpr: startsExpr
            }),
            _yield: createKeywordLike("yield", {
                startsExpr: startsExpr
            }),
            _asserts: createKeywordLike("asserts", {
                startsExpr: startsExpr
            }),
            _checks: createKeywordLike("checks", {
                startsExpr: startsExpr
            }),
            _exports: createKeywordLike("exports", {
                startsExpr: startsExpr
            }),
            _global: createKeywordLike("global", {
                startsExpr: startsExpr
            }),
            _implements: createKeywordLike("implements", {
                startsExpr: startsExpr
            }),
            _intrinsic: createKeywordLike("intrinsic", {
                startsExpr: startsExpr
            }),
            _infer: createKeywordLike("infer", {
                startsExpr: startsExpr
            }),
            _is: createKeywordLike("is", {
                startsExpr: startsExpr
            }),
            _mixins: createKeywordLike("mixins", {
                startsExpr: startsExpr
            }),
            _proto: createKeywordLike("proto", {
                startsExpr: startsExpr
            }),
            _require: createKeywordLike("require", {
                startsExpr: startsExpr
            }),
            _satisfies: createKeywordLike("satisfies", {
                startsExpr: startsExpr
            }),
            _keyof: createKeywordLike("keyof", {
                startsExpr: startsExpr
            }),
            _readonly: createKeywordLike("readonly", {
                startsExpr: startsExpr
            }),
            _unique: createKeywordLike("unique", {
                startsExpr: startsExpr
            }),
            _abstract: createKeywordLike("abstract", {
                startsExpr: startsExpr
            }),
            _declare: createKeywordLike("declare", {
                startsExpr: startsExpr
            }),
            _enum: createKeywordLike("enum", {
                startsExpr: startsExpr
            }),
            _module: createKeywordLike("module", {
                startsExpr: startsExpr
            }),
            _namespace: createKeywordLike("namespace", {
                startsExpr: startsExpr
            }),
            _interface: createKeywordLike("interface", {
                startsExpr: startsExpr
            }),
            _type: createKeywordLike("type", {
                startsExpr: startsExpr
            }),
            _opaque: createKeywordLike("opaque", {
                startsExpr: startsExpr
            }),
            name: createToken("name", {
                startsExpr: startsExpr
            }),
            placeholder: createToken("%%", {
                startsExpr: true
            }),
            string: createToken("string", {
                startsExpr: startsExpr
            }),
            num: createToken("num", {
                startsExpr: startsExpr
            }),
            bigint: createToken("bigint", {
                startsExpr: startsExpr
            }),
            decimal: createToken("decimal", {
                startsExpr: startsExpr
            }),
            regexp: createToken("regexp", {
                startsExpr: startsExpr
            }),
            privateName: createToken("#name", {
                startsExpr: startsExpr
            }),
            eof: createToken("eof"),
            jsxName: createToken("jsxName"),
            jsxText: createToken("jsxText", {
                beforeExpr: true
            }),
            jsxTagStart: createToken("jsxTagStart", {
                startsExpr: true
            }),
            jsxTagEnd: createToken("jsxTagEnd")
        };
        function tokenIsIdentifier(token) {
            return token >= 93 && token <= 133;
        }
        function tokenKeywordOrIdentifierIsKeyword(token) {
            return token <= 92;
        }
        function tokenIsKeywordOrIdentifier(token) {
            return token >= 58 && token <= 133;
        }
        function tokenIsLiteralPropertyName(token) {
            return token >= 58 && token <= 137;
        }
        function tokenComesBeforeExpression(token) {
            return tokenBeforeExprs[token];
        }
        function tokenCanStartExpression(token) {
            return tokenStartsExprs[token];
        }
        function tokenIsAssignment(token) {
            return token >= 29 && token <= 33;
        }
        function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
            return token >= 129 && token <= 131;
        }
        function tokenIsLoop(token) {
            return token >= 90 && token <= 92;
        }
        function tokenIsKeyword(token) {
            return token >= 58 && token <= 92;
        }
        function tokenIsOperator(token) {
            return token >= 39 && token <= 59;
        }
        function tokenIsPostfix(token) {
            return token === 34;
        }
        function tokenIsPrefix(token) {
            return tokenPrefixes[token];
        }
        function tokenIsTSTypeOperator(token) {
            return token >= 121 && token <= 123;
        }
        function tokenIsTSDeclarationStart(token) {
            return token >= 124 && token <= 130;
        }
        function tokenLabelName(token) {
            return tokenLabels[token];
        }
        function tokenOperatorPrecedence(token) {
            return tokenBinops[token];
        }
        function tokenIsRightAssociative(token) {
            return token === 57;
        }
        function tokenIsTemplate(token) {
            return token >= 24 && token <= 25;
        }
        function getExportedToken(token) {
            return tokenTypes[token];
        }
        {
            tokenTypes[8].updateContext = function(context) {
                context.pop();
            };
            tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = function(context) {
                context.push(types.brace);
            };
            tokenTypes[22].updateContext = function(context) {
                if (context[context.length - 1] === types.template) {
                    context.pop();
                } else {
                    context.push(types.template);
                }
            };
            tokenTypes[143].updateContext = function(context) {
                context.push(types.j_expr, types.j_oTag);
            };
        }
        var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
        var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
        var astralIdentifierStartCodes = [
            0,
            11,
            2,
            25,
            2,
            18,
            2,
            1,
            2,
            14,
            3,
            13,
            35,
            122,
            70,
            52,
            268,
            28,
            4,
            48,
            48,
            31,
            14,
            29,
            6,
            37,
            11,
            29,
            3,
            35,
            5,
            7,
            2,
            4,
            43,
            157,
            19,
            35,
            5,
            35,
            5,
            39,
            9,
            51,
            13,
            10,
            2,
            14,
            2,
            6,
            2,
            1,
            2,
            10,
            2,
            14,
            2,
            6,
            2,
            1,
            4,
            51,
            13,
            310,
            10,
            21,
            11,
            7,
            25,
            5,
            2,
            41,
            2,
            8,
            70,
            5,
            3,
            0,
            2,
            43,
            2,
            1,
            4,
            0,
            3,
            22,
            11,
            22,
            10,
            30,
            66,
            18,
            2,
            1,
            11,
            21,
            11,
            25,
            71,
            55,
            7,
            1,
            65,
            0,
            16,
            3,
            2,
            2,
            2,
            28,
            43,
            28,
            4,
            28,
            36,
            7,
            2,
            27,
            28,
            53,
            11,
            21,
            11,
            18,
            14,
            17,
            111,
            72,
            56,
            50,
            14,
            50,
            14,
            35,
            39,
            27,
            10,
            22,
            251,
            41,
            7,
            1,
            17,
            2,
            60,
            28,
            11,
            0,
            9,
            21,
            43,
            17,
            47,
            20,
            28,
            22,
            13,
            52,
            58,
            1,
            3,
            0,
            14,
            44,
            33,
            24,
            27,
            35,
            30,
            0,
            3,
            0,
            9,
            34,
            4,
            0,
            13,
            47,
            15,
            3,
            22,
            0,
            2,
            0,
            36,
            17,
            2,
            24,
            20,
            1,
            64,
            6,
            2,
            0,
            2,
            3,
            2,
            14,
            2,
            9,
            8,
            46,
            39,
            7,
            3,
            1,
            3,
            21,
            2,
            6,
            2,
            1,
            2,
            4,
            4,
            0,
            19,
            0,
            13,
            4,
            31,
            9,
            2,
            0,
            3,
            0,
            2,
            37,
            2,
            0,
            26,
            0,
            2,
            0,
            45,
            52,
            19,
            3,
            21,
            2,
            31,
            47,
            21,
            1,
            2,
            0,
            185,
            46,
            42,
            3,
            37,
            47,
            21,
            0,
            60,
            42,
            14,
            0,
            72,
            26,
            38,
            6,
            186,
            43,
            117,
            63,
            32,
            7,
            3,
            0,
            3,
            7,
            2,
            1,
            2,
            23,
            16,
            0,
            2,
            0,
            95,
            7,
            3,
            38,
            17,
            0,
            2,
            0,
            29,
            0,
            11,
            39,
            8,
            0,
            22,
            0,
            12,
            45,
            20,
            0,
            19,
            72,
            200,
            32,
            32,
            8,
            2,
            36,
            18,
            0,
            50,
            29,
            113,
            6,
            2,
            1,
            2,
            37,
            22,
            0,
            26,
            5,
            2,
            1,
            2,
            31,
            15,
            0,
            328,
            18,
            16,
            0,
            2,
            12,
            2,
            33,
            125,
            0,
            80,
            921,
            103,
            110,
            18,
            195,
            2637,
            96,
            16,
            1071,
            18,
            5,
            26,
            3994,
            6,
            582,
            6842,
            29,
            1763,
            568,
            8,
            30,
            18,
            78,
            18,
            29,
            19,
            47,
            17,
            3,
            32,
            20,
            6,
            18,
            433,
            44,
            212,
            63,
            129,
            74,
            6,
            0,
            67,
            12,
            65,
            1,
            2,
            0,
            29,
            6135,
            9,
            1237,
            42,
            9,
            8936,
            3,
            2,
            6,
            2,
            1,
            2,
            290,
            16,
            0,
            30,
            2,
            3,
            0,
            15,
            3,
            9,
            395,
            2309,
            106,
            6,
            12,
            4,
            8,
            8,
            9,
            5991,
            84,
            2,
            70,
            2,
            1,
            3,
            0,
            3,
            1,
            3,
            3,
            2,
            11,
            2,
            0,
            2,
            6,
            2,
            64,
            2,
            3,
            3,
            7,
            2,
            6,
            2,
            27,
            2,
            3,
            2,
            4,
            2,
            0,
            4,
            6,
            2,
            339,
            3,
            24,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            7,
            1845,
            30,
            7,
            5,
            262,
            61,
            147,
            44,
            11,
            6,
            17,
            0,
            322,
            29,
            19,
            43,
            485,
            27,
            229,
            29,
            3,
            0,
            496,
            6,
            2,
            3,
            2,
            1,
            2,
            14,
            2,
            196,
            60,
            67,
            8,
            0,
            1205,
            3,
            2,
            26,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            9,
            2,
            3,
            2,
            0,
            2,
            0,
            7,
            0,
            5,
            0,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            1,
            2,
            0,
            3,
            3,
            2,
            6,
            2,
            3,
            2,
            3,
            2,
            0,
            2,
            9,
            2,
            16,
            6,
            2,
            2,
            4,
            2,
            16,
            4421,
            42719,
            33,
            4153,
            7,
            221,
            3,
            5761,
            15,
            7472,
            16,
            621,
            2467,
            541,
            1507,
            4938,
            6,
            4191
        ];
        var astralIdentifierCodes = [
            509,
            0,
            227,
            0,
            150,
            4,
            294,
            9,
            1368,
            2,
            2,
            1,
            6,
            3,
            41,
            2,
            5,
            0,
            166,
            1,
            574,
            3,
            9,
            9,
            7,
            9,
            32,
            4,
            318,
            1,
            80,
            3,
            71,
            10,
            50,
            3,
            123,
            2,
            54,
            14,
            32,
            10,
            3,
            1,
            11,
            3,
            46,
            10,
            8,
            0,
            46,
            9,
            7,
            2,
            37,
            13,
            2,
            9,
            6,
            1,
            45,
            0,
            13,
            2,
            49,
            13,
            9,
            3,
            2,
            11,
            83,
            11,
            7,
            0,
            3,
            0,
            158,
            11,
            6,
            9,
            7,
            3,
            56,
            1,
            2,
            6,
            3,
            1,
            3,
            2,
            10,
            0,
            11,
            1,
            3,
            6,
            4,
            4,
            68,
            8,
            2,
            0,
            3,
            0,
            2,
            3,
            2,
            4,
            2,
            0,
            15,
            1,
            83,
            17,
            10,
            9,
            5,
            0,
            82,
            19,
            13,
            9,
            214,
            6,
            3,
            8,
            28,
            1,
            83,
            16,
            16,
            9,
            82,
            12,
            9,
            9,
            7,
            19,
            58,
            14,
            5,
            9,
            243,
            14,
            166,
            9,
            71,
            5,
            2,
            1,
            3,
            3,
            2,
            0,
            2,
            1,
            13,
            9,
            120,
            6,
            3,
            6,
            4,
            0,
            29,
            9,
            41,
            6,
            2,
            3,
            9,
            0,
            10,
            10,
            47,
            15,
            343,
            9,
            54,
            7,
            2,
            7,
            17,
            9,
            57,
            21,
            2,
            13,
            123,
            5,
            4,
            0,
            2,
            1,
            2,
            6,
            2,
            0,
            9,
            9,
            49,
            4,
            2,
            1,
            2,
            4,
            9,
            9,
            330,
            3,
            10,
            1,
            2,
            0,
            49,
            6,
            4,
            4,
            14,
            10,
            5350,
            0,
            7,
            14,
            11465,
            27,
            2343,
            9,
            87,
            9,
            39,
            4,
            60,
            6,
            26,
            9,
            535,
            9,
            470,
            0,
            2,
            54,
            8,
            3,
            82,
            0,
            12,
            1,
            19628,
            1,
            4178,
            9,
            519,
            45,
            3,
            22,
            543,
            4,
            4,
            5,
            9,
            7,
            3,
            6,
            31,
            3,
            149,
            2,
            1418,
            49,
            513,
            54,
            5,
            49,
            9,
            0,
            15,
            0,
            23,
            4,
            2,
            14,
            1361,
            6,
            2,
            16,
            3,
            6,
            2,
            1,
            2,
            4,
            101,
            0,
            161,
            6,
            10,
            9,
            357,
            0,
            62,
            13,
            499,
            13,
            245,
            1,
            2,
            9,
            726,
            6,
            110,
            6,
            6,
            9,
            4759,
            9,
            787719,
            239
        ];
        function isInAstralSet(code2, set3) {
            var pos = 65536;
            for(var i = 0, length = set3.length; i < length; i += 2){
                pos += set3[i];
                if (pos > code2) return false;
                pos += set3[i + 1];
                if (pos >= code2) return true;
            }
            return false;
        }
        function isIdentifierStart(code2) {
            if (code2 < 65) return code2 === 36;
            if (code2 <= 90) return true;
            if (code2 < 97) return code2 === 95;
            if (code2 <= 122) return true;
            if (code2 <= 65535) {
                return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
            }
            return isInAstralSet(code2, astralIdentifierStartCodes);
        }
        function isIdentifierChar(code2) {
            if (code2 < 48) return code2 === 36;
            if (code2 < 58) return true;
            if (code2 < 65) return false;
            if (code2 <= 90) return true;
            if (code2 < 97) return code2 === 95;
            if (code2 <= 122) return true;
            if (code2 <= 65535) {
                return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
            }
            return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
        }
        var reservedWords = {
            keyword: [
                "break",
                "case",
                "catch",
                "continue",
                "debugger",
                "default",
                "do",
                "else",
                "finally",
                "for",
                "function",
                "if",
                "return",
                "switch",
                "throw",
                "try",
                "var",
                "const",
                "while",
                "with",
                "new",
                "this",
                "super",
                "class",
                "extends",
                "export",
                "import",
                "null",
                "true",
                "false",
                "in",
                "instanceof",
                "typeof",
                "void",
                "delete"
            ],
            strict: [
                "implements",
                "interface",
                "let",
                "package",
                "private",
                "protected",
                "public",
                "static",
                "yield"
            ],
            strictBind: [
                "eval",
                "arguments"
            ]
        };
        var keywords = new Set(reservedWords.keyword);
        var reservedWordsStrictSet = new Set(reservedWords.strict);
        var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
        function isReservedWord(word, inModule) {
            return inModule && word === "await" || word === "enum";
        }
        function isStrictReservedWord(word, inModule) {
            return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
        }
        function isStrictBindOnlyReservedWord(word) {
            return reservedWordsStrictBindSet.has(word);
        }
        function isStrictBindReservedWord(word, inModule) {
            return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
        }
        function isKeyword(word) {
            return keywords.has(word);
        }
        function isIteratorStart(current, next, next2) {
            return current === 64 && next === 64 && isIdentifierStart(next2);
        }
        var reservedWordLikeSet = /* @__PURE__ */ new Set([
            "break",
            "case",
            "catch",
            "continue",
            "debugger",
            "default",
            "do",
            "else",
            "finally",
            "for",
            "function",
            "if",
            "return",
            "switch",
            "throw",
            "try",
            "var",
            "const",
            "while",
            "with",
            "new",
            "this",
            "super",
            "class",
            "extends",
            "export",
            "import",
            "null",
            "true",
            "false",
            "in",
            "instanceof",
            "typeof",
            "void",
            "delete",
            "implements",
            "interface",
            "let",
            "package",
            "private",
            "protected",
            "public",
            "static",
            "yield",
            "eval",
            "arguments",
            "enum",
            "await"
        ]);
        function canBeReservedWord(word) {
            return reservedWordLikeSet.has(word);
        }
        var Scope = function Scope(flags) {
            _class_call_check(this, Scope);
            this.flags = 0;
            this.names = /* @__PURE__ */ new Map();
            this.firstLexicalName = "";
            this.flags = flags;
        };
        var ScopeHandler = /*#__PURE__*/ function() {
            function ScopeHandler(parser, inModule) {
                _class_call_check(this, ScopeHandler);
                this.parser = void 0;
                this.scopeStack = [];
                this.inModule = void 0;
                this.undefinedExports = /* @__PURE__ */ new Map();
                this.parser = parser;
                this.inModule = inModule;
            }
            _create_class(ScopeHandler, [
                {
                    key: "inTopLevel",
                    get: function get() {
                        return (this.currentScope().flags & 1) > 0;
                    }
                },
                {
                    key: "inFunction",
                    get: function get() {
                        return (this.currentVarScopeFlags() & 2) > 0;
                    }
                },
                {
                    key: "allowSuper",
                    get: function get() {
                        return (this.currentThisScopeFlags() & 16) > 0;
                    }
                },
                {
                    key: "allowDirectSuper",
                    get: function get() {
                        return (this.currentThisScopeFlags() & 32) > 0;
                    }
                },
                {
                    key: "inClass",
                    get: function get() {
                        return (this.currentThisScopeFlags() & 64) > 0;
                    }
                },
                {
                    key: "inClassAndNotInNonArrowFunction",
                    get: function get() {
                        var flags = this.currentThisScopeFlags();
                        return (flags & 64) > 0 && (flags & 2) === 0;
                    }
                },
                {
                    key: "inStaticBlock",
                    get: function get() {
                        for(var i = this.scopeStack.length - 1;; i--){
                            var flags = this.scopeStack[i].flags;
                            if (flags & 128) {
                                return true;
                            }
                            if (flags & (387 | 64)) {
                                return false;
                            }
                        }
                    }
                },
                {
                    key: "inNonArrowFunction",
                    get: function get() {
                        return (this.currentThisScopeFlags() & 2) > 0;
                    }
                },
                {
                    key: "treatFunctionsAsVar",
                    get: function get() {
                        return this.treatFunctionsAsVarInScope(this.currentScope());
                    }
                },
                {
                    key: "createScope",
                    value: function createScope(flags) {
                        return new Scope(flags);
                    }
                },
                {
                    key: "enter",
                    value: function enter(flags) {
                        this.scopeStack.push(this.createScope(flags));
                    }
                },
                {
                    key: "exit",
                    value: function exit() {
                        var scope = this.scopeStack.pop();
                        return scope.flags;
                    }
                },
                {
                    key: "treatFunctionsAsVarInScope",
                    value: function treatFunctionsAsVarInScope(scope) {
                        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
                    }
                },
                {
                    key: "declareName",
                    value: function declareName(name, bindingType, loc) {
                        var scope = this.currentScope();
                        if (bindingType & 8 || bindingType & 16) {
                            this.checkRedeclarationInScope(scope, name, bindingType, loc);
                            var type = scope.names.get(name) || 0;
                            if (bindingType & 16) {
                                type = type | 4;
                            } else {
                                if (!scope.firstLexicalName) {
                                    scope.firstLexicalName = name;
                                }
                                type = type | 2;
                            }
                            scope.names.set(name, type);
                            if (bindingType & 8) {
                                this.maybeExportDefined(scope, name);
                            }
                        } else if (bindingType & 4) {
                            for(var i = this.scopeStack.length - 1; i >= 0; --i){
                                scope = this.scopeStack[i];
                                this.checkRedeclarationInScope(scope, name, bindingType, loc);
                                scope.names.set(name, (scope.names.get(name) || 0) | 1);
                                this.maybeExportDefined(scope, name);
                                if (scope.flags & 387) break;
                            }
                        }
                        if (this.parser.inModule && scope.flags & 1) {
                            this.undefinedExports.delete(name);
                        }
                    }
                },
                {
                    key: "maybeExportDefined",
                    value: function maybeExportDefined(scope, name) {
                        if (this.parser.inModule && scope.flags & 1) {
                            this.undefinedExports.delete(name);
                        }
                    }
                },
                {
                    key: "checkRedeclarationInScope",
                    value: function checkRedeclarationInScope(scope, name, bindingType, loc) {
                        if (this.isRedeclaredInScope(scope, name, bindingType)) {
                            this.parser.raise(Errors.VarRedeclaration, loc, {
                                identifierName: name
                            });
                        }
                    }
                },
                {
                    key: "isRedeclaredInScope",
                    value: function isRedeclaredInScope(scope, name, bindingType) {
                        if (!(bindingType & 1)) return false;
                        if (bindingType & 8) {
                            return scope.names.has(name);
                        }
                        var type = scope.names.get(name);
                        if (bindingType & 16) {
                            return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
                        }
                        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
                    }
                },
                {
                    key: "checkLocalExport",
                    value: function checkLocalExport(id) {
                        var name = id.name;
                        var topLevelScope = this.scopeStack[0];
                        if (!topLevelScope.names.has(name)) {
                            this.undefinedExports.set(name, id.loc.start);
                        }
                    }
                },
                {
                    key: "currentScope",
                    value: function currentScope() {
                        return this.scopeStack[this.scopeStack.length - 1];
                    }
                },
                {
                    key: "currentVarScopeFlags",
                    value: function currentVarScopeFlags() {
                        for(var i = this.scopeStack.length - 1;; i--){
                            var flags = this.scopeStack[i].flags;
                            if (flags & 387) {
                                return flags;
                            }
                        }
                    }
                },
                {
                    key: "currentThisScopeFlags",
                    value: function currentThisScopeFlags() {
                        for(var i = this.scopeStack.length - 1;; i--){
                            var flags = this.scopeStack[i].flags;
                            if (flags & (387 | 64) && !(flags & 4)) {
                                return flags;
                            }
                        }
                    }
                }
            ]);
            return ScopeHandler;
        }();
        var FlowScope = /*#__PURE__*/ function(Scope) {
            _inherits(FlowScope, Scope);
            function FlowScope() {
                _class_call_check(this, FlowScope);
                var _this;
                _this = _call_super(this, FlowScope, arguments);
                _this.declareFunctions = /* @__PURE__ */ new Set();
                return _this;
            }
            return FlowScope;
        }(Scope);
        var FlowScopeHandler = /*#__PURE__*/ function(ScopeHandler) {
            _inherits(FlowScopeHandler, ScopeHandler);
            function FlowScopeHandler() {
                _class_call_check(this, FlowScopeHandler);
                return _call_super(this, FlowScopeHandler, arguments);
            }
            _create_class(FlowScopeHandler, [
                {
                    key: "createScope",
                    value: function createScope(flags) {
                        return new FlowScope(flags);
                    }
                },
                {
                    key: "declareName",
                    value: function declareName(name, bindingType, loc) {
                        var scope = this.currentScope();
                        if (bindingType & 2048) {
                            this.checkRedeclarationInScope(scope, name, bindingType, loc);
                            this.maybeExportDefined(scope, name);
                            scope.declareFunctions.add(name);
                            return;
                        }
                        _get(_get_prototype_of(FlowScopeHandler.prototype), "declareName", this).call(this, name, bindingType, loc);
                    }
                },
                {
                    key: "isRedeclaredInScope",
                    value: function isRedeclaredInScope(scope, name, bindingType) {
                        if (_get(_get_prototype_of(FlowScopeHandler.prototype), "isRedeclaredInScope", this).call(this, scope, name, bindingType)) return true;
                        if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
                            var type = scope.names.get(name);
                            return (type & 4) > 0 || (type & 2) > 0;
                        }
                        return false;
                    }
                },
                {
                    key: "checkLocalExport",
                    value: function checkLocalExport(id) {
                        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
                            _get(_get_prototype_of(FlowScopeHandler.prototype), "checkLocalExport", this).call(this, id);
                        }
                    }
                }
            ]);
            return FlowScopeHandler;
        }(ScopeHandler);
        var BaseParser = /*#__PURE__*/ function() {
            function BaseParser() {
                _class_call_check(this, BaseParser);
                this.sawUnambiguousESM = false;
                this.ambiguousScriptDifferentAst = false;
            }
            _create_class(BaseParser, [
                {
                    key: "sourceToOffsetPos",
                    value: function sourceToOffsetPos(sourcePos) {
                        return sourcePos + this.startIndex;
                    }
                },
                {
                    key: "offsetToSourcePos",
                    value: function offsetToSourcePos(offsetPos) {
                        return offsetPos - this.startIndex;
                    }
                },
                {
                    key: "hasPlugin",
                    value: function hasPlugin(pluginConfig) {
                        if (typeof pluginConfig === "string") {
                            return this.plugins.has(pluginConfig);
                        } else {
                            var _pluginConfig = _sliced_to_array(pluginConfig, 2), pluginName = _pluginConfig[0], pluginOptions = _pluginConfig[1];
                            if (!this.hasPlugin(pluginName)) {
                                return false;
                            }
                            var actualOptions = this.plugins.get(pluginName);
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = Object.keys(pluginOptions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var key2 = _step.value;
                                    if ((actualOptions == null ? void 0 : actualOptions[key2]) !== pluginOptions[key2]) {
                                        return false;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            return true;
                        }
                    }
                },
                {
                    key: "getPluginOption",
                    value: function getPluginOption(plugin, name) {
                        var _this$plugins$get;
                        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
                    }
                }
            ]);
            return BaseParser;
        }();
        function setTrailingComments(node, comments) {
            if (node.trailingComments === void 0) {
                node.trailingComments = comments;
            } else {
                var _node_trailingComments;
                (_node_trailingComments = node.trailingComments).unshift.apply(_node_trailingComments, _to_consumable_array(comments));
            }
        }
        function setLeadingComments(node, comments) {
            if (node.leadingComments === void 0) {
                node.leadingComments = comments;
            } else {
                var _node_leadingComments;
                (_node_leadingComments = node.leadingComments).unshift.apply(_node_leadingComments, _to_consumable_array(comments));
            }
        }
        function setInnerComments(node, comments) {
            if (node.innerComments === void 0) {
                node.innerComments = comments;
            } else {
                var _node_innerComments;
                (_node_innerComments = node.innerComments).unshift.apply(_node_innerComments, _to_consumable_array(comments));
            }
        }
        function adjustInnerComments(node, elements, commentWS) {
            var lastElement = null;
            var i = elements.length;
            while(lastElement === null && i > 0){
                lastElement = elements[--i];
            }
            if (lastElement === null || lastElement.start > commentWS.start) {
                setInnerComments(node, commentWS.comments);
            } else {
                setTrailingComments(lastElement, commentWS.comments);
            }
        }
        var CommentsParser = /*#__PURE__*/ function(BaseParser) {
            _inherits(CommentsParser, BaseParser);
            function CommentsParser() {
                _class_call_check(this, CommentsParser);
                return _call_super(this, CommentsParser, arguments);
            }
            _create_class(CommentsParser, [
                {
                    key: "addComment",
                    value: function addComment(comment) {
                        if (this.filename) comment.loc.filename = this.filename;
                        var commentsLen = this.state.commentsLen;
                        if (this.comments.length !== commentsLen) {
                            this.comments.length = commentsLen;
                        }
                        this.comments.push(comment);
                        this.state.commentsLen++;
                    }
                },
                {
                    key: "processComment",
                    value: function processComment(node) {
                        var commentStack = this.state.commentStack;
                        var commentStackLength = commentStack.length;
                        if (commentStackLength === 0) return;
                        var i = commentStackLength - 1;
                        var lastCommentWS = commentStack[i];
                        if (lastCommentWS.start === node.end) {
                            lastCommentWS.leadingNode = node;
                            i--;
                        }
                        var nodeStart = node.start;
                        for(; i >= 0; i--){
                            var commentWS = commentStack[i];
                            var commentEnd = commentWS.end;
                            if (commentEnd > nodeStart) {
                                commentWS.containingNode = node;
                                this.finalizeComment(commentWS);
                                commentStack.splice(i, 1);
                            } else {
                                if (commentEnd === nodeStart) {
                                    commentWS.trailingNode = node;
                                }
                                break;
                            }
                        }
                    }
                },
                {
                    key: "finalizeComment",
                    value: function finalizeComment(commentWS) {
                        var comments = commentWS.comments;
                        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
                            if (commentWS.leadingNode !== null) {
                                setTrailingComments(commentWS.leadingNode, comments);
                            }
                            if (commentWS.trailingNode !== null) {
                                setLeadingComments(commentWS.trailingNode, comments);
                            }
                        } else {
                            var node = commentWS.containingNode, commentStart = commentWS.start;
                            if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
                                switch(node.type){
                                    case "ObjectExpression":
                                    case "ObjectPattern":
                                    case "RecordExpression":
                                        adjustInnerComments(node, node.properties, commentWS);
                                        break;
                                    case "CallExpression":
                                    case "OptionalCallExpression":
                                        adjustInnerComments(node, node.arguments, commentWS);
                                        break;
                                    case "FunctionDeclaration":
                                    case "FunctionExpression":
                                    case "ArrowFunctionExpression":
                                    case "ObjectMethod":
                                    case "ClassMethod":
                                    case "ClassPrivateMethod":
                                        adjustInnerComments(node, node.params, commentWS);
                                        break;
                                    case "ArrayExpression":
                                    case "ArrayPattern":
                                    case "TupleExpression":
                                        adjustInnerComments(node, node.elements, commentWS);
                                        break;
                                    case "ExportNamedDeclaration":
                                    case "ImportDeclaration":
                                        adjustInnerComments(node, node.specifiers, commentWS);
                                        break;
                                    default:
                                        {
                                            setInnerComments(node, comments);
                                        }
                                }
                            } else {
                                setInnerComments(node, comments);
                            }
                        }
                    }
                },
                {
                    key: "finalizeRemainingComments",
                    value: function finalizeRemainingComments() {
                        var commentStack = this.state.commentStack;
                        for(var i = commentStack.length - 1; i >= 0; i--){
                            this.finalizeComment(commentStack[i]);
                        }
                        this.state.commentStack = [];
                    }
                },
                {
                    key: "resetPreviousNodeTrailingComments",
                    value: function resetPreviousNodeTrailingComments(node) {
                        var commentStack = this.state.commentStack;
                        var length = commentStack.length;
                        if (length === 0) return;
                        var commentWS = commentStack[length - 1];
                        if (commentWS.leadingNode === node) {
                            commentWS.leadingNode = null;
                        }
                    }
                },
                {
                    key: "resetPreviousIdentifierLeadingComments",
                    value: function resetPreviousIdentifierLeadingComments(node) {
                        var commentStack = this.state.commentStack;
                        var length = commentStack.length;
                        if (length === 0) return;
                        if (commentStack[length - 1].trailingNode === node) {
                            commentStack[length - 1].trailingNode = null;
                        } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
                            commentStack[length - 2].trailingNode = null;
                        }
                    }
                },
                {
                    key: "takeSurroundingComments",
                    value: function takeSurroundingComments(node, start, end) {
                        var commentStack = this.state.commentStack;
                        var commentStackLength = commentStack.length;
                        if (commentStackLength === 0) return;
                        var i = commentStackLength - 1;
                        for(; i >= 0; i--){
                            var commentWS = commentStack[i];
                            var commentEnd = commentWS.end;
                            var commentStart = commentWS.start;
                            if (commentStart === end) {
                                commentWS.leadingNode = node;
                            } else if (commentEnd === start) {
                                commentWS.trailingNode = node;
                            } else if (commentEnd < start) {
                                break;
                            }
                        }
                    }
                }
            ]);
            return CommentsParser;
        }(BaseParser);
        var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
        var lineBreakG = new RegExp(lineBreak.source, "g");
        function isNewLine(code2) {
            switch(code2){
                case 10:
                case 13:
                case 8232:
                case 8233:
                    return true;
                default:
                    return false;
            }
        }
        function hasNewLine(input2, start, end) {
            for(var i = start; i < end; i++){
                if (isNewLine(input2.charCodeAt(i))) {
                    return true;
                }
            }
            return false;
        }
        var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
        function isWhitespace(code2) {
            switch(code2){
                case 9:
                case 11:
                case 12:
                case 32:
                case 160:
                case 5760:
                case 8192:
                case 8193:
                case 8194:
                case 8195:
                case 8196:
                case 8197:
                case 8198:
                case 8199:
                case 8200:
                case 8201:
                case 8202:
                case 8239:
                case 8287:
                case 12288:
                case 65279:
                    return true;
                default:
                    return false;
            }
        }
        var State = /*#__PURE__*/ function() {
            function _State() {
                _class_call_check(this, _State);
                this.flags = 1024;
                this.startIndex = void 0;
                this.curLine = void 0;
                this.lineStart = void 0;
                this.startLoc = void 0;
                this.endLoc = void 0;
                this.errors = [];
                this.potentialArrowAt = -1;
                this.noArrowAt = [];
                this.noArrowParamsConversionAt = [];
                this.topicContext = {
                    maxNumOfResolvableTopics: 0,
                    maxTopicIndex: null
                };
                this.labels = [];
                this.commentsLen = 0;
                this.commentStack = [];
                this.pos = 0;
                this.type = 140;
                this.value = null;
                this.start = 0;
                this.end = 0;
                this.lastTokEndLoc = null;
                this.lastTokStartLoc = null;
                this.context = [
                    types.brace
                ];
                this.firstInvalidTemplateEscapePos = null;
                this.strictErrors = /* @__PURE__ */ new Map();
                this.tokensLength = 0;
            }
            _create_class(_State, [
                {
                    key: "strict",
                    get: function get() {
                        return (this.flags & 1) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 1;
                        else this.flags &= -2;
                    }
                },
                {
                    key: "init",
                    value: function init(_ref38) {
                        var strictMode = _ref38.strictMode, sourceType = _ref38.sourceType, startIndex = _ref38.startIndex, startLine = _ref38.startLine, startColumn = _ref38.startColumn;
                        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
                        this.startIndex = startIndex;
                        this.curLine = startLine;
                        this.lineStart = -startColumn;
                        this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
                    }
                },
                {
                    key: "maybeInArrowParameters",
                    get: function get() {
                        return (this.flags & 2) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 2;
                        else this.flags &= -3;
                    }
                },
                {
                    key: "inType",
                    get: function get() {
                        return (this.flags & 4) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 4;
                        else this.flags &= -5;
                    }
                },
                {
                    key: "noAnonFunctionType",
                    get: function get() {
                        return (this.flags & 8) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 8;
                        else this.flags &= -9;
                    }
                },
                {
                    key: "hasFlowComment",
                    get: function get() {
                        return (this.flags & 16) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 16;
                        else this.flags &= -17;
                    }
                },
                {
                    key: "isAmbientContext",
                    get: function get() {
                        return (this.flags & 32) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 32;
                        else this.flags &= -33;
                    }
                },
                {
                    key: "inAbstractClass",
                    get: function get() {
                        return (this.flags & 64) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 64;
                        else this.flags &= -65;
                    }
                },
                {
                    key: "inDisallowConditionalTypesContext",
                    get: function get() {
                        return (this.flags & 128) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 128;
                        else this.flags &= -129;
                    }
                },
                {
                    key: "soloAwait",
                    get: function get() {
                        return (this.flags & 256) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 256;
                        else this.flags &= -257;
                    }
                },
                {
                    key: "inFSharpPipelineDirectBody",
                    get: function get() {
                        return (this.flags & 512) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 512;
                        else this.flags &= -513;
                    }
                },
                {
                    key: "canStartJSXElement",
                    get: function get() {
                        return (this.flags & 1024) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 1024;
                        else this.flags &= -1025;
                    }
                },
                {
                    key: "containsEsc",
                    get: function get() {
                        return (this.flags & 2048) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 2048;
                        else this.flags &= -2049;
                    }
                },
                {
                    key: "hasTopLevelAwait",
                    get: function get() {
                        return (this.flags & 4096) > 0;
                    },
                    set: function set(v) {
                        if (v) this.flags |= 4096;
                        else this.flags &= -4097;
                    }
                },
                {
                    key: "curPosition",
                    value: function curPosition() {
                        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
                    }
                },
                {
                    key: "clone",
                    value: function clone() {
                        var state = new _State();
                        state.flags = this.flags;
                        state.startIndex = this.startIndex;
                        state.curLine = this.curLine;
                        state.lineStart = this.lineStart;
                        state.startLoc = this.startLoc;
                        state.endLoc = this.endLoc;
                        state.errors = this.errors.slice();
                        state.potentialArrowAt = this.potentialArrowAt;
                        state.noArrowAt = this.noArrowAt.slice();
                        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
                        state.topicContext = this.topicContext;
                        state.labels = this.labels.slice();
                        state.commentsLen = this.commentsLen;
                        state.commentStack = this.commentStack.slice();
                        state.pos = this.pos;
                        state.type = this.type;
                        state.value = this.value;
                        state.start = this.start;
                        state.end = this.end;
                        state.lastTokEndLoc = this.lastTokEndLoc;
                        state.lastTokStartLoc = this.lastTokStartLoc;
                        state.context = this.context.slice();
                        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
                        state.strictErrors = this.strictErrors;
                        state.tokensLength = this.tokensLength;
                        return state;
                    }
                }
            ]);
            return _State;
        }();
        var _isDigit = function isDigit(code2) {
            return code2 >= 48 && code2 <= 57;
        };
        var forbiddenNumericSeparatorSiblings = {
            decBinOct: /* @__PURE__ */ new Set([
                46,
                66,
                69,
                79,
                95,
                98,
                101,
                111
            ]),
            hex: /* @__PURE__ */ new Set([
                46,
                88,
                95,
                120
            ])
        };
        var isAllowedNumericSeparatorSibling = {
            bin: function(ch) {
                return ch === 48 || ch === 49;
            },
            oct: function(ch) {
                return ch >= 48 && ch <= 55;
            },
            dec: function(ch) {
                return ch >= 48 && ch <= 57;
            },
            hex: function(ch) {
                return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
            }
        };
        function readStringContents(type, input2, pos, lineStart, curLine, errors) {
            var initialPos = pos;
            var initialLineStart = lineStart;
            var initialCurLine = curLine;
            var out = "";
            var firstInvalidLoc = null;
            var chunkStart = pos;
            var length = input2.length;
            for(;;){
                if (pos >= length) {
                    errors.unterminated(initialPos, initialLineStart, initialCurLine);
                    out += input2.slice(chunkStart, pos);
                    break;
                }
                var ch = input2.charCodeAt(pos);
                if (isStringEnd(type, ch, input2, pos)) {
                    out += input2.slice(chunkStart, pos);
                    break;
                }
                if (ch === 92) {
                    out += input2.slice(chunkStart, pos);
                    var res = readEscapedChar(input2, pos, lineStart, curLine, type === "template", errors);
                    if (res.ch === null && !firstInvalidLoc) {
                        firstInvalidLoc = {
                            pos: pos,
                            lineStart: lineStart,
                            curLine: curLine
                        };
                    } else {
                        out += res.ch;
                    }
                    var ref;
                    ref = res, pos = ref.pos, lineStart = ref.lineStart, curLine = ref.curLine, ref;
                    chunkStart = pos;
                } else if (ch === 8232 || ch === 8233) {
                    ++pos;
                    ++curLine;
                    lineStart = pos;
                } else if (ch === 10 || ch === 13) {
                    if (type === "template") {
                        out += input2.slice(chunkStart, pos) + "\n";
                        ++pos;
                        if (ch === 13 && input2.charCodeAt(pos) === 10) {
                            ++pos;
                        }
                        ++curLine;
                        chunkStart = lineStart = pos;
                    } else {
                        errors.unterminated(initialPos, initialLineStart, initialCurLine);
                    }
                } else {
                    ++pos;
                }
            }
            return {
                pos: pos,
                str: out,
                firstInvalidLoc: firstInvalidLoc,
                lineStart: lineStart,
                curLine: curLine,
                containsInvalid: !!firstInvalidLoc
            };
        }
        function isStringEnd(type, ch, input2, pos) {
            if (type === "template") {
                return ch === 96 || ch === 36 && input2.charCodeAt(pos + 1) === 123;
            }
            return ch === (type === "double" ? 34 : 39);
        }
        function readEscapedChar(input2, pos, lineStart, curLine, inTemplate, errors) {
            var throwOnInvalid = !inTemplate;
            pos++;
            var res = function(ch2) {
                return {
                    pos: pos,
                    ch: ch2,
                    lineStart: lineStart,
                    curLine: curLine
                };
            };
            var ch = input2.charCodeAt(pos++);
            switch(ch){
                case 110:
                    return res("\n");
                case 114:
                    return res("\r");
                case 120:
                    {
                        var _code;
                        var ref;
                        ref = readHexChar(input2, pos, lineStart, curLine, 2, false, throwOnInvalid, errors), _code = ref.code, pos = ref.pos, ref;
                        return res(_code === null ? null : String.fromCharCode(_code));
                    }
                case 117:
                    {
                        var _code2;
                        var ref1;
                        ref1 = readCodePoint(input2, pos, lineStart, curLine, throwOnInvalid, errors), _code2 = ref1.code, pos = ref1.pos, ref1;
                        return res(_code2 === null ? null : String.fromCodePoint(_code2));
                    }
                case 116:
                    return res("	");
                case 98:
                    return res("\b");
                case 118:
                    return res("\v");
                case 102:
                    return res("\f");
                case 13:
                    if (input2.charCodeAt(pos) === 10) {
                        ++pos;
                    }
                case 10:
                    lineStart = pos;
                    ++curLine;
                case 8232:
                case 8233:
                    return res("");
                case 56:
                case 57:
                    if (inTemplate) {
                        return res(null);
                    } else {
                        errors.strictNumericEscape(pos - 1, lineStart, curLine);
                    }
                default:
                    if (ch >= 48 && ch <= 55) {
                        var startPos = pos - 1;
                        var match = /^[0-7]+/.exec(input2.slice(startPos, pos + 2));
                        var octalStr = match[0];
                        var octal = parseInt(octalStr, 8);
                        if (octal > 255) {
                            octalStr = octalStr.slice(0, -1);
                            octal = parseInt(octalStr, 8);
                        }
                        pos += octalStr.length - 1;
                        var next = input2.charCodeAt(pos);
                        if (octalStr !== "0" || next === 56 || next === 57) {
                            if (inTemplate) {
                                return res(null);
                            } else {
                                errors.strictNumericEscape(startPos, lineStart, curLine);
                            }
                        }
                        return res(String.fromCharCode(octal));
                    }
                    return res(String.fromCharCode(ch));
            }
        }
        function readHexChar(input2, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
            var initialPos = pos;
            var n;
            var ref;
            ref = readInt(input2, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid), n = ref.n, pos = ref.pos, ref;
            if (n === null) {
                if (throwOnInvalid) {
                    errors.invalidEscapeSequence(initialPos, lineStart, curLine);
                } else {
                    pos = initialPos - 1;
                }
            }
            return {
                code: n,
                pos: pos
            };
        }
        function readInt(input2, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
            var start = pos;
            var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
            var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
            var invalid = false;
            var total = 0;
            for(var i = 0, e = len == null ? Infinity : len; i < e; ++i){
                var _code3 = input2.charCodeAt(pos);
                var val = void 0;
                if (_code3 === 95 && allowNumSeparator !== "bail") {
                    var prev = input2.charCodeAt(pos - 1);
                    var next = input2.charCodeAt(pos + 1);
                    if (!allowNumSeparator) {
                        if (bailOnError) return {
                            n: null,
                            pos: pos
                        };
                        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
                    } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                        if (bailOnError) return {
                            n: null,
                            pos: pos
                        };
                        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
                    }
                    ++pos;
                    continue;
                }
                if (_code3 >= 97) {
                    val = _code3 - 97 + 10;
                } else if (_code3 >= 65) {
                    val = _code3 - 65 + 10;
                } else if (_isDigit(_code3)) {
                    val = _code3 - 48;
                } else {
                    val = Infinity;
                }
                if (val >= radix) {
                    if (val <= 9 && bailOnError) {
                        return {
                            n: null,
                            pos: pos
                        };
                    } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                        val = 0;
                    } else if (forceLen) {
                        val = 0;
                        invalid = true;
                    } else {
                        break;
                    }
                }
                ++pos;
                total = total * radix + val;
            }
            if (pos === start || len != null && pos - start !== len || invalid) {
                return {
                    n: null,
                    pos: pos
                };
            }
            return {
                n: total,
                pos: pos
            };
        }
        function readCodePoint(input2, pos, lineStart, curLine, throwOnInvalid, errors) {
            var ch = input2.charCodeAt(pos);
            var code2;
            if (ch === 123) {
                ++pos;
                var ref;
                ref = readHexChar(input2, pos, lineStart, curLine, input2.indexOf("}", pos) - pos, true, throwOnInvalid, errors), code2 = ref.code, pos = ref.pos, ref;
                ++pos;
                if (code2 !== null && code2 > 1114111) {
                    if (throwOnInvalid) {
                        errors.invalidCodePoint(pos, lineStart, curLine);
                    } else {
                        return {
                            code: null,
                            pos: pos
                        };
                    }
                }
            } else {
                var ref1;
                ref1 = readHexChar(input2, pos, lineStart, curLine, 4, false, throwOnInvalid, errors), code2 = ref1.code, pos = ref1.pos, ref1;
            }
            return {
                code: code2,
                pos: pos
            };
        }
        function buildPosition(pos, lineStart, curLine) {
            return new Position(curLine, pos - lineStart, pos);
        }
        var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([
            103,
            109,
            115,
            105,
            121,
            117,
            100,
            118
        ]);
        var Token = function Token(state) {
            _class_call_check(this, Token);
            var startIndex = state.startIndex || 0;
            this.type = state.type;
            this.value = state.value;
            this.start = startIndex + state.start;
            this.end = startIndex + state.end;
            this.loc = new SourceLocation(state.startLoc, state.endLoc);
        };
        var Tokenizer = /*#__PURE__*/ function(CommentsParser) {
            _inherits(Tokenizer, CommentsParser);
            function Tokenizer(options, input2) {
                _class_call_check(this, Tokenizer);
                var _this;
                _this = _call_super(this, Tokenizer);
                _this.isLookahead = void 0;
                _this.tokens = [];
                _this.errorHandlers_readInt = {
                    invalidDigit: function(pos, lineStart, curLine, radix) {
                        if (!_this.options.errorRecovery) return false;
                        _this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
                            radix: radix
                        });
                        return true;
                    },
                    numericSeparatorInEscapeSequence: _this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
                    unexpectedNumericSeparator: _this.errorBuilder(Errors.UnexpectedNumericSeparator)
                };
                _this.errorHandlers_readCodePoint = Object.assign({}, _this.errorHandlers_readInt, {
                    invalidEscapeSequence: _this.errorBuilder(Errors.InvalidEscapeSequence),
                    invalidCodePoint: _this.errorBuilder(Errors.InvalidCodePoint)
                });
                _this.errorHandlers_readStringContents_string = Object.assign({}, _this.errorHandlers_readCodePoint, {
                    strictNumericEscape: function(pos, lineStart, curLine) {
                        _this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
                    },
                    unterminated: function(pos, lineStart, curLine) {
                        throw _this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
                    }
                });
                _this.errorHandlers_readStringContents_template = Object.assign({}, _this.errorHandlers_readCodePoint, {
                    strictNumericEscape: _this.errorBuilder(Errors.StrictNumericEscape),
                    unterminated: function(pos, lineStart, curLine) {
                        throw _this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
                    }
                });
                _this.state = new State();
                _this.state.init(options);
                _this.input = input2;
                _this.length = input2.length;
                _this.comments = [];
                _this.isLookahead = false;
                return _this;
            }
            _create_class(Tokenizer, [
                {
                    key: "pushToken",
                    value: function pushToken(token) {
                        this.tokens.length = this.state.tokensLength;
                        this.tokens.push(token);
                        ++this.state.tokensLength;
                    }
                },
                {
                    key: "next",
                    value: function next() {
                        this.checkKeywordEscapes();
                        if (this.options.tokens) {
                            this.pushToken(new Token(this.state));
                        }
                        this.state.lastTokEndLoc = this.state.endLoc;
                        this.state.lastTokStartLoc = this.state.startLoc;
                        this.nextToken();
                    }
                },
                {
                    key: "eat",
                    value: function eat(type) {
                        if (this.match(type)) {
                            this.next();
                            return true;
                        } else {
                            return false;
                        }
                    }
                },
                {
                    key: "match",
                    value: function match(type) {
                        return this.state.type === type;
                    }
                },
                {
                    key: "createLookaheadState",
                    value: function createLookaheadState(state) {
                        return {
                            pos: state.pos,
                            value: null,
                            type: state.type,
                            start: state.start,
                            end: state.end,
                            context: [
                                this.curContext()
                            ],
                            inType: state.inType,
                            startLoc: state.startLoc,
                            lastTokEndLoc: state.lastTokEndLoc,
                            curLine: state.curLine,
                            lineStart: state.lineStart,
                            curPosition: state.curPosition
                        };
                    }
                },
                {
                    key: "lookahead",
                    value: function lookahead() {
                        var old = this.state;
                        this.state = this.createLookaheadState(old);
                        this.isLookahead = true;
                        this.nextToken();
                        this.isLookahead = false;
                        var curr = this.state;
                        this.state = old;
                        return curr;
                    }
                },
                {
                    key: "nextTokenStart",
                    value: function nextTokenStart() {
                        return this.nextTokenStartSince(this.state.pos);
                    }
                },
                {
                    key: "nextTokenStartSince",
                    value: function nextTokenStartSince(pos) {
                        skipWhiteSpace.lastIndex = pos;
                        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
                    }
                },
                {
                    key: "lookaheadCharCode",
                    value: function lookaheadCharCode() {
                        return this.input.charCodeAt(this.nextTokenStart());
                    }
                },
                {
                    key: "nextTokenInLineStart",
                    value: function nextTokenInLineStart() {
                        return this.nextTokenInLineStartSince(this.state.pos);
                    }
                },
                {
                    key: "nextTokenInLineStartSince",
                    value: function nextTokenInLineStartSince(pos) {
                        skipWhiteSpaceInLine.lastIndex = pos;
                        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
                    }
                },
                {
                    key: "lookaheadInLineCharCode",
                    value: function lookaheadInLineCharCode() {
                        return this.input.charCodeAt(this.nextTokenInLineStart());
                    }
                },
                {
                    key: "codePointAtPos",
                    value: function codePointAtPos(pos) {
                        var cp = this.input.charCodeAt(pos);
                        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
                            var trail = this.input.charCodeAt(pos);
                            if ((trail & 64512) === 56320) {
                                cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
                            }
                        }
                        return cp;
                    }
                },
                {
                    key: "setStrict",
                    value: function setStrict(strict) {
                        var _this = this;
                        this.state.strict = strict;
                        if (strict) {
                            this.state.strictErrors.forEach(function(_ref39) {
                                var _$_ref39 = _sliced_to_array(_ref39, 2), toParseError = _$_ref39[0], at = _$_ref39[1];
                                return _this.raise(toParseError, at);
                            });
                            this.state.strictErrors.clear();
                        }
                    }
                },
                {
                    key: "curContext",
                    value: function curContext() {
                        return this.state.context[this.state.context.length - 1];
                    }
                },
                {
                    key: "nextToken",
                    value: function nextToken() {
                        this.skipSpace();
                        this.state.start = this.state.pos;
                        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
                        if (this.state.pos >= this.length) {
                            this.finishToken(140);
                            return;
                        }
                        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
                    }
                },
                {
                    key: "skipBlockComment",
                    value: function skipBlockComment(commentEnd) {
                        var startLoc;
                        if (!this.isLookahead) startLoc = this.state.curPosition();
                        var start = this.state.pos;
                        var end = this.input.indexOf(commentEnd, start + 2);
                        if (end === -1) {
                            throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
                        }
                        this.state.pos = end + commentEnd.length;
                        lineBreakG.lastIndex = start + 2;
                        while(lineBreakG.test(this.input) && lineBreakG.lastIndex <= end){
                            ++this.state.curLine;
                            this.state.lineStart = lineBreakG.lastIndex;
                        }
                        if (this.isLookahead) return;
                        var comment = {
                            type: "CommentBlock",
                            value: this.input.slice(start + 2, end),
                            start: this.sourceToOffsetPos(start),
                            end: this.sourceToOffsetPos(end + commentEnd.length),
                            loc: new SourceLocation(startLoc, this.state.curPosition())
                        };
                        if (this.options.tokens) this.pushToken(comment);
                        return comment;
                    }
                },
                {
                    key: "skipLineComment",
                    value: function skipLineComment(startSkip) {
                        var start = this.state.pos;
                        var startLoc;
                        if (!this.isLookahead) startLoc = this.state.curPosition();
                        var ch = this.input.charCodeAt(this.state.pos += startSkip);
                        if (this.state.pos < this.length) {
                            while(!isNewLine(ch) && ++this.state.pos < this.length){
                                ch = this.input.charCodeAt(this.state.pos);
                            }
                        }
                        if (this.isLookahead) return;
                        var end = this.state.pos;
                        var value = this.input.slice(start + startSkip, end);
                        var comment = {
                            type: "CommentLine",
                            value: value,
                            start: this.sourceToOffsetPos(start),
                            end: this.sourceToOffsetPos(end),
                            loc: new SourceLocation(startLoc, this.state.curPosition())
                        };
                        if (this.options.tokens) this.pushToken(comment);
                        return comment;
                    }
                },
                {
                    key: "skipSpace",
                    value: function skipSpace() {
                        var spaceStart = this.state.pos;
                        var comments = [];
                        loop: while(this.state.pos < this.length){
                            var ch = this.input.charCodeAt(this.state.pos);
                            switch(ch){
                                case 32:
                                case 160:
                                case 9:
                                    ++this.state.pos;
                                    break;
                                case 13:
                                    if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                                        ++this.state.pos;
                                    }
                                case 10:
                                case 8232:
                                case 8233:
                                    ++this.state.pos;
                                    ++this.state.curLine;
                                    this.state.lineStart = this.state.pos;
                                    break;
                                case 47:
                                    switch(this.input.charCodeAt(this.state.pos + 1)){
                                        case 42:
                                            {
                                                var comment = this.skipBlockComment("*/");
                                                if (comment !== void 0) {
                                                    this.addComment(comment);
                                                    if (this.options.attachComment) comments.push(comment);
                                                }
                                                break;
                                            }
                                        case 47:
                                            {
                                                var _comment = this.skipLineComment(2);
                                                if (_comment !== void 0) {
                                                    this.addComment(_comment);
                                                    if (this.options.attachComment) comments.push(_comment);
                                                }
                                                break;
                                            }
                                        default:
                                            break loop;
                                    }
                                    break;
                                default:
                                    if (isWhitespace(ch)) {
                                        ++this.state.pos;
                                    } else if (ch === 45 && !this.inModule && this.options.annexB) {
                                        var pos = this.state.pos;
                                        if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                                            var _comment2 = this.skipLineComment(3);
                                            if (_comment2 !== void 0) {
                                                this.addComment(_comment2);
                                                if (this.options.attachComment) comments.push(_comment2);
                                            }
                                        } else {
                                            break loop;
                                        }
                                    } else if (ch === 60 && !this.inModule && this.options.annexB) {
                                        var _pos = this.state.pos;
                                        if (this.input.charCodeAt(_pos + 1) === 33 && this.input.charCodeAt(_pos + 2) === 45 && this.input.charCodeAt(_pos + 3) === 45) {
                                            var _comment3 = this.skipLineComment(4);
                                            if (_comment3 !== void 0) {
                                                this.addComment(_comment3);
                                                if (this.options.attachComment) comments.push(_comment3);
                                            }
                                        } else {
                                            break loop;
                                        }
                                    } else {
                                        break loop;
                                    }
                            }
                        }
                        if (comments.length > 0) {
                            var end = this.state.pos;
                            var commentWhitespace = {
                                start: this.sourceToOffsetPos(spaceStart),
                                end: this.sourceToOffsetPos(end),
                                comments: comments,
                                leadingNode: null,
                                trailingNode: null,
                                containingNode: null
                            };
                            this.state.commentStack.push(commentWhitespace);
                        }
                    }
                },
                {
                    key: "finishToken",
                    value: function finishToken(type, val) {
                        this.state.end = this.state.pos;
                        this.state.endLoc = this.state.curPosition();
                        var prevType = this.state.type;
                        this.state.type = type;
                        this.state.value = val;
                        if (!this.isLookahead) {
                            this.updateContext(prevType);
                        }
                    }
                },
                {
                    key: "replaceToken",
                    value: function replaceToken(type) {
                        this.state.type = type;
                        this.updateContext();
                    }
                },
                {
                    key: "readToken_numberSign",
                    value: function readToken_numberSign() {
                        if (this.state.pos === 0 && this.readToken_interpreter()) {
                            return;
                        }
                        var nextPos = this.state.pos + 1;
                        var next = this.codePointAtPos(nextPos);
                        if (next >= 48 && next <= 57) {
                            throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
                        }
                        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
                            this.expectPlugin("recordAndTuple");
                            if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
                                throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
                            }
                            this.state.pos += 2;
                            if (next === 123) {
                                this.finishToken(7);
                            } else {
                                this.finishToken(1);
                            }
                        } else if (isIdentifierStart(next)) {
                            ++this.state.pos;
                            this.finishToken(139, this.readWord1(next));
                        } else if (next === 92) {
                            ++this.state.pos;
                            this.finishToken(139, this.readWord1());
                        } else {
                            this.finishOp(27, 1);
                        }
                    }
                },
                {
                    key: "readToken_dot",
                    value: function readToken_dot() {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (next >= 48 && next <= 57) {
                            this.readNumber(true);
                            return;
                        }
                        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
                            this.state.pos += 3;
                            this.finishToken(21);
                        } else {
                            ++this.state.pos;
                            this.finishToken(16);
                        }
                    }
                },
                {
                    key: "readToken_slash",
                    value: function readToken_slash() {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (next === 61) {
                            this.finishOp(31, 2);
                        } else {
                            this.finishOp(56, 1);
                        }
                    }
                },
                {
                    key: "readToken_interpreter",
                    value: function readToken_interpreter() {
                        if (this.state.pos !== 0 || this.length < 2) return false;
                        var ch = this.input.charCodeAt(this.state.pos + 1);
                        if (ch !== 33) return false;
                        var start = this.state.pos;
                        this.state.pos += 1;
                        while(!isNewLine(ch) && ++this.state.pos < this.length){
                            ch = this.input.charCodeAt(this.state.pos);
                        }
                        var value = this.input.slice(start + 2, this.state.pos);
                        this.finishToken(28, value);
                        return true;
                    }
                },
                {
                    key: "readToken_mult_modulo",
                    value: function readToken_mult_modulo(code2) {
                        var type = code2 === 42 ? 55 : 54;
                        var width2 = 1;
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (code2 === 42 && next === 42) {
                            width2++;
                            next = this.input.charCodeAt(this.state.pos + 2);
                            type = 57;
                        }
                        if (next === 61 && !this.state.inType) {
                            width2++;
                            type = code2 === 37 ? 33 : 30;
                        }
                        this.finishOp(type, width2);
                    }
                },
                {
                    key: "readToken_pipe_amp",
                    value: function readToken_pipe_amp(code2) {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (next === code2) {
                            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                                this.finishOp(30, 3);
                            } else {
                                this.finishOp(code2 === 124 ? 41 : 42, 2);
                            }
                            return;
                        }
                        if (code2 === 124) {
                            if (next === 62) {
                                this.finishOp(39, 2);
                                return;
                            }
                            if (this.hasPlugin("recordAndTuple") && next === 125) {
                                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                    throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                                }
                                this.state.pos += 2;
                                this.finishToken(9);
                                return;
                            }
                            if (this.hasPlugin("recordAndTuple") && next === 93) {
                                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                    throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                                }
                                this.state.pos += 2;
                                this.finishToken(4);
                                return;
                            }
                        }
                        if (next === 61) {
                            this.finishOp(30, 2);
                            return;
                        }
                        this.finishOp(code2 === 124 ? 43 : 45, 1);
                    }
                },
                {
                    key: "readToken_caret",
                    value: function readToken_caret() {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (next === 61 && !this.state.inType) {
                            this.finishOp(32, 2);
                        } else if (next === 94 && this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "hack",
                                topicToken: "^^"
                            }
                        ])) {
                            this.finishOp(37, 2);
                            var lookaheadCh = this.input.codePointAt(this.state.pos);
                            if (lookaheadCh === 94) {
                                this.unexpected();
                            }
                        } else {
                            this.finishOp(44, 1);
                        }
                    }
                },
                {
                    key: "readToken_atSign",
                    value: function readToken_atSign() {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (next === 64 && this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "hack",
                                topicToken: "@@"
                            }
                        ])) {
                            this.finishOp(38, 2);
                        } else {
                            this.finishOp(26, 1);
                        }
                    }
                },
                {
                    key: "readToken_plus_min",
                    value: function readToken_plus_min(code2) {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (next === code2) {
                            this.finishOp(34, 2);
                            return;
                        }
                        if (next === 61) {
                            this.finishOp(30, 2);
                        } else {
                            this.finishOp(53, 1);
                        }
                    }
                },
                {
                    key: "readToken_lt",
                    value: function readToken_lt() {
                        var pos = this.state.pos;
                        var next = this.input.charCodeAt(pos + 1);
                        if (next === 60) {
                            if (this.input.charCodeAt(pos + 2) === 61) {
                                this.finishOp(30, 3);
                                return;
                            }
                            this.finishOp(51, 2);
                            return;
                        }
                        if (next === 61) {
                            this.finishOp(49, 2);
                            return;
                        }
                        this.finishOp(47, 1);
                    }
                },
                {
                    key: "readToken_gt",
                    value: function readToken_gt() {
                        var pos = this.state.pos;
                        var next = this.input.charCodeAt(pos + 1);
                        if (next === 62) {
                            var size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
                            if (this.input.charCodeAt(pos + size) === 61) {
                                this.finishOp(30, size + 1);
                                return;
                            }
                            this.finishOp(52, size);
                            return;
                        }
                        if (next === 61) {
                            this.finishOp(49, 2);
                            return;
                        }
                        this.finishOp(48, 1);
                    }
                },
                {
                    key: "readToken_eq_excl",
                    value: function readToken_eq_excl(code2) {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        if (next === 61) {
                            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                            return;
                        }
                        if (code2 === 61 && next === 62) {
                            this.state.pos += 2;
                            this.finishToken(19);
                            return;
                        }
                        this.finishOp(code2 === 61 ? 29 : 35, 1);
                    }
                },
                {
                    key: "readToken_question",
                    value: function readToken_question() {
                        var next = this.input.charCodeAt(this.state.pos + 1);
                        var next2 = this.input.charCodeAt(this.state.pos + 2);
                        if (next === 63) {
                            if (next2 === 61) {
                                this.finishOp(30, 3);
                            } else {
                                this.finishOp(40, 2);
                            }
                        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
                            this.state.pos += 2;
                            this.finishToken(18);
                        } else {
                            ++this.state.pos;
                            this.finishToken(17);
                        }
                    }
                },
                {
                    key: "getTokenFromCode",
                    value: function getTokenFromCode(code2) {
                        switch(code2){
                            case 46:
                                this.readToken_dot();
                                return;
                            case 40:
                                ++this.state.pos;
                                this.finishToken(10);
                                return;
                            case 41:
                                ++this.state.pos;
                                this.finishToken(11);
                                return;
                            case 59:
                                ++this.state.pos;
                                this.finishToken(13);
                                return;
                            case 44:
                                ++this.state.pos;
                                this.finishToken(12);
                                return;
                            case 91:
                                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                        throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                                    }
                                    this.state.pos += 2;
                                    this.finishToken(2);
                                } else {
                                    ++this.state.pos;
                                    this.finishToken(0);
                                }
                                return;
                            case 93:
                                ++this.state.pos;
                                this.finishToken(3);
                                return;
                            case 123:
                                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                        throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                                    }
                                    this.state.pos += 2;
                                    this.finishToken(6);
                                } else {
                                    ++this.state.pos;
                                    this.finishToken(5);
                                }
                                return;
                            case 125:
                                ++this.state.pos;
                                this.finishToken(8);
                                return;
                            case 58:
                                if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                                    this.finishOp(15, 2);
                                } else {
                                    ++this.state.pos;
                                    this.finishToken(14);
                                }
                                return;
                            case 63:
                                this.readToken_question();
                                return;
                            case 96:
                                this.readTemplateToken();
                                return;
                            case 48:
                                {
                                    var next = this.input.charCodeAt(this.state.pos + 1);
                                    if (next === 120 || next === 88) {
                                        this.readRadixNumber(16);
                                        return;
                                    }
                                    if (next === 111 || next === 79) {
                                        this.readRadixNumber(8);
                                        return;
                                    }
                                    if (next === 98 || next === 66) {
                                        this.readRadixNumber(2);
                                        return;
                                    }
                                }
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                            case 56:
                            case 57:
                                this.readNumber(false);
                                return;
                            case 34:
                            case 39:
                                this.readString(code2);
                                return;
                            case 47:
                                this.readToken_slash();
                                return;
                            case 37:
                            case 42:
                                this.readToken_mult_modulo(code2);
                                return;
                            case 124:
                            case 38:
                                this.readToken_pipe_amp(code2);
                                return;
                            case 94:
                                this.readToken_caret();
                                return;
                            case 43:
                            case 45:
                                this.readToken_plus_min(code2);
                                return;
                            case 60:
                                this.readToken_lt();
                                return;
                            case 62:
                                this.readToken_gt();
                                return;
                            case 61:
                            case 33:
                                this.readToken_eq_excl(code2);
                                return;
                            case 126:
                                this.finishOp(36, 1);
                                return;
                            case 64:
                                this.readToken_atSign();
                                return;
                            case 35:
                                this.readToken_numberSign();
                                return;
                            case 92:
                                this.readWord();
                                return;
                            default:
                                if (isIdentifierStart(code2)) {
                                    this.readWord(code2);
                                    return;
                                }
                        }
                        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
                            unexpected: String.fromCodePoint(code2)
                        });
                    }
                },
                {
                    key: "finishOp",
                    value: function finishOp(type, size) {
                        var str = this.input.slice(this.state.pos, this.state.pos + size);
                        this.state.pos += size;
                        this.finishToken(type, str);
                    }
                },
                {
                    key: "readRegexp",
                    value: function readRegexp() {
                        var startLoc = this.state.startLoc;
                        var start = this.state.start + 1;
                        var escaped, inClass;
                        var pos = this.state.pos;
                        for(;; ++pos){
                            if (pos >= this.length) {
                                throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
                            }
                            var ch = this.input.charCodeAt(pos);
                            if (isNewLine(ch)) {
                                throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
                            }
                            if (escaped) {
                                escaped = false;
                            } else {
                                if (ch === 91) {
                                    inClass = true;
                                } else if (ch === 93 && inClass) {
                                    inClass = false;
                                } else if (ch === 47 && !inClass) {
                                    break;
                                }
                                escaped = ch === 92;
                            }
                        }
                        var content2 = this.input.slice(start, pos);
                        ++pos;
                        var mods = "";
                        var nextPos = function() {
                            return createPositionWithColumnOffset(startLoc, pos + 2 - start);
                        };
                        while(pos < this.length){
                            var cp = this.codePointAtPos(pos);
                            var char = String.fromCharCode(cp);
                            if (VALID_REGEX_FLAGS.has(cp)) {
                                if (cp === 118) {
                                    if (mods.includes("u")) {
                                        this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                                    }
                                } else if (cp === 117) {
                                    if (mods.includes("v")) {
                                        this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                                    }
                                }
                                if (mods.includes(char)) {
                                    this.raise(Errors.DuplicateRegExpFlags, nextPos());
                                }
                            } else if (isIdentifierChar(cp) || cp === 92) {
                                this.raise(Errors.MalformedRegExpFlags, nextPos());
                            } else {
                                break;
                            }
                            ++pos;
                            mods += char;
                        }
                        this.state.pos = pos;
                        this.finishToken(138, {
                            pattern: content2,
                            flags: mods
                        });
                    }
                },
                {
                    key: "readInt",
                    value: function readInt1(radix, len) {
                        var forceLen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        var allowNumSeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                        var _readInt = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false), n = _readInt.n, pos = _readInt.pos;
                        this.state.pos = pos;
                        return n;
                    }
                },
                {
                    key: "readRadixNumber",
                    value: function readRadixNumber(radix) {
                        var start = this.state.pos;
                        var startLoc = this.state.curPosition();
                        var isBigInt = false;
                        this.state.pos += 2;
                        var val = this.readInt(radix);
                        if (val == null) {
                            this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
                                radix: radix
                            });
                        }
                        var next = this.input.charCodeAt(this.state.pos);
                        if (next === 110) {
                            ++this.state.pos;
                            isBigInt = true;
                        } else if (next === 109) {
                            throw this.raise(Errors.InvalidDecimal, startLoc);
                        }
                        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                            throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
                        }
                        if (isBigInt) {
                            var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
                            this.finishToken(136, str);
                            return;
                        }
                        this.finishToken(135, val);
                    }
                },
                {
                    key: "readNumber",
                    value: function readNumber(startsWithDot) {
                        var start = this.state.pos;
                        var startLoc = this.state.curPosition();
                        var isFloat = false;
                        var isBigInt = false;
                        var hasExponent = false;
                        var isOctal = false;
                        if (!startsWithDot && this.readInt(10) === null) {
                            this.raise(Errors.InvalidNumber, this.state.curPosition());
                        }
                        var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
                        if (hasLeadingZero) {
                            var integer = this.input.slice(start, this.state.pos);
                            this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
                            if (!this.state.strict) {
                                var underscorePos = integer.indexOf("_");
                                if (underscorePos > 0) {
                                    this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
                                }
                            }
                            isOctal = hasLeadingZero && !/[89]/.test(integer);
                        }
                        var next = this.input.charCodeAt(this.state.pos);
                        if (next === 46 && !isOctal) {
                            ++this.state.pos;
                            this.readInt(10);
                            isFloat = true;
                            next = this.input.charCodeAt(this.state.pos);
                        }
                        if ((next === 69 || next === 101) && !isOctal) {
                            next = this.input.charCodeAt(++this.state.pos);
                            if (next === 43 || next === 45) {
                                ++this.state.pos;
                            }
                            if (this.readInt(10) === null) {
                                this.raise(Errors.InvalidOrMissingExponent, startLoc);
                            }
                            isFloat = true;
                            hasExponent = true;
                            next = this.input.charCodeAt(this.state.pos);
                        }
                        if (next === 110) {
                            if (isFloat || hasLeadingZero) {
                                this.raise(Errors.InvalidBigIntLiteral, startLoc);
                            }
                            ++this.state.pos;
                            isBigInt = true;
                        }
                        if (next === 109) {
                            this.expectPlugin("decimal", this.state.curPosition());
                            if (hasExponent || hasLeadingZero) {
                                this.raise(Errors.InvalidDecimal, startLoc);
                            }
                            ++this.state.pos;
                            var isDecimal = true;
                        }
                        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                            throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
                        }
                        var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
                        if (isBigInt) {
                            this.finishToken(136, str);
                            return;
                        }
                        if (isDecimal) {
                            this.finishToken(137, str);
                            return;
                        }
                        var val = isOctal ? parseInt(str, 8) : parseFloat(str);
                        this.finishToken(135, val);
                    }
                },
                {
                    key: "readCodePoint",
                    value: function readCodePoint1(throwOnInvalid) {
                        var _readCodePoint = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint), code2 = _readCodePoint.code, pos = _readCodePoint.pos;
                        this.state.pos = pos;
                        return code2;
                    }
                },
                {
                    key: "readString",
                    value: function readString(quote) {
                        var _readStringContents = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string), str = _readStringContents.str, pos = _readStringContents.pos, curLine = _readStringContents.curLine, lineStart = _readStringContents.lineStart;
                        this.state.pos = pos + 1;
                        this.state.lineStart = lineStart;
                        this.state.curLine = curLine;
                        this.finishToken(134, str);
                    }
                },
                {
                    key: "readTemplateContinuation",
                    value: function readTemplateContinuation() {
                        if (!this.match(8)) {
                            this.unexpected(null, 8);
                        }
                        this.state.pos--;
                        this.readTemplateToken();
                    }
                },
                {
                    key: "readTemplateToken",
                    value: function readTemplateToken() {
                        var opening = this.input[this.state.pos];
                        var _readStringContents = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template), str = _readStringContents.str, firstInvalidLoc = _readStringContents.firstInvalidLoc, pos = _readStringContents.pos, curLine = _readStringContents.curLine, lineStart = _readStringContents.lineStart;
                        this.state.pos = pos + 1;
                        this.state.lineStart = lineStart;
                        this.state.curLine = curLine;
                        if (firstInvalidLoc) {
                            this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
                        }
                        if (this.input.codePointAt(pos) === 96) {
                            this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
                        } else {
                            this.state.pos++;
                            this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
                        }
                    }
                },
                {
                    key: "recordStrictModeErrors",
                    value: function recordStrictModeErrors(toParseError, at) {
                        var index = at.index;
                        if (this.state.strict && !this.state.strictErrors.has(index)) {
                            this.raise(toParseError, at);
                        } else {
                            this.state.strictErrors.set(index, [
                                toParseError,
                                at
                            ]);
                        }
                    }
                },
                {
                    key: "readWord1",
                    value: function readWord1(firstCode) {
                        this.state.containsEsc = false;
                        var word = "";
                        var start = this.state.pos;
                        var chunkStart = this.state.pos;
                        if (firstCode !== void 0) {
                            this.state.pos += firstCode <= 65535 ? 1 : 2;
                        }
                        while(this.state.pos < this.length){
                            var ch = this.codePointAtPos(this.state.pos);
                            if (isIdentifierChar(ch)) {
                                this.state.pos += ch <= 65535 ? 1 : 2;
                            } else if (ch === 92) {
                                this.state.containsEsc = true;
                                word += this.input.slice(chunkStart, this.state.pos);
                                var escStart = this.state.curPosition();
                                var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                                    this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
                                    chunkStart = this.state.pos - 1;
                                    continue;
                                }
                                ++this.state.pos;
                                var esc = this.readCodePoint(true);
                                if (esc !== null) {
                                    if (!identifierCheck(esc)) {
                                        this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
                                    }
                                    word += String.fromCodePoint(esc);
                                }
                                chunkStart = this.state.pos;
                            } else {
                                break;
                            }
                        }
                        return word + this.input.slice(chunkStart, this.state.pos);
                    }
                },
                {
                    key: "readWord",
                    value: function readWord(firstCode) {
                        var word = this.readWord1(firstCode);
                        var type = keywords$1.get(word);
                        if (type !== void 0) {
                            this.finishToken(type, tokenLabelName(type));
                        } else {
                            this.finishToken(132, word);
                        }
                    }
                },
                {
                    key: "checkKeywordEscapes",
                    value: function checkKeywordEscapes() {
                        var type = this.state.type;
                        if (tokenIsKeyword(type) && this.state.containsEsc) {
                            this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
                                reservedWord: tokenLabelName(type)
                            });
                        }
                    }
                },
                {
                    key: "raise",
                    value: function raise(toParseError, at) {
                        var details = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                        var loc = _instanceof(at, Position) ? at : at.loc.start;
                        var error = toParseError(loc, details);
                        if (!this.options.errorRecovery) throw error;
                        if (!this.isLookahead) this.state.errors.push(error);
                        return error;
                    }
                },
                {
                    key: "raiseOverwrite",
                    value: function raiseOverwrite(toParseError, at) {
                        var details = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                        var loc = _instanceof(at, Position) ? at : at.loc.start;
                        var pos = loc.index;
                        var errors = this.state.errors;
                        for(var i = errors.length - 1; i >= 0; i--){
                            var error = errors[i];
                            if (error.loc.index === pos) {
                                return errors[i] = toParseError(loc, details);
                            }
                            if (error.loc.index < pos) break;
                        }
                        return this.raise(toParseError, at, details);
                    }
                },
                {
                    key: "updateContext",
                    value: function updateContext(prevType) {}
                },
                {
                    key: "unexpected",
                    value: function unexpected(loc, type) {
                        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
                            expected: type ? tokenLabelName(type) : null
                        });
                    }
                },
                {
                    key: "expectPlugin",
                    value: function expectPlugin(pluginName, loc) {
                        if (this.hasPlugin(pluginName)) {
                            return true;
                        }
                        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
                            missingPlugin: [
                                pluginName
                            ]
                        });
                    }
                },
                {
                    key: "expectOnePlugin",
                    value: function expectOnePlugin(pluginNames) {
                        var _this = this;
                        if (!pluginNames.some(function(name) {
                            return _this.hasPlugin(name);
                        })) {
                            throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
                                missingPlugin: pluginNames
                            });
                        }
                    }
                },
                {
                    key: "errorBuilder",
                    value: function errorBuilder(error) {
                        var _this = this;
                        return function(pos, lineStart, curLine) {
                            _this.raise(error, buildPosition(pos, lineStart, curLine));
                        };
                    }
                }
            ]);
            return Tokenizer;
        }(CommentsParser);
        var ClassScope = function ClassScope() {
            _class_call_check(this, ClassScope);
            this.privateNames = /* @__PURE__ */ new Set();
            this.loneAccessors = /* @__PURE__ */ new Map();
            this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        };
        var ClassScopeHandler = /*#__PURE__*/ function() {
            function ClassScopeHandler(parser) {
                _class_call_check(this, ClassScopeHandler);
                this.parser = void 0;
                this.stack = [];
                this.undefinedPrivateNames = /* @__PURE__ */ new Map();
                this.parser = parser;
            }
            _create_class(ClassScopeHandler, [
                {
                    key: "current",
                    value: function current() {
                        return this.stack[this.stack.length - 1];
                    }
                },
                {
                    key: "enter",
                    value: function enter() {
                        this.stack.push(new ClassScope());
                    }
                },
                {
                    key: "exit",
                    value: function exit() {
                        var oldClassScope = this.stack.pop();
                        var current = this.current();
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = Array.from(oldClassScope.undefinedPrivateNames)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var _step_value = _sliced_to_array(_step.value, 2), name = _step_value[0], loc = _step_value[1];
                                if (current) {
                                    if (!current.undefinedPrivateNames.has(name)) {
                                        current.undefinedPrivateNames.set(name, loc);
                                    }
                                } else {
                                    this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                                        identifierName: name
                                    });
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                },
                {
                    key: "declarePrivateName",
                    value: function declarePrivateName(name, elementType, loc) {
                        var _this_current = this.current(), privateNames = _this_current.privateNames, loneAccessors = _this_current.loneAccessors, undefinedPrivateNames = _this_current.undefinedPrivateNames;
                        var redefined = privateNames.has(name);
                        if (elementType & 3) {
                            var accessor = redefined && loneAccessors.get(name);
                            if (accessor) {
                                var oldStatic = accessor & 4;
                                var newStatic = elementType & 4;
                                var oldKind = accessor & 3;
                                var newKind = elementType & 3;
                                redefined = oldKind === newKind || oldStatic !== newStatic;
                                if (!redefined) loneAccessors.delete(name);
                            } else if (!redefined) {
                                loneAccessors.set(name, elementType);
                            }
                        }
                        if (redefined) {
                            this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
                                identifierName: name
                            });
                        }
                        privateNames.add(name);
                        undefinedPrivateNames.delete(name);
                    }
                },
                {
                    key: "usePrivateName",
                    value: function usePrivateName(name, loc) {
                        var classScope;
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = this.stack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                classScope = _step.value;
                                if (classScope.privateNames.has(name)) return;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        if (classScope) {
                            classScope.undefinedPrivateNames.set(name, loc);
                        } else {
                            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                                identifierName: name
                            });
                        }
                    }
                }
            ]);
            return ClassScopeHandler;
        }();
        var ExpressionScope = /*#__PURE__*/ function() {
            function ExpressionScope() {
                _class_call_check(this, ExpressionScope);
                var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                this.type = type;
            }
            _create_class(ExpressionScope, [
                {
                    key: "canBeArrowParameterDeclaration",
                    value: function canBeArrowParameterDeclaration() {
                        return this.type === 2 || this.type === 1;
                    }
                },
                {
                    key: "isCertainlyParameterDeclaration",
                    value: function isCertainlyParameterDeclaration() {
                        return this.type === 3;
                    }
                }
            ]);
            return ExpressionScope;
        }();
        var ArrowHeadParsingScope = /*#__PURE__*/ function(ExpressionScope) {
            _inherits(ArrowHeadParsingScope, ExpressionScope);
            function ArrowHeadParsingScope(type) {
                _class_call_check(this, ArrowHeadParsingScope);
                var _this;
                _this = _call_super(this, ArrowHeadParsingScope, [
                    type
                ]);
                _this.declarationErrors = /* @__PURE__ */ new Map();
                return _this;
            }
            _create_class(ArrowHeadParsingScope, [
                {
                    key: "recordDeclarationError",
                    value: function recordDeclarationError(ParsingErrorClass, at) {
                        var index = at.index;
                        this.declarationErrors.set(index, [
                            ParsingErrorClass,
                            at
                        ]);
                    }
                },
                {
                    key: "clearDeclarationError",
                    value: function clearDeclarationError(index) {
                        this.declarationErrors.delete(index);
                    }
                },
                {
                    key: "iterateErrors",
                    value: function iterateErrors(iterator) {
                        this.declarationErrors.forEach(iterator);
                    }
                }
            ]);
            return ArrowHeadParsingScope;
        }(ExpressionScope);
        var ExpressionScopeHandler = /*#__PURE__*/ function() {
            function ExpressionScopeHandler(parser) {
                _class_call_check(this, ExpressionScopeHandler);
                this.parser = void 0;
                this.stack = [
                    new ExpressionScope()
                ];
                this.parser = parser;
            }
            _create_class(ExpressionScopeHandler, [
                {
                    key: "enter",
                    value: function enter(scope) {
                        this.stack.push(scope);
                    }
                },
                {
                    key: "exit",
                    value: function exit() {
                        this.stack.pop();
                    }
                },
                {
                    key: "recordParameterInitializerError",
                    value: function recordParameterInitializerError(toParseError, node) {
                        var origin = node.loc.start;
                        var stack = this.stack;
                        var i = stack.length - 1;
                        var scope = stack[i];
                        while(!scope.isCertainlyParameterDeclaration()){
                            if (scope.canBeArrowParameterDeclaration()) {
                                scope.recordDeclarationError(toParseError, origin);
                            } else {
                                return;
                            }
                            scope = stack[--i];
                        }
                        this.parser.raise(toParseError, origin);
                    }
                },
                {
                    key: "recordArrowParameterBindingError",
                    value: function recordArrowParameterBindingError(error, node) {
                        var stack = this.stack;
                        var scope = stack[stack.length - 1];
                        var origin = node.loc.start;
                        if (scope.isCertainlyParameterDeclaration()) {
                            this.parser.raise(error, origin);
                        } else if (scope.canBeArrowParameterDeclaration()) {
                            scope.recordDeclarationError(error, origin);
                        } else {
                            return;
                        }
                    }
                },
                {
                    key: "recordAsyncArrowParametersError",
                    value: function recordAsyncArrowParametersError(at) {
                        var stack = this.stack;
                        var i = stack.length - 1;
                        var scope = stack[i];
                        while(scope.canBeArrowParameterDeclaration()){
                            if (scope.type === 2) {
                                scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
                            }
                            scope = stack[--i];
                        }
                    }
                },
                {
                    key: "validateAsPattern",
                    value: function validateAsPattern() {
                        var _this = this;
                        var stack = this.stack;
                        var currentScope = stack[stack.length - 1];
                        if (!currentScope.canBeArrowParameterDeclaration()) return;
                        currentScope.iterateErrors(function(_ref40) {
                            var _$_ref40 = _sliced_to_array(_ref40, 2), toParseError = _$_ref40[0], loc = _$_ref40[1];
                            _this.parser.raise(toParseError, loc);
                            var i = stack.length - 2;
                            var scope = stack[i];
                            while(scope.canBeArrowParameterDeclaration()){
                                scope.clearDeclarationError(loc.index);
                                scope = stack[--i];
                            }
                        });
                    }
                }
            ]);
            return ExpressionScopeHandler;
        }();
        function newParameterDeclarationScope() {
            return new ExpressionScope(3);
        }
        function newArrowHeadScope() {
            return new ArrowHeadParsingScope(1);
        }
        function newAsyncArrowScope() {
            return new ArrowHeadParsingScope(2);
        }
        function newExpressionScope() {
            return new ExpressionScope();
        }
        var ProductionParameterHandler = /*#__PURE__*/ function() {
            function ProductionParameterHandler() {
                _class_call_check(this, ProductionParameterHandler);
                this.stacks = [];
            }
            _create_class(ProductionParameterHandler, [
                {
                    key: "enter",
                    value: function enter(flags) {
                        this.stacks.push(flags);
                    }
                },
                {
                    key: "exit",
                    value: function exit() {
                        this.stacks.pop();
                    }
                },
                {
                    key: "currentFlags",
                    value: function currentFlags() {
                        return this.stacks[this.stacks.length - 1];
                    }
                },
                {
                    key: "hasAwait",
                    get: function get() {
                        return (this.currentFlags() & 2) > 0;
                    }
                },
                {
                    key: "hasYield",
                    get: function get() {
                        return (this.currentFlags() & 1) > 0;
                    }
                },
                {
                    key: "hasReturn",
                    get: function get() {
                        return (this.currentFlags() & 4) > 0;
                    }
                },
                {
                    key: "hasIn",
                    get: function get() {
                        return (this.currentFlags() & 8) > 0;
                    }
                }
            ]);
            return ProductionParameterHandler;
        }();
        function functionFlags(isAsync, isGenerator) {
            return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
        }
        var UtilParser = /*#__PURE__*/ function(Tokenizer) {
            _inherits(UtilParser, Tokenizer);
            function UtilParser() {
                _class_call_check(this, UtilParser);
                return _call_super(this, UtilParser, arguments);
            }
            _create_class(UtilParser, [
                {
                    key: "addExtra",
                    value: function addExtra(node, key2, value) {
                        var enumerable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                        if (!node) return;
                        var extra = node.extra;
                        if (extra == null) {
                            extra = {};
                            node.extra = extra;
                        }
                        if (enumerable) {
                            extra[key2] = value;
                        } else {
                            Object.defineProperty(extra, key2, {
                                enumerable: enumerable,
                                value: value
                            });
                        }
                    }
                },
                {
                    key: "isContextual",
                    value: function isContextual(token) {
                        return this.state.type === token && !this.state.containsEsc;
                    }
                },
                {
                    key: "isUnparsedContextual",
                    value: function isUnparsedContextual(nameStart, name) {
                        var nameEnd = nameStart + name.length;
                        if (this.input.slice(nameStart, nameEnd) === name) {
                            var nextCh = this.input.charCodeAt(nameEnd);
                            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
                        }
                        return false;
                    }
                },
                {
                    key: "isLookaheadContextual",
                    value: function isLookaheadContextual(name) {
                        var next = this.nextTokenStart();
                        return this.isUnparsedContextual(next, name);
                    }
                },
                {
                    key: "eatContextual",
                    value: function eatContextual(token) {
                        if (this.isContextual(token)) {
                            this.next();
                            return true;
                        }
                        return false;
                    }
                },
                {
                    key: "expectContextual",
                    value: function expectContextual(token, toParseError) {
                        if (!this.eatContextual(token)) {
                            if (toParseError != null) {
                                throw this.raise(toParseError, this.state.startLoc);
                            }
                            this.unexpected(null, token);
                        }
                    }
                },
                {
                    key: "canInsertSemicolon",
                    value: function canInsertSemicolon() {
                        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
                    }
                },
                {
                    key: "hasPrecedingLineBreak",
                    value: function hasPrecedingLineBreak() {
                        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
                    }
                },
                {
                    key: "hasFollowingLineBreak",
                    value: function hasFollowingLineBreak() {
                        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
                    }
                },
                {
                    key: "isLineTerminator",
                    value: function isLineTerminator() {
                        return this.eat(13) || this.canInsertSemicolon();
                    }
                },
                {
                    key: "semicolon",
                    value: function semicolon() {
                        var allowAsi = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
                        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
                    }
                },
                {
                    key: "expect",
                    value: function expect(type, loc) {
                        if (!this.eat(type)) {
                            this.unexpected(loc, type);
                        }
                    }
                },
                {
                    key: "tryParse",
                    value: function tryParse(fn) {
                        var oldState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone();
                        var abortSignal = {
                            node: null
                        };
                        try {
                            var node = fn(function() {
                                var node2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                                abortSignal.node = node2;
                                throw abortSignal;
                            });
                            if (this.state.errors.length > oldState.errors.length) {
                                var failState = this.state;
                                this.state = oldState;
                                this.state.tokensLength = failState.tokensLength;
                                return {
                                    node: node,
                                    error: failState.errors[oldState.errors.length],
                                    thrown: false,
                                    aborted: false,
                                    failState: failState
                                };
                            }
                            return {
                                node: node,
                                error: null,
                                thrown: false,
                                aborted: false,
                                failState: null
                            };
                        } catch (error) {
                            var _failState = this.state;
                            this.state = oldState;
                            if (_instanceof(error, SyntaxError)) {
                                return {
                                    node: null,
                                    error: error,
                                    thrown: true,
                                    aborted: false,
                                    failState: _failState
                                };
                            }
                            if (error === abortSignal) {
                                return {
                                    node: abortSignal.node,
                                    error: null,
                                    thrown: false,
                                    aborted: true,
                                    failState: _failState
                                };
                            }
                            throw error;
                        }
                    }
                },
                {
                    key: "checkExpressionErrors",
                    value: function checkExpressionErrors(refExpressionErrors, andThrow) {
                        if (!refExpressionErrors) return false;
                        var shorthandAssignLoc = refExpressionErrors.shorthandAssignLoc, doubleProtoLoc = refExpressionErrors.doubleProtoLoc, privateKeyLoc = refExpressionErrors.privateKeyLoc, optionalParametersLoc = refExpressionErrors.optionalParametersLoc;
                        var hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
                        if (!andThrow) {
                            return hasErrors;
                        }
                        if (shorthandAssignLoc != null) {
                            this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
                        }
                        if (doubleProtoLoc != null) {
                            this.raise(Errors.DuplicateProto, doubleProtoLoc);
                        }
                        if (privateKeyLoc != null) {
                            this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                        }
                        if (optionalParametersLoc != null) {
                            this.unexpected(optionalParametersLoc);
                        }
                    }
                },
                {
                    key: "isLiteralPropertyName",
                    value: function isLiteralPropertyName() {
                        return tokenIsLiteralPropertyName(this.state.type);
                    }
                },
                {
                    key: "isPrivateName",
                    value: function isPrivateName(node) {
                        return node.type === "PrivateName";
                    }
                },
                {
                    key: "getPrivateNameSV",
                    value: function getPrivateNameSV(node) {
                        return node.id.name;
                    }
                },
                {
                    key: "hasPropertyAsPrivateName",
                    value: function hasPropertyAsPrivateName(node) {
                        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
                    }
                },
                {
                    key: "isObjectProperty",
                    value: function isObjectProperty(node) {
                        return node.type === "ObjectProperty";
                    }
                },
                {
                    key: "isObjectMethod",
                    value: function isObjectMethod(node) {
                        return node.type === "ObjectMethod";
                    }
                },
                {
                    key: "initializeScopes",
                    value: function initializeScopes() {
                        var _this = this;
                        var inModule = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module";
                        var oldLabels = this.state.labels;
                        this.state.labels = [];
                        var oldExportedIdentifiers = this.exportedIdentifiers;
                        this.exportedIdentifiers = /* @__PURE__ */ new Set();
                        var oldInModule = this.inModule;
                        this.inModule = inModule;
                        var oldScope = this.scope;
                        var ScopeHandler2 = this.getScopeHandler();
                        this.scope = new ScopeHandler2(this, inModule);
                        var oldProdParam = this.prodParam;
                        this.prodParam = new ProductionParameterHandler();
                        var oldClassScope = this.classScope;
                        this.classScope = new ClassScopeHandler(this);
                        var oldExpressionScope = this.expressionScope;
                        this.expressionScope = new ExpressionScopeHandler(this);
                        return function() {
                            _this.state.labels = oldLabels;
                            _this.exportedIdentifiers = oldExportedIdentifiers;
                            _this.inModule = oldInModule;
                            _this.scope = oldScope;
                            _this.prodParam = oldProdParam;
                            _this.classScope = oldClassScope;
                            _this.expressionScope = oldExpressionScope;
                        };
                    }
                },
                {
                    key: "enterInitialScopes",
                    value: function enterInitialScopes() {
                        var paramFlags = 0;
                        if (this.inModule) {
                            paramFlags |= 2;
                        }
                        this.scope.enter(1);
                        this.prodParam.enter(paramFlags);
                    }
                },
                {
                    key: "checkDestructuringPrivate",
                    value: function checkDestructuringPrivate(refExpressionErrors) {
                        var privateKeyLoc = refExpressionErrors.privateKeyLoc;
                        if (privateKeyLoc !== null) {
                            this.expectPlugin("destructuringPrivate", privateKeyLoc);
                        }
                    }
                }
            ]);
            return UtilParser;
        }(Tokenizer);
        var ExpressionErrors = function ExpressionErrors() {
            _class_call_check(this, ExpressionErrors);
            this.shorthandAssignLoc = null;
            this.doubleProtoLoc = null;
            this.privateKeyLoc = null;
            this.optionalParametersLoc = null;
        };
        var Node = function Node(parser, pos, loc) {
            _class_call_check(this, Node);
            this.type = "";
            this.start = pos;
            this.end = 0;
            this.loc = new SourceLocation(loc);
            if (parser != null && parser.options.ranges) this.range = [
                pos,
                0
            ];
            if (parser != null && parser.filename) this.loc.filename = parser.filename;
        };
        var NodePrototype = Node.prototype;
        {
            NodePrototype.__clone = function() {
                var newNode = new Node(void 0, this.start, this.loc.start);
                var keys = Object.keys(this);
                for(var i = 0, length = keys.length; i < length; i++){
                    var key2 = keys[i];
                    if (key2 !== "leadingComments" && key2 !== "trailingComments" && key2 !== "innerComments") {
                        newNode[key2] = this[key2];
                    }
                }
                return newNode;
            };
        }
        function clonePlaceholder(node) {
            return cloneIdentifier(node);
        }
        function cloneIdentifier(node) {
            var type = node.type, start = node.start, end = node.end, loc = node.loc, range = node.range, extra = node.extra, name = node.name;
            var cloned = Object.create(NodePrototype);
            cloned.type = type;
            cloned.start = start;
            cloned.end = end;
            cloned.loc = loc;
            cloned.range = range;
            cloned.extra = extra;
            cloned.name = name;
            if (type === "Placeholder") {
                cloned.expectedNode = node.expectedNode;
            }
            return cloned;
        }
        function cloneStringLiteral(node) {
            var type = node.type, start = node.start, end = node.end, loc = node.loc, range = node.range, extra = node.extra;
            if (type === "Placeholder") {
                return clonePlaceholder(node);
            }
            var cloned = Object.create(NodePrototype);
            cloned.type = type;
            cloned.start = start;
            cloned.end = end;
            cloned.loc = loc;
            cloned.range = range;
            if (node.raw !== void 0) {
                cloned.raw = node.raw;
            } else {
                cloned.extra = extra;
            }
            cloned.value = node.value;
            return cloned;
        }
        var NodeUtils = /*#__PURE__*/ function(UtilParser) {
            _inherits(NodeUtils, UtilParser);
            function NodeUtils() {
                _class_call_check(this, NodeUtils);
                return _call_super(this, NodeUtils, arguments);
            }
            _create_class(NodeUtils, [
                {
                    key: "startNode",
                    value: function startNode() {
                        var loc = this.state.startLoc;
                        return new Node(this, loc.index, loc);
                    }
                },
                {
                    key: "startNodeAt",
                    value: function startNodeAt(loc) {
                        return new Node(this, loc.index, loc);
                    }
                },
                {
                    key: "startNodeAtNode",
                    value: function startNodeAtNode(type) {
                        return this.startNodeAt(type.loc.start);
                    }
                },
                {
                    key: "finishNode",
                    value: function finishNode(node, type) {
                        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
                    }
                },
                {
                    key: "finishNodeAt",
                    value: function finishNodeAt(node, type, endLoc) {
                        node.type = type;
                        node.end = endLoc.index;
                        node.loc.end = endLoc;
                        if (this.options.ranges) node.range[1] = endLoc.index;
                        if (this.options.attachComment) this.processComment(node);
                        return node;
                    }
                },
                {
                    key: "resetStartLocation",
                    value: function resetStartLocation(node, startLoc) {
                        node.start = startLoc.index;
                        node.loc.start = startLoc;
                        if (this.options.ranges) node.range[0] = startLoc.index;
                    }
                },
                {
                    key: "resetEndLocation",
                    value: function resetEndLocation(node) {
                        var endLoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                        node.end = endLoc.index;
                        node.loc.end = endLoc;
                        if (this.options.ranges) node.range[1] = endLoc.index;
                    }
                },
                {
                    key: "resetStartLocationFromNode",
                    value: function resetStartLocationFromNode(node, locationNode) {
                        this.resetStartLocation(node, locationNode.loc.start);
                    }
                }
            ]);
            return NodeUtils;
        }(UtilParser);
        var reservedTypes = /* @__PURE__ */ new Set([
            "_",
            "any",
            "bool",
            "boolean",
            "empty",
            "extends",
            "false",
            "interface",
            "mixed",
            "null",
            "number",
            "static",
            "string",
            "true",
            "typeof",
            "void"
        ]);
        var FlowErrors = ParseErrorEnum(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([
            "flow"
        ])))({
            AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
            AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
            AssignReservedType: function(_ref41) {
                var reservedType = _ref41.reservedType;
                return "Cannot overwrite reserved type ".concat(reservedType, ".");
            },
            DeclareClassElement: "The `declare` modifier can only appear on class fields.",
            DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
            DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
            EnumBooleanMemberNotInitialized: function(_ref42) {
                var memberName = _ref42.memberName, enumName = _ref42.enumName;
                return "Boolean enum members need to be initialized. Use either `".concat(memberName, " = true,` or `").concat(memberName, " = false,` in enum `").concat(enumName, "`.");
            },
            EnumDuplicateMemberName: function(_ref43) {
                var memberName = _ref43.memberName, enumName = _ref43.enumName;
                return "Enum member names need to be unique, but the name `".concat(memberName, "` has already been used before in enum `").concat(enumName, "`.");
            },
            EnumInconsistentMemberValues: function(_ref44) {
                var enumName = _ref44.enumName;
                return "Enum `".concat(enumName, "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");
            },
            EnumInvalidExplicitType: function(_ref45) {
                var invalidEnumType = _ref45.invalidEnumType, enumName = _ref45.enumName;
                return "Enum type `".concat(invalidEnumType, "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(enumName, "`.");
            },
            EnumInvalidExplicitTypeUnknownSupplied: function(_ref46) {
                var enumName = _ref46.enumName;
                return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(enumName, "`.");
            },
            EnumInvalidMemberInitializerPrimaryType: function(_ref47) {
                var enumName = _ref47.enumName, memberName = _ref47.memberName, explicitType = _ref47.explicitType;
                return "Enum `".concat(enumName, "` has type `").concat(explicitType, "`, so the initializer of `").concat(memberName, "` needs to be a ").concat(explicitType, " literal.");
            },
            EnumInvalidMemberInitializerSymbolType: function(_ref48) {
                var enumName = _ref48.enumName, memberName = _ref48.memberName;
                return "Symbol enum members cannot be initialized. Use `".concat(memberName, ",` in enum `").concat(enumName, "`.");
            },
            EnumInvalidMemberInitializerUnknownType: function(_ref49) {
                var enumName = _ref49.enumName, memberName = _ref49.memberName;
                return "The enum member initializer for `".concat(memberName, "` needs to be a literal (either a boolean, number, or string) in enum `").concat(enumName, "`.");
            },
            EnumInvalidMemberName: function(_ref50) {
                var enumName = _ref50.enumName, memberName = _ref50.memberName, suggestion = _ref50.suggestion;
                return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(memberName, "`, consider using `").concat(suggestion, "`, in enum `").concat(enumName, "`.");
            },
            EnumNumberMemberNotInitialized: function(_ref51) {
                var enumName = _ref51.enumName, memberName = _ref51.memberName;
                return "Number enum members need to be initialized, e.g. `".concat(memberName, " = 1` in enum `").concat(enumName, "`.");
            },
            EnumStringMemberInconsistentlyInitialized: function(_ref52) {
                var enumName = _ref52.enumName;
                return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(enumName, "`.");
            },
            GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
            ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
            ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
            InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
            InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
            InexactVariance: "Explicit inexact syntax cannot have variance.",
            InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
            MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
            NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
            NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
            PatternIsOptional: Object.assign({
                message: "A binding pattern parameter cannot be optional in an implementation signature."
            }, {
                reasonCode: "OptionalBindingPattern"
            }),
            SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
            SpreadVariance: "Spread properties cannot have variance.",
            ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
            ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
            ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
            ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
            ThisParamNoDefault: "The `this` parameter may not have a default value.",
            TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
            TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
            UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
            UnexpectedReservedType: function(_ref53) {
                var reservedType = _ref53.reservedType;
                return "Unexpected reserved type ".concat(reservedType, ".");
            },
            UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
            UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
            UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
            UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
            UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
            UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
            UnsupportedDeclareExportKind: function(_ref54) {
                var unsupportedExportKind = _ref54.unsupportedExportKind, suggestion = _ref54.suggestion;
                return "`declare export ".concat(unsupportedExportKind, "` is not supported. Use `").concat(suggestion, "` instead.");
            },
            UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
            UnterminatedFlowComment: "Unterminated flow-comment."
        });
        function isEsModuleType(bodyElement) {
            return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
        }
        function hasTypeImportKind(node) {
            return node.importKind === "type" || node.importKind === "typeof";
        }
        var exportSuggestions = {
            const: "declare export var",
            let: "declare export var",
            type: "export type",
            interface: "export interface"
        };
        function partition(list, test) {
            var list1 = [];
            var list2 = [];
            for(var i = 0; i < list.length; i++){
                (test(list[i], i, list) ? list1 : list2).push(list[i]);
            }
            return [
                list1,
                list2
            ];
        }
        var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
        var flow = function(superClass) {
            var FlowParserMixin = /*#__PURE__*/ function(superClass) {
                _inherits(FlowParserMixin, superClass);
                function FlowParserMixin() {
                    _class_call_check(this, FlowParserMixin);
                    var _this;
                    _this = _call_super(this, FlowParserMixin, arguments);
                    _this.flowPragma = void 0;
                    return _this;
                }
                _create_class(FlowParserMixin, [
                    {
                        key: "getScopeHandler",
                        value: function getScopeHandler() {
                            return FlowScopeHandler;
                        }
                    },
                    {
                        key: "shouldParseTypes",
                        value: function shouldParseTypes() {
                            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
                        }
                    },
                    {
                        key: "finishToken",
                        value: function finishToken(type, val) {
                            if (type !== 134 && type !== 13 && type !== 28) {
                                if (this.flowPragma === void 0) {
                                    this.flowPragma = null;
                                }
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "finishToken", this).call(this, type, val);
                        }
                    },
                    {
                        key: "addComment",
                        value: function addComment(comment) {
                            if (this.flowPragma === void 0) {
                                var matches = FLOW_PRAGMA_REGEX.exec(comment.value);
                                if (!matches) ;
                                else if (matches[1] === "flow") {
                                    this.flowPragma = "flow";
                                } else if (matches[1] === "noflow") {
                                    this.flowPragma = "noflow";
                                } else {
                                    throw new Error("Unexpected flow pragma");
                                }
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "addComment", this).call(this, comment);
                        }
                    },
                    {
                        key: "flowParseTypeInitialiser",
                        value: function flowParseTypeInitialiser(tok) {
                            var oldInType = this.state.inType;
                            this.state.inType = true;
                            this.expect(tok || 14);
                            var type = this.flowParseType();
                            this.state.inType = oldInType;
                            return type;
                        }
                    },
                    {
                        key: "flowParsePredicate",
                        value: function flowParsePredicate() {
                            var node = this.startNode();
                            var moduloLoc = this.state.startLoc;
                            this.next();
                            this.expectContextual(110);
                            if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
                                this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
                            }
                            if (this.eat(10)) {
                                node.value = _get(_get_prototype_of(FlowParserMixin.prototype), "parseExpression", this).call(this);
                                this.expect(11);
                                return this.finishNode(node, "DeclaredPredicate");
                            } else {
                                return this.finishNode(node, "InferredPredicate");
                            }
                        }
                    },
                    {
                        key: "flowParseTypeAndPredicateInitialiser",
                        value: function flowParseTypeAndPredicateInitialiser() {
                            var oldInType = this.state.inType;
                            this.state.inType = true;
                            this.expect(14);
                            var type = null;
                            var predicate = null;
                            if (this.match(54)) {
                                this.state.inType = oldInType;
                                predicate = this.flowParsePredicate();
                            } else {
                                type = this.flowParseType();
                                this.state.inType = oldInType;
                                if (this.match(54)) {
                                    predicate = this.flowParsePredicate();
                                }
                            }
                            return [
                                type,
                                predicate
                            ];
                        }
                    },
                    {
                        key: "flowParseDeclareClass",
                        value: function flowParseDeclareClass(node) {
                            this.next();
                            this.flowParseInterfaceish(node, true);
                            return this.finishNode(node, "DeclareClass");
                        }
                    },
                    {
                        key: "flowParseDeclareFunction",
                        value: function flowParseDeclareFunction(node) {
                            this.next();
                            var id = node.id = this.parseIdentifier();
                            var typeNode = this.startNode();
                            var typeContainer = this.startNode();
                            if (this.match(47)) {
                                typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
                            } else {
                                typeNode.typeParameters = null;
                            }
                            this.expect(10);
                            var tmp = this.flowParseFunctionTypeParams();
                            typeNode.params = tmp.params;
                            typeNode.rest = tmp.rest;
                            typeNode.this = tmp._this;
                            this.expect(11);
                            var ref;
                            ref = _sliced_to_array(this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.returnType = ref[0], node.predicate = ref[1], ref;
                            typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
                            id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
                            this.resetEndLocation(id);
                            this.semicolon();
                            this.scope.declareName(node.id.name, 2048, node.id.loc.start);
                            return this.finishNode(node, "DeclareFunction");
                        }
                    },
                    {
                        key: "flowParseDeclare",
                        value: function flowParseDeclare(node, insideModule) {
                            if (this.match(80)) {
                                return this.flowParseDeclareClass(node);
                            } else if (this.match(68)) {
                                return this.flowParseDeclareFunction(node);
                            } else if (this.match(74)) {
                                return this.flowParseDeclareVariable(node);
                            } else if (this.eatContextual(127)) {
                                if (this.match(16)) {
                                    return this.flowParseDeclareModuleExports(node);
                                } else {
                                    if (insideModule) {
                                        this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
                                    }
                                    return this.flowParseDeclareModule(node);
                                }
                            } else if (this.isContextual(130)) {
                                return this.flowParseDeclareTypeAlias(node);
                            } else if (this.isContextual(131)) {
                                return this.flowParseDeclareOpaqueType(node);
                            } else if (this.isContextual(129)) {
                                return this.flowParseDeclareInterface(node);
                            } else if (this.match(82)) {
                                return this.flowParseDeclareExportDeclaration(node, insideModule);
                            } else {
                                this.unexpected();
                            }
                        }
                    },
                    {
                        key: "flowParseDeclareVariable",
                        value: function flowParseDeclareVariable(node) {
                            this.next();
                            node.id = this.flowParseTypeAnnotatableIdentifier(true);
                            this.scope.declareName(node.id.name, 5, node.id.loc.start);
                            this.semicolon();
                            return this.finishNode(node, "DeclareVariable");
                        }
                    },
                    {
                        key: "flowParseDeclareModule",
                        value: function flowParseDeclareModule(node) {
                            var _this = this;
                            this.scope.enter(0);
                            if (this.match(134)) {
                                node.id = _get(_get_prototype_of(FlowParserMixin.prototype), "parseExprAtom", this).call(this);
                            } else {
                                node.id = this.parseIdentifier();
                            }
                            var bodyNode = node.body = this.startNode();
                            var body3 = bodyNode.body = [];
                            this.expect(5);
                            while(!this.match(8)){
                                var _bodyNode = this.startNode();
                                if (this.match(83)) {
                                    this.next();
                                    if (!this.isContextual(130) && !this.match(87)) {
                                        this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
                                    }
                                    _get(_get_prototype_of(FlowParserMixin.prototype), "parseImport", this).call(this, _bodyNode);
                                } else {
                                    this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
                                    _bodyNode = this.flowParseDeclare(_bodyNode, true);
                                }
                                body3.push(_bodyNode);
                            }
                            this.scope.exit();
                            this.expect(8);
                            this.finishNode(bodyNode, "BlockStatement");
                            var kind = null;
                            var hasModuleExport = false;
                            body3.forEach(function(bodyElement) {
                                if (isEsModuleType(bodyElement)) {
                                    if (kind === "CommonJS") {
                                        _this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
                                    }
                                    kind = "ES";
                                } else if (bodyElement.type === "DeclareModuleExports") {
                                    if (hasModuleExport) {
                                        _this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
                                    }
                                    if (kind === "ES") {
                                        _this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
                                    }
                                    kind = "CommonJS";
                                    hasModuleExport = true;
                                }
                            });
                            node.kind = kind || "CommonJS";
                            return this.finishNode(node, "DeclareModule");
                        }
                    },
                    {
                        key: "flowParseDeclareExportDeclaration",
                        value: function flowParseDeclareExportDeclaration(node, insideModule) {
                            this.expect(82);
                            if (this.eat(65)) {
                                if (this.match(68) || this.match(80)) {
                                    node.declaration = this.flowParseDeclare(this.startNode());
                                } else {
                                    node.declaration = this.flowParseType();
                                    this.semicolon();
                                }
                                node.default = true;
                                return this.finishNode(node, "DeclareExportDeclaration");
                            } else {
                                if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
                                    var label = this.state.value;
                                    throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
                                        unsupportedExportKind: label,
                                        suggestion: exportSuggestions[label]
                                    });
                                }
                                if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
                                    node.declaration = this.flowParseDeclare(this.startNode());
                                    node.default = false;
                                    return this.finishNode(node, "DeclareExportDeclaration");
                                } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
                                    node = this.parseExport(node, null);
                                    if (node.type === "ExportNamedDeclaration") {
                                        node.type = "ExportDeclaration";
                                        node.default = false;
                                        delete node.exportKind;
                                    }
                                    node.type = "Declare" + node.type;
                                    return node;
                                }
                            }
                            this.unexpected();
                        }
                    },
                    {
                        key: "flowParseDeclareModuleExports",
                        value: function flowParseDeclareModuleExports(node) {
                            this.next();
                            this.expectContextual(111);
                            node.typeAnnotation = this.flowParseTypeAnnotation();
                            this.semicolon();
                            return this.finishNode(node, "DeclareModuleExports");
                        }
                    },
                    {
                        key: "flowParseDeclareTypeAlias",
                        value: function flowParseDeclareTypeAlias(node) {
                            this.next();
                            var finished = this.flowParseTypeAlias(node);
                            finished.type = "DeclareTypeAlias";
                            return finished;
                        }
                    },
                    {
                        key: "flowParseDeclareOpaqueType",
                        value: function flowParseDeclareOpaqueType(node) {
                            this.next();
                            var finished = this.flowParseOpaqueType(node, true);
                            finished.type = "DeclareOpaqueType";
                            return finished;
                        }
                    },
                    {
                        key: "flowParseDeclareInterface",
                        value: function flowParseDeclareInterface(node) {
                            this.next();
                            this.flowParseInterfaceish(node, false);
                            return this.finishNode(node, "DeclareInterface");
                        }
                    },
                    {
                        key: "flowParseInterfaceish",
                        value: function flowParseInterfaceish(node, isClass) {
                            node.id = this.flowParseRestrictedIdentifier(!isClass, true);
                            this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
                            if (this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterDeclaration();
                            } else {
                                node.typeParameters = null;
                            }
                            node.extends = [];
                            if (this.eat(81)) {
                                do {
                                    node.extends.push(this.flowParseInterfaceExtends());
                                }while (!isClass && this.eat(12));
                            }
                            if (isClass) {
                                node.implements = [];
                                node.mixins = [];
                                if (this.eatContextual(117)) {
                                    do {
                                        node.mixins.push(this.flowParseInterfaceExtends());
                                    }while (this.eat(12));
                                }
                                if (this.eatContextual(113)) {
                                    do {
                                        node.implements.push(this.flowParseInterfaceExtends());
                                    }while (this.eat(12));
                                }
                            }
                            node.body = this.flowParseObjectType({
                                allowStatic: isClass,
                                allowExact: false,
                                allowSpread: false,
                                allowProto: isClass,
                                allowInexact: false
                            });
                        }
                    },
                    {
                        key: "flowParseInterfaceExtends",
                        value: function flowParseInterfaceExtends() {
                            var node = this.startNode();
                            node.id = this.flowParseQualifiedTypeIdentifier();
                            if (this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterInstantiation();
                            } else {
                                node.typeParameters = null;
                            }
                            return this.finishNode(node, "InterfaceExtends");
                        }
                    },
                    {
                        key: "flowParseInterface",
                        value: function flowParseInterface(node) {
                            this.flowParseInterfaceish(node, false);
                            return this.finishNode(node, "InterfaceDeclaration");
                        }
                    },
                    {
                        key: "checkNotUnderscore",
                        value: function checkNotUnderscore(word) {
                            if (word === "_") {
                                this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
                            }
                        }
                    },
                    {
                        key: "checkReservedType",
                        value: function checkReservedType(word, startLoc, declaration) {
                            if (!reservedTypes.has(word)) return;
                            this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
                                reservedType: word
                            });
                        }
                    },
                    {
                        key: "flowParseRestrictedIdentifier",
                        value: function flowParseRestrictedIdentifier(liberal, declaration) {
                            this.checkReservedType(this.state.value, this.state.startLoc, declaration);
                            return this.parseIdentifier(liberal);
                        }
                    },
                    {
                        key: "flowParseTypeAlias",
                        value: function flowParseTypeAlias(node) {
                            node.id = this.flowParseRestrictedIdentifier(false, true);
                            this.scope.declareName(node.id.name, 8201, node.id.loc.start);
                            if (this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterDeclaration();
                            } else {
                                node.typeParameters = null;
                            }
                            node.right = this.flowParseTypeInitialiser(29);
                            this.semicolon();
                            return this.finishNode(node, "TypeAlias");
                        }
                    },
                    {
                        key: "flowParseOpaqueType",
                        value: function flowParseOpaqueType(node, declare) {
                            this.expectContextual(130);
                            node.id = this.flowParseRestrictedIdentifier(true, true);
                            this.scope.declareName(node.id.name, 8201, node.id.loc.start);
                            if (this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterDeclaration();
                            } else {
                                node.typeParameters = null;
                            }
                            node.supertype = null;
                            if (this.match(14)) {
                                node.supertype = this.flowParseTypeInitialiser(14);
                            }
                            node.impltype = null;
                            if (!declare) {
                                node.impltype = this.flowParseTypeInitialiser(29);
                            }
                            this.semicolon();
                            return this.finishNode(node, "OpaqueType");
                        }
                    },
                    {
                        key: "flowParseTypeParameter",
                        value: function flowParseTypeParameter() {
                            var requireDefault = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                            var nodeStartLoc = this.state.startLoc;
                            var node = this.startNode();
                            var variance = this.flowParseVariance();
                            var ident = this.flowParseTypeAnnotatableIdentifier();
                            node.name = ident.name;
                            node.variance = variance;
                            node.bound = ident.typeAnnotation;
                            if (this.match(29)) {
                                this.eat(29);
                                node.default = this.flowParseType();
                            } else {
                                if (requireDefault) {
                                    this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
                                }
                            }
                            return this.finishNode(node, "TypeParameter");
                        }
                    },
                    {
                        key: "flowParseTypeParameterDeclaration",
                        value: function flowParseTypeParameterDeclaration() {
                            var oldInType = this.state.inType;
                            var node = this.startNode();
                            node.params = [];
                            this.state.inType = true;
                            if (this.match(47) || this.match(143)) {
                                this.next();
                            } else {
                                this.unexpected();
                            }
                            var defaultRequired = false;
                            do {
                                var typeParameter = this.flowParseTypeParameter(defaultRequired);
                                node.params.push(typeParameter);
                                if (typeParameter.default) {
                                    defaultRequired = true;
                                }
                                if (!this.match(48)) {
                                    this.expect(12);
                                }
                            }while (!this.match(48));
                            this.expect(48);
                            this.state.inType = oldInType;
                            return this.finishNode(node, "TypeParameterDeclaration");
                        }
                    },
                    {
                        key: "flowParseTypeParameterInstantiation",
                        value: function flowParseTypeParameterInstantiation() {
                            var node = this.startNode();
                            var oldInType = this.state.inType;
                            node.params = [];
                            this.state.inType = true;
                            this.expect(47);
                            var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = false;
                            while(!this.match(48)){
                                node.params.push(this.flowParseType());
                                if (!this.match(48)) {
                                    this.expect(12);
                                }
                            }
                            this.state.noAnonFunctionType = oldNoAnonFunctionType;
                            this.expect(48);
                            this.state.inType = oldInType;
                            return this.finishNode(node, "TypeParameterInstantiation");
                        }
                    },
                    {
                        key: "flowParseTypeParameterInstantiationCallOrNew",
                        value: function flowParseTypeParameterInstantiationCallOrNew() {
                            var node = this.startNode();
                            var oldInType = this.state.inType;
                            node.params = [];
                            this.state.inType = true;
                            this.expect(47);
                            while(!this.match(48)){
                                node.params.push(this.flowParseTypeOrImplicitInstantiation());
                                if (!this.match(48)) {
                                    this.expect(12);
                                }
                            }
                            this.expect(48);
                            this.state.inType = oldInType;
                            return this.finishNode(node, "TypeParameterInstantiation");
                        }
                    },
                    {
                        key: "flowParseInterfaceType",
                        value: function flowParseInterfaceType() {
                            var node = this.startNode();
                            this.expectContextual(129);
                            node.extends = [];
                            if (this.eat(81)) {
                                do {
                                    node.extends.push(this.flowParseInterfaceExtends());
                                }while (this.eat(12));
                            }
                            node.body = this.flowParseObjectType({
                                allowStatic: false,
                                allowExact: false,
                                allowSpread: false,
                                allowProto: false,
                                allowInexact: false
                            });
                            return this.finishNode(node, "InterfaceTypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseObjectPropertyKey",
                        value: function flowParseObjectPropertyKey() {
                            return this.match(135) || this.match(134) ? _get(_get_prototype_of(FlowParserMixin.prototype), "parseExprAtom", this).call(this) : this.parseIdentifier(true);
                        }
                    },
                    {
                        key: "flowParseObjectTypeIndexer",
                        value: function flowParseObjectTypeIndexer(node, isStatic, variance) {
                            node.static = isStatic;
                            if (this.lookahead().type === 14) {
                                node.id = this.flowParseObjectPropertyKey();
                                node.key = this.flowParseTypeInitialiser();
                            } else {
                                node.id = null;
                                node.key = this.flowParseType();
                            }
                            this.expect(3);
                            node.value = this.flowParseTypeInitialiser();
                            node.variance = variance;
                            return this.finishNode(node, "ObjectTypeIndexer");
                        }
                    },
                    {
                        key: "flowParseObjectTypeInternalSlot",
                        value: function flowParseObjectTypeInternalSlot(node, isStatic) {
                            node.static = isStatic;
                            node.id = this.flowParseObjectPropertyKey();
                            this.expect(3);
                            this.expect(3);
                            if (this.match(47) || this.match(10)) {
                                node.method = true;
                                node.optional = false;
                                node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
                            } else {
                                node.method = false;
                                if (this.eat(17)) {
                                    node.optional = true;
                                }
                                node.value = this.flowParseTypeInitialiser();
                            }
                            return this.finishNode(node, "ObjectTypeInternalSlot");
                        }
                    },
                    {
                        key: "flowParseObjectTypeMethodish",
                        value: function flowParseObjectTypeMethodish(node) {
                            node.params = [];
                            node.rest = null;
                            node.typeParameters = null;
                            node.this = null;
                            if (this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterDeclaration();
                            }
                            this.expect(10);
                            if (this.match(78)) {
                                node.this = this.flowParseFunctionTypeParam(true);
                                node.this.name = null;
                                if (!this.match(11)) {
                                    this.expect(12);
                                }
                            }
                            while(!this.match(11) && !this.match(21)){
                                node.params.push(this.flowParseFunctionTypeParam(false));
                                if (!this.match(11)) {
                                    this.expect(12);
                                }
                            }
                            if (this.eat(21)) {
                                node.rest = this.flowParseFunctionTypeParam(false);
                            }
                            this.expect(11);
                            node.returnType = this.flowParseTypeInitialiser();
                            return this.finishNode(node, "FunctionTypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseObjectTypeCallProperty",
                        value: function flowParseObjectTypeCallProperty(node, isStatic) {
                            var valueNode = this.startNode();
                            node.static = isStatic;
                            node.value = this.flowParseObjectTypeMethodish(valueNode);
                            return this.finishNode(node, "ObjectTypeCallProperty");
                        }
                    },
                    {
                        key: "flowParseObjectType",
                        value: function flowParseObjectType(_ref55) {
                            var allowStatic = _ref55.allowStatic, allowExact = _ref55.allowExact, allowSpread = _ref55.allowSpread, allowProto = _ref55.allowProto, allowInexact = _ref55.allowInexact;
                            var oldInType = this.state.inType;
                            this.state.inType = true;
                            var nodeStart = this.startNode();
                            nodeStart.callProperties = [];
                            nodeStart.properties = [];
                            nodeStart.indexers = [];
                            nodeStart.internalSlots = [];
                            var endDelim;
                            var exact;
                            var inexact = false;
                            if (allowExact && this.match(6)) {
                                this.expect(6);
                                endDelim = 9;
                                exact = true;
                            } else {
                                this.expect(5);
                                endDelim = 8;
                                exact = false;
                            }
                            nodeStart.exact = exact;
                            while(!this.match(endDelim)){
                                var isStatic = false;
                                var protoStartLoc = null;
                                var inexactStartLoc = null;
                                var node = this.startNode();
                                if (allowProto && this.isContextual(118)) {
                                    var lookahead = this.lookahead();
                                    if (lookahead.type !== 14 && lookahead.type !== 17) {
                                        this.next();
                                        protoStartLoc = this.state.startLoc;
                                        allowStatic = false;
                                    }
                                }
                                if (allowStatic && this.isContextual(106)) {
                                    var _lookahead = this.lookahead();
                                    if (_lookahead.type !== 14 && _lookahead.type !== 17) {
                                        this.next();
                                        isStatic = true;
                                    }
                                }
                                var variance = this.flowParseVariance();
                                if (this.eat(0)) {
                                    if (protoStartLoc != null) {
                                        this.unexpected(protoStartLoc);
                                    }
                                    if (this.eat(0)) {
                                        if (variance) {
                                            this.unexpected(variance.loc.start);
                                        }
                                        nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
                                    } else {
                                        nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
                                    }
                                } else if (this.match(10) || this.match(47)) {
                                    if (protoStartLoc != null) {
                                        this.unexpected(protoStartLoc);
                                    }
                                    if (variance) {
                                        this.unexpected(variance.loc.start);
                                    }
                                    nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
                                } else {
                                    var kind = "init";
                                    if (this.isContextual(99) || this.isContextual(104)) {
                                        var _lookahead2 = this.lookahead();
                                        if (tokenIsLiteralPropertyName(_lookahead2.type)) {
                                            kind = this.state.value;
                                            this.next();
                                        }
                                    }
                                    var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
                                    if (propOrInexact === null) {
                                        inexact = true;
                                        inexactStartLoc = this.state.lastTokStartLoc;
                                    } else {
                                        nodeStart.properties.push(propOrInexact);
                                    }
                                }
                                this.flowObjectTypeSemicolon();
                                if (inexactStartLoc && !this.match(8) && !this.match(9)) {
                                    this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
                                }
                            }
                            this.expect(endDelim);
                            if (allowSpread) {
                                nodeStart.inexact = inexact;
                            }
                            var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
                            this.state.inType = oldInType;
                            return out;
                        }
                    },
                    {
                        key: "flowParseObjectTypeProperty",
                        value: function flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
                            if (this.eat(21)) {
                                var isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
                                if (isInexactToken) {
                                    if (!allowSpread) {
                                        this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
                                    } else if (!allowInexact) {
                                        this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
                                    }
                                    if (variance) {
                                        this.raise(FlowErrors.InexactVariance, variance);
                                    }
                                    return null;
                                }
                                if (!allowSpread) {
                                    this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
                                }
                                if (protoStartLoc != null) {
                                    this.unexpected(protoStartLoc);
                                }
                                if (variance) {
                                    this.raise(FlowErrors.SpreadVariance, variance);
                                }
                                node.argument = this.flowParseType();
                                return this.finishNode(node, "ObjectTypeSpreadProperty");
                            } else {
                                node.key = this.flowParseObjectPropertyKey();
                                node.static = isStatic;
                                node.proto = protoStartLoc != null;
                                node.kind = kind;
                                var optional = false;
                                if (this.match(47) || this.match(10)) {
                                    node.method = true;
                                    if (protoStartLoc != null) {
                                        this.unexpected(protoStartLoc);
                                    }
                                    if (variance) {
                                        this.unexpected(variance.loc.start);
                                    }
                                    node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
                                    if (kind === "get" || kind === "set") {
                                        this.flowCheckGetterSetterParams(node);
                                    }
                                    if (!allowSpread && node.key.name === "constructor" && node.value.this) {
                                        this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
                                    }
                                } else {
                                    if (kind !== "init") this.unexpected();
                                    node.method = false;
                                    if (this.eat(17)) {
                                        optional = true;
                                    }
                                    node.value = this.flowParseTypeInitialiser();
                                    node.variance = variance;
                                }
                                node.optional = optional;
                                return this.finishNode(node, "ObjectTypeProperty");
                            }
                        }
                    },
                    {
                        key: "flowCheckGetterSetterParams",
                        value: function flowCheckGetterSetterParams(property) {
                            var paramCount = property.kind === "get" ? 0 : 1;
                            var length = property.value.params.length + (property.value.rest ? 1 : 0);
                            if (property.value.this) {
                                this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
                            }
                            if (length !== paramCount) {
                                this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
                            }
                            if (property.kind === "set" && property.value.rest) {
                                this.raise(Errors.BadSetterRestParameter, property);
                            }
                        }
                    },
                    {
                        key: "flowObjectTypeSemicolon",
                        value: function flowObjectTypeSemicolon() {
                            if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
                                this.unexpected();
                            }
                        }
                    },
                    {
                        key: "flowParseQualifiedTypeIdentifier",
                        value: function flowParseQualifiedTypeIdentifier(startLoc, id) {
                            var _startLoc;
                            (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
                            var node = id || this.flowParseRestrictedIdentifier(true);
                            while(this.eat(16)){
                                var node2 = this.startNodeAt(startLoc);
                                node2.qualification = node;
                                node2.id = this.flowParseRestrictedIdentifier(true);
                                node = this.finishNode(node2, "QualifiedTypeIdentifier");
                            }
                            return node;
                        }
                    },
                    {
                        key: "flowParseGenericType",
                        value: function flowParseGenericType(startLoc, id) {
                            var node = this.startNodeAt(startLoc);
                            node.typeParameters = null;
                            node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
                            if (this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterInstantiation();
                            }
                            return this.finishNode(node, "GenericTypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseTypeofType",
                        value: function flowParseTypeofType() {
                            var node = this.startNode();
                            this.expect(87);
                            node.argument = this.flowParsePrimaryType();
                            return this.finishNode(node, "TypeofTypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseTupleType",
                        value: function flowParseTupleType() {
                            var node = this.startNode();
                            node.types = [];
                            this.expect(0);
                            while(this.state.pos < this.length && !this.match(3)){
                                node.types.push(this.flowParseType());
                                if (this.match(3)) break;
                                this.expect(12);
                            }
                            this.expect(3);
                            return this.finishNode(node, "TupleTypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseFunctionTypeParam",
                        value: function flowParseFunctionTypeParam(first) {
                            var name = null;
                            var optional = false;
                            var typeAnnotation = null;
                            var node = this.startNode();
                            var lh = this.lookahead();
                            var isThis = this.state.type === 78;
                            if (lh.type === 14 || lh.type === 17) {
                                if (isThis && !first) {
                                    this.raise(FlowErrors.ThisParamMustBeFirst, node);
                                }
                                name = this.parseIdentifier(isThis);
                                if (this.eat(17)) {
                                    optional = true;
                                    if (isThis) {
                                        this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
                                    }
                                }
                                typeAnnotation = this.flowParseTypeInitialiser();
                            } else {
                                typeAnnotation = this.flowParseType();
                            }
                            node.name = name;
                            node.optional = optional;
                            node.typeAnnotation = typeAnnotation;
                            return this.finishNode(node, "FunctionTypeParam");
                        }
                    },
                    {
                        key: "reinterpretTypeAsFunctionTypeParam",
                        value: function reinterpretTypeAsFunctionTypeParam(type) {
                            var node = this.startNodeAt(type.loc.start);
                            node.name = null;
                            node.optional = false;
                            node.typeAnnotation = type;
                            return this.finishNode(node, "FunctionTypeParam");
                        }
                    },
                    {
                        key: "flowParseFunctionTypeParams",
                        value: function flowParseFunctionTypeParams() {
                            var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                            var rest = null;
                            var _this = null;
                            if (this.match(78)) {
                                _this = this.flowParseFunctionTypeParam(true);
                                _this.name = null;
                                if (!this.match(11)) {
                                    this.expect(12);
                                }
                            }
                            while(!this.match(11) && !this.match(21)){
                                params.push(this.flowParseFunctionTypeParam(false));
                                if (!this.match(11)) {
                                    this.expect(12);
                                }
                            }
                            if (this.eat(21)) {
                                rest = this.flowParseFunctionTypeParam(false);
                            }
                            return {
                                params: params,
                                rest: rest,
                                _this: _this
                            };
                        }
                    },
                    {
                        key: "flowIdentToTypeAnnotation",
                        value: function flowIdentToTypeAnnotation(startLoc, node, id) {
                            switch(id.name){
                                case "any":
                                    return this.finishNode(node, "AnyTypeAnnotation");
                                case "bool":
                                case "boolean":
                                    return this.finishNode(node, "BooleanTypeAnnotation");
                                case "mixed":
                                    return this.finishNode(node, "MixedTypeAnnotation");
                                case "empty":
                                    return this.finishNode(node, "EmptyTypeAnnotation");
                                case "number":
                                    return this.finishNode(node, "NumberTypeAnnotation");
                                case "string":
                                    return this.finishNode(node, "StringTypeAnnotation");
                                case "symbol":
                                    return this.finishNode(node, "SymbolTypeAnnotation");
                                default:
                                    this.checkNotUnderscore(id.name);
                                    return this.flowParseGenericType(startLoc, id);
                            }
                        }
                    },
                    {
                        key: "flowParsePrimaryType",
                        value: function flowParsePrimaryType() {
                            var startLoc = this.state.startLoc;
                            var node = this.startNode();
                            var tmp;
                            var type;
                            var isGroupedType = false;
                            var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                            switch(this.state.type){
                                case 5:
                                    return this.flowParseObjectType({
                                        allowStatic: false,
                                        allowExact: false,
                                        allowSpread: true,
                                        allowProto: false,
                                        allowInexact: true
                                    });
                                case 6:
                                    return this.flowParseObjectType({
                                        allowStatic: false,
                                        allowExact: true,
                                        allowSpread: true,
                                        allowProto: false,
                                        allowInexact: false
                                    });
                                case 0:
                                    this.state.noAnonFunctionType = false;
                                    type = this.flowParseTupleType();
                                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                    return type;
                                case 47:
                                    {
                                        var _node = this.startNode();
                                        _node.typeParameters = this.flowParseTypeParameterDeclaration();
                                        this.expect(10);
                                        tmp = this.flowParseFunctionTypeParams();
                                        _node.params = tmp.params;
                                        _node.rest = tmp.rest;
                                        _node.this = tmp._this;
                                        this.expect(11);
                                        this.expect(19);
                                        _node.returnType = this.flowParseType();
                                        return this.finishNode(_node, "FunctionTypeAnnotation");
                                    }
                                case 10:
                                    {
                                        var _node2 = this.startNode();
                                        this.next();
                                        if (!this.match(11) && !this.match(21)) {
                                            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                                                var token = this.lookahead().type;
                                                isGroupedType = token !== 17 && token !== 14;
                                            } else {
                                                isGroupedType = true;
                                            }
                                        }
                                        if (isGroupedType) {
                                            this.state.noAnonFunctionType = false;
                                            type = this.flowParseType();
                                            this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                                                this.expect(11);
                                                return type;
                                            } else {
                                                this.eat(12);
                                            }
                                        }
                                        if (type) {
                                            tmp = this.flowParseFunctionTypeParams([
                                                this.reinterpretTypeAsFunctionTypeParam(type)
                                            ]);
                                        } else {
                                            tmp = this.flowParseFunctionTypeParams();
                                        }
                                        _node2.params = tmp.params;
                                        _node2.rest = tmp.rest;
                                        _node2.this = tmp._this;
                                        this.expect(11);
                                        this.expect(19);
                                        _node2.returnType = this.flowParseType();
                                        _node2.typeParameters = null;
                                        return this.finishNode(_node2, "FunctionTypeAnnotation");
                                    }
                                case 134:
                                    return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                                case 85:
                                case 86:
                                    node.value = this.match(85);
                                    this.next();
                                    return this.finishNode(node, "BooleanLiteralTypeAnnotation");
                                case 53:
                                    if (this.state.value === "-") {
                                        this.next();
                                        if (this.match(135)) {
                                            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                                        }
                                        if (this.match(136)) {
                                            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                                        }
                                        throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
                                    }
                                    this.unexpected();
                                    return;
                                case 135:
                                    return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                                case 136:
                                    return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                                case 88:
                                    this.next();
                                    return this.finishNode(node, "VoidTypeAnnotation");
                                case 84:
                                    this.next();
                                    return this.finishNode(node, "NullLiteralTypeAnnotation");
                                case 78:
                                    this.next();
                                    return this.finishNode(node, "ThisTypeAnnotation");
                                case 55:
                                    this.next();
                                    return this.finishNode(node, "ExistsTypeAnnotation");
                                case 87:
                                    return this.flowParseTypeofType();
                                default:
                                    if (tokenIsKeyword(this.state.type)) {
                                        var label = tokenLabelName(this.state.type);
                                        this.next();
                                        return _get(_get_prototype_of(FlowParserMixin.prototype), "createIdentifier", this).call(this, node, label);
                                    } else if (tokenIsIdentifier(this.state.type)) {
                                        if (this.isContextual(129)) {
                                            return this.flowParseInterfaceType();
                                        }
                                        return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
                                    }
                            }
                            this.unexpected();
                        }
                    },
                    {
                        key: "flowParsePostfixType",
                        value: function flowParsePostfixType() {
                            var startLoc = this.state.startLoc;
                            var type = this.flowParsePrimaryType();
                            var seenOptionalIndexedAccess = false;
                            while((this.match(0) || this.match(18)) && !this.canInsertSemicolon()){
                                var node = this.startNodeAt(startLoc);
                                var optional = this.eat(18);
                                seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
                                this.expect(0);
                                if (!optional && this.match(3)) {
                                    node.elementType = type;
                                    this.next();
                                    type = this.finishNode(node, "ArrayTypeAnnotation");
                                } else {
                                    node.objectType = type;
                                    node.indexType = this.flowParseType();
                                    this.expect(3);
                                    if (seenOptionalIndexedAccess) {
                                        node.optional = optional;
                                        type = this.finishNode(node, "OptionalIndexedAccessType");
                                    } else {
                                        type = this.finishNode(node, "IndexedAccessType");
                                    }
                                }
                            }
                            return type;
                        }
                    },
                    {
                        key: "flowParsePrefixType",
                        value: function flowParsePrefixType() {
                            var node = this.startNode();
                            if (this.eat(17)) {
                                node.typeAnnotation = this.flowParsePrefixType();
                                return this.finishNode(node, "NullableTypeAnnotation");
                            } else {
                                return this.flowParsePostfixType();
                            }
                        }
                    },
                    {
                        key: "flowParseAnonFunctionWithoutParens",
                        value: function flowParseAnonFunctionWithoutParens() {
                            var param = this.flowParsePrefixType();
                            if (!this.state.noAnonFunctionType && this.eat(19)) {
                                var node = this.startNodeAt(param.loc.start);
                                node.params = [
                                    this.reinterpretTypeAsFunctionTypeParam(param)
                                ];
                                node.rest = null;
                                node.this = null;
                                node.returnType = this.flowParseType();
                                node.typeParameters = null;
                                return this.finishNode(node, "FunctionTypeAnnotation");
                            }
                            return param;
                        }
                    },
                    {
                        key: "flowParseIntersectionType",
                        value: function flowParseIntersectionType() {
                            var node = this.startNode();
                            this.eat(45);
                            var type = this.flowParseAnonFunctionWithoutParens();
                            node.types = [
                                type
                            ];
                            while(this.eat(45)){
                                node.types.push(this.flowParseAnonFunctionWithoutParens());
                            }
                            return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseUnionType",
                        value: function flowParseUnionType() {
                            var node = this.startNode();
                            this.eat(43);
                            var type = this.flowParseIntersectionType();
                            node.types = [
                                type
                            ];
                            while(this.eat(43)){
                                node.types.push(this.flowParseIntersectionType());
                            }
                            return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseType",
                        value: function flowParseType() {
                            var oldInType = this.state.inType;
                            this.state.inType = true;
                            var type = this.flowParseUnionType();
                            this.state.inType = oldInType;
                            return type;
                        }
                    },
                    {
                        key: "flowParseTypeOrImplicitInstantiation",
                        value: function flowParseTypeOrImplicitInstantiation() {
                            if (this.state.type === 132 && this.state.value === "_") {
                                var startLoc = this.state.startLoc;
                                var node = this.parseIdentifier();
                                return this.flowParseGenericType(startLoc, node);
                            } else {
                                return this.flowParseType();
                            }
                        }
                    },
                    {
                        key: "flowParseTypeAnnotation",
                        value: function flowParseTypeAnnotation() {
                            var node = this.startNode();
                            node.typeAnnotation = this.flowParseTypeInitialiser();
                            return this.finishNode(node, "TypeAnnotation");
                        }
                    },
                    {
                        key: "flowParseTypeAnnotatableIdentifier",
                        value: function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
                            var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                            if (this.match(14)) {
                                ident.typeAnnotation = this.flowParseTypeAnnotation();
                                this.resetEndLocation(ident);
                            }
                            return ident;
                        }
                    },
                    {
                        key: "typeCastToParameter",
                        value: function typeCastToParameter(node) {
                            node.expression.typeAnnotation = node.typeAnnotation;
                            this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
                            return node.expression;
                        }
                    },
                    {
                        key: "flowParseVariance",
                        value: function flowParseVariance() {
                            var variance = null;
                            if (this.match(53)) {
                                variance = this.startNode();
                                if (this.state.value === "+") {
                                    variance.kind = "plus";
                                } else {
                                    variance.kind = "minus";
                                }
                                this.next();
                                return this.finishNode(variance, "Variance");
                            }
                            return variance;
                        }
                    },
                    {
                        key: "parseFunctionBody",
                        value: function parseFunctionBody(node, allowExpressionBody) {
                            var _this = this;
                            var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            if (allowExpressionBody) {
                                this.forwardNoArrowParamsConversionAt(node, function() {
                                    return _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionBody", _this).call(_this, node, true, isMethod);
                                });
                                return;
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionBody", this).call(this, node, false, isMethod);
                        }
                    },
                    {
                        key: "parseFunctionBodyAndFinish",
                        value: function parseFunctionBodyAndFinish(node, type) {
                            var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            if (this.match(14)) {
                                var typeNode = this.startNode();
                                var ref;
                                ref = _sliced_to_array(this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.typeAnnotation = ref[0], node.predicate = ref[1], ref;
                                node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
                        }
                    },
                    {
                        key: "parseStatementLike",
                        value: function parseStatementLike(flags) {
                            if (this.state.strict && this.isContextual(129)) {
                                var lookahead = this.lookahead();
                                if (tokenIsKeywordOrIdentifier(lookahead.type)) {
                                    var node = this.startNode();
                                    this.next();
                                    return this.flowParseInterface(node);
                                }
                            } else if (this.isContextual(126)) {
                                var _node3 = this.startNode();
                                this.next();
                                return this.flowParseEnumDeclaration(_node3);
                            }
                            var stmt = _get(_get_prototype_of(FlowParserMixin.prototype), "parseStatementLike", this).call(this, flags);
                            if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
                                this.flowPragma = null;
                            }
                            return stmt;
                        }
                    },
                    {
                        key: "parseExpressionStatement",
                        value: function parseExpressionStatement(node, expr, decorators) {
                            if (expr.type === "Identifier") {
                                if (expr.name === "declare") {
                                    if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                                        return this.flowParseDeclare(node);
                                    }
                                } else if (tokenIsIdentifier(this.state.type)) {
                                    if (expr.name === "interface") {
                                        return this.flowParseInterface(node);
                                    } else if (expr.name === "type") {
                                        return this.flowParseTypeAlias(node);
                                    } else if (expr.name === "opaque") {
                                        return this.flowParseOpaqueType(node, false);
                                    }
                                }
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr, decorators);
                        }
                    },
                    {
                        key: "shouldParseExportDeclaration",
                        value: function shouldParseExportDeclaration() {
                            var type = this.state.type;
                            if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
                                return !this.state.containsEsc;
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "shouldParseExportDeclaration", this).call(this);
                        }
                    },
                    {
                        key: "isExportDefaultSpecifier",
                        value: function isExportDefaultSpecifier() {
                            var type = this.state.type;
                            if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
                                return this.state.containsEsc;
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
                        }
                    },
                    {
                        key: "parseExportDefaultExpression",
                        value: function parseExportDefaultExpression() {
                            if (this.isContextual(126)) {
                                var node = this.startNode();
                                this.next();
                                return this.flowParseEnumDeclaration(node);
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseExportDefaultExpression", this).call(this);
                        }
                    },
                    {
                        key: "parseConditional",
                        value: function parseConditional(expr, startLoc, refExpressionErrors) {
                            var _this = this;
                            if (!this.match(17)) return expr;
                            if (this.state.maybeInArrowParameters) {
                                var nextCh = this.lookaheadCharCode();
                                if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
                                    this.setOptionalParametersError(refExpressionErrors);
                                    return expr;
                                }
                            }
                            this.expect(17);
                            var state = this.state.clone();
                            var originalNoArrowAt = this.state.noArrowAt;
                            var node = this.startNodeAt(startLoc);
                            var _this_tryParseConditionalConsequent = this.tryParseConditionalConsequent(), consequent = _this_tryParseConditionalConsequent.consequent, failed = _this_tryParseConditionalConsequent.failed;
                            var _this_getArrowLikeExpressions = _sliced_to_array(this.getArrowLikeExpressions(consequent), 2), valid = _this_getArrowLikeExpressions[0], invalid = _this_getArrowLikeExpressions[1];
                            if (failed || invalid.length > 0) {
                                var noArrowAt = _to_consumable_array(originalNoArrowAt);
                                if (invalid.length > 0) {
                                    this.state = state;
                                    this.state.noArrowAt = noArrowAt;
                                    for(var i = 0; i < invalid.length; i++){
                                        noArrowAt.push(invalid[i].start);
                                    }
                                    var ref;
                                    ref = this.tryParseConditionalConsequent(), consequent = ref.consequent, failed = ref.failed, ref;
                                    var ref1;
                                    ref1 = _sliced_to_array(this.getArrowLikeExpressions(consequent), 2), valid = ref1[0], invalid = ref1[1], ref1;
                                }
                                if (failed && valid.length > 1) {
                                    this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
                                }
                                if (failed && valid.length === 1) {
                                    this.state = state;
                                    noArrowAt.push(valid[0].start);
                                    this.state.noArrowAt = noArrowAt;
                                    var ref2;
                                    ref2 = this.tryParseConditionalConsequent(), consequent = ref2.consequent, failed = ref2.failed, ref2;
                                }
                            }
                            this.getArrowLikeExpressions(consequent, true);
                            this.state.noArrowAt = originalNoArrowAt;
                            this.expect(14);
                            node.test = expr;
                            node.consequent = consequent;
                            node.alternate = this.forwardNoArrowParamsConversionAt(node, function() {
                                return _this.parseMaybeAssign(void 0, void 0);
                            });
                            return this.finishNode(node, "ConditionalExpression");
                        }
                    },
                    {
                        key: "tryParseConditionalConsequent",
                        value: function tryParseConditionalConsequent() {
                            this.state.noArrowParamsConversionAt.push(this.state.start);
                            var consequent = this.parseMaybeAssignAllowIn();
                            var failed = !this.match(14);
                            this.state.noArrowParamsConversionAt.pop();
                            return {
                                consequent: consequent,
                                failed: failed
                            };
                        }
                    },
                    {
                        key: "getArrowLikeExpressions",
                        value: function getArrowLikeExpressions(node, disallowInvalid) {
                            var _this = this;
                            var stack = [
                                node
                            ];
                            var arrows = [];
                            while(stack.length !== 0){
                                var _node4 = stack.pop();
                                if (_node4.type === "ArrowFunctionExpression" && _node4.body.type !== "BlockStatement") {
                                    if (_node4.typeParameters || !_node4.returnType) {
                                        this.finishArrowValidation(_node4);
                                    } else {
                                        arrows.push(_node4);
                                    }
                                    stack.push(_node4.body);
                                } else if (_node4.type === "ConditionalExpression") {
                                    stack.push(_node4.consequent);
                                    stack.push(_node4.alternate);
                                }
                            }
                            if (disallowInvalid) {
                                arrows.forEach(function(node2) {
                                    return _this.finishArrowValidation(node2);
                                });
                                return [
                                    arrows,
                                    []
                                ];
                            }
                            return partition(arrows, function(node2) {
                                return node2.params.every(function(param) {
                                    return _this.isAssignable(param, true);
                                });
                            });
                        }
                    },
                    {
                        key: "finishArrowValidation",
                        value: function finishArrowValidation(node) {
                            var _node$extra;
                            this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
                            this.scope.enter(2 | 4);
                            _get(_get_prototype_of(FlowParserMixin.prototype), "checkParams", this).call(this, node, false, true);
                            this.scope.exit();
                        }
                    },
                    {
                        key: "forwardNoArrowParamsConversionAt",
                        value: function forwardNoArrowParamsConversionAt(node, parse3) {
                            var result;
                            if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
                                this.state.noArrowParamsConversionAt.push(this.state.start);
                                result = parse3();
                                this.state.noArrowParamsConversionAt.pop();
                            } else {
                                result = parse3();
                            }
                            return result;
                        }
                    },
                    {
                        key: "parseParenItem",
                        value: function parseParenItem(node, startLoc) {
                            var newNode = _get(_get_prototype_of(FlowParserMixin.prototype), "parseParenItem", this).call(this, node, startLoc);
                            if (this.eat(17)) {
                                newNode.optional = true;
                                this.resetEndLocation(node);
                            }
                            if (this.match(14)) {
                                var typeCastNode = this.startNodeAt(startLoc);
                                typeCastNode.expression = newNode;
                                typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                                return this.finishNode(typeCastNode, "TypeCastExpression");
                            }
                            return newNode;
                        }
                    },
                    {
                        key: "assertModuleNodeAllowed",
                        value: function assertModuleNodeAllowed(node) {
                            if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
                                return;
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "assertModuleNodeAllowed", this).call(this, node);
                        }
                    },
                    {
                        key: "parseExportDeclaration",
                        value: function parseExportDeclaration(node) {
                            if (this.isContextual(130)) {
                                node.exportKind = "type";
                                var declarationNode = this.startNode();
                                this.next();
                                if (this.match(5)) {
                                    node.specifiers = this.parseExportSpecifiers(true);
                                    _get(_get_prototype_of(FlowParserMixin.prototype), "parseExportFrom", this).call(this, node);
                                    return null;
                                } else {
                                    return this.flowParseTypeAlias(declarationNode);
                                }
                            } else if (this.isContextual(131)) {
                                node.exportKind = "type";
                                var _declarationNode = this.startNode();
                                this.next();
                                return this.flowParseOpaqueType(_declarationNode, false);
                            } else if (this.isContextual(129)) {
                                node.exportKind = "type";
                                var _declarationNode2 = this.startNode();
                                this.next();
                                return this.flowParseInterface(_declarationNode2);
                            } else if (this.isContextual(126)) {
                                node.exportKind = "value";
                                var _declarationNode3 = this.startNode();
                                this.next();
                                return this.flowParseEnumDeclaration(_declarationNode3);
                            } else {
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseExportDeclaration", this).call(this, node);
                            }
                        }
                    },
                    {
                        key: "eatExportStar",
                        value: function eatExportStar(node) {
                            if (_get(_get_prototype_of(FlowParserMixin.prototype), "eatExportStar", this).call(this, node)) return true;
                            if (this.isContextual(130) && this.lookahead().type === 55) {
                                node.exportKind = "type";
                                this.next();
                                this.next();
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "maybeParseExportNamespaceSpecifier",
                        value: function maybeParseExportNamespaceSpecifier(node) {
                            var startLoc = this.state.startLoc;
                            var hasNamespace = _get(_get_prototype_of(FlowParserMixin.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, node);
                            if (hasNamespace && node.exportKind === "type") {
                                this.unexpected(startLoc);
                            }
                            return hasNamespace;
                        }
                    },
                    {
                        key: "parseClassId",
                        value: function parseClassId(node, isStatement, optionalId) {
                            _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassId", this).call(this, node, isStatement, optionalId);
                            if (this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterDeclaration();
                            }
                        }
                    },
                    {
                        key: "parseClassMember",
                        value: function parseClassMember(classBody, member, state) {
                            var startLoc = this.state.startLoc;
                            if (this.isContextual(125)) {
                                if (_get(_get_prototype_of(FlowParserMixin.prototype), "parseClassMemberFromModifier", this).call(this, classBody, member)) {
                                    return;
                                }
                                member.declare = true;
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassMember", this).call(this, classBody, member, state);
                            if (member.declare) {
                                if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
                                    this.raise(FlowErrors.DeclareClassElement, startLoc);
                                } else if (member.value) {
                                    this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
                                }
                            }
                        }
                    },
                    {
                        key: "isIterator",
                        value: function isIterator(word) {
                            return word === "iterator" || word === "asyncIterator";
                        }
                    },
                    {
                        key: "readIterator",
                        value: function readIterator() {
                            var word = _get(_get_prototype_of(FlowParserMixin.prototype), "readWord1", this).call(this);
                            var fullWord = "@@" + word;
                            if (!this.isIterator(word) || !this.state.inType) {
                                this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
                                    identifierName: fullWord
                                });
                            }
                            this.finishToken(132, fullWord);
                        }
                    },
                    {
                        key: "getTokenFromCode",
                        value: function getTokenFromCode(code2) {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (code2 === 123 && next === 124) {
                                this.finishOp(6, 2);
                            } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
                                this.finishOp(code2 === 62 ? 48 : 47, 1);
                            } else if (this.state.inType && code2 === 63) {
                                if (next === 46) {
                                    this.finishOp(18, 2);
                                } else {
                                    this.finishOp(17, 1);
                                }
                            } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
                                this.state.pos += 2;
                                this.readIterator();
                            } else {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                            }
                        }
                    },
                    {
                        key: "isAssignable",
                        value: function isAssignable(node, isBinding) {
                            if (node.type === "TypeCastExpression") {
                                return this.isAssignable(node.expression, isBinding);
                            } else {
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
                            }
                        }
                    },
                    {
                        key: "toAssignable",
                        value: function toAssignable(node) {
                            var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                            if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
                                node.left = this.typeCastToParameter(node.left);
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                        }
                    },
                    {
                        key: "toAssignableList",
                        value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
                            for(var i = 0; i < exprList.length; i++){
                                var expr = exprList[i];
                                if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
                                    exprList[i] = this.typeCastToParameter(expr);
                                }
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
                        }
                    },
                    {
                        key: "toReferencedList",
                        value: function toReferencedList(exprList, isParenthesizedExpr) {
                            for(var i = 0; i < exprList.length; i++){
                                var _expr$extra;
                                var expr = exprList[i];
                                if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
                                    this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
                                }
                            }
                            return exprList;
                        }
                    },
                    {
                        key: "parseArrayLike",
                        value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
                            var node = _get(_get_prototype_of(FlowParserMixin.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);
                            if (canBePattern && !this.state.maybeInArrowParameters) {
                                this.toReferencedList(node.elements);
                            }
                            return node;
                        }
                    },
                    {
                        key: "isValidLVal",
                        value: function isValidLVal(type, isParenthesized, binding) {
                            return type === "TypeCastExpression" || _get(_get_prototype_of(FlowParserMixin.prototype), "isValidLVal", this).call(this, type, isParenthesized, binding);
                        }
                    },
                    {
                        key: "parseClassProperty",
                        value: function parseClassProperty(node) {
                            if (this.match(14)) {
                                node.typeAnnotation = this.flowParseTypeAnnotation();
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassProperty", this).call(this, node);
                        }
                    },
                    {
                        key: "parseClassPrivateProperty",
                        value: function parseClassPrivateProperty(node) {
                            if (this.match(14)) {
                                node.typeAnnotation = this.flowParseTypeAnnotation();
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassPrivateProperty", this).call(this, node);
                        }
                    },
                    {
                        key: "isClassMethod",
                        value: function isClassMethod() {
                            return this.match(47) || _get(_get_prototype_of(FlowParserMixin.prototype), "isClassMethod", this).call(this);
                        }
                    },
                    {
                        key: "isClassProperty",
                        value: function isClassProperty() {
                            return this.match(14) || _get(_get_prototype_of(FlowParserMixin.prototype), "isClassProperty", this).call(this);
                        }
                    },
                    {
                        key: "isNonstaticConstructor",
                        value: function isNonstaticConstructor(method) {
                            return !this.match(14) && _get(_get_prototype_of(FlowParserMixin.prototype), "isNonstaticConstructor", this).call(this, method);
                        }
                    },
                    {
                        key: "pushClassMethod",
                        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                            if (method.variance) {
                                this.unexpected(method.variance.loc.start);
                            }
                            delete method.variance;
                            if (this.match(47)) {
                                method.typeParameters = this.flowParseTypeParameterDeclaration();
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
                            if (method.params && isConstructor) {
                                var params = method.params;
                                if (params.length > 0 && this.isThisParam(params[0])) {
                                    this.raise(FlowErrors.ThisParamBannedInConstructor, method);
                                }
                            } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
                                var _params2 = method.value.params;
                                if (_params2.length > 0 && this.isThisParam(_params2[0])) {
                                    this.raise(FlowErrors.ThisParamBannedInConstructor, method);
                                }
                            }
                        }
                    },
                    {
                        key: "pushClassPrivateMethod",
                        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
                            if (method.variance) {
                                this.unexpected(method.variance.loc.start);
                            }
                            delete method.variance;
                            if (this.match(47)) {
                                method.typeParameters = this.flowParseTypeParameterDeclaration();
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
                        }
                    },
                    {
                        key: "parseClassSuper",
                        value: function parseClassSuper(node) {
                            _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassSuper", this).call(this, node);
                            if (node.superClass && this.match(47)) {
                                node.superTypeParameters = this.flowParseTypeParameterInstantiation();
                            }
                            if (this.isContextual(113)) {
                                this.next();
                                var implemented = node.implements = [];
                                do {
                                    var _node5 = this.startNode();
                                    _node5.id = this.flowParseRestrictedIdentifier(true);
                                    if (this.match(47)) {
                                        _node5.typeParameters = this.flowParseTypeParameterInstantiation();
                                    } else {
                                        _node5.typeParameters = null;
                                    }
                                    implemented.push(this.finishNode(_node5, "ClassImplements"));
                                }while (this.eat(12));
                            }
                        }
                    },
                    {
                        key: "checkGetterSetterParams",
                        value: function checkGetterSetterParams(method) {
                            _get(_get_prototype_of(FlowParserMixin.prototype), "checkGetterSetterParams", this).call(this, method);
                            var params = this.getObjectOrClassMethodParams(method);
                            if (params.length > 0) {
                                var param = params[0];
                                if (this.isThisParam(param) && method.kind === "get") {
                                    this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
                                } else if (this.isThisParam(param)) {
                                    this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
                                }
                            }
                        }
                    },
                    {
                        key: "parsePropertyNamePrefixOperator",
                        value: function parsePropertyNamePrefixOperator(node) {
                            node.variance = this.flowParseVariance();
                        }
                    },
                    {
                        key: "parseObjPropValue",
                        value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
                            if (prop.variance) {
                                this.unexpected(prop.variance.loc.start);
                            }
                            delete prop.variance;
                            var typeParameters;
                            if (this.match(47) && !isAccessor) {
                                typeParameters = this.flowParseTypeParameterDeclaration();
                                if (!this.match(10)) this.unexpected();
                            }
                            var result = _get(_get_prototype_of(FlowParserMixin.prototype), "parseObjPropValue", this).call(this, prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
                            if (typeParameters) {
                                (result.value || result).typeParameters = typeParameters;
                            }
                            return result;
                        }
                    },
                    {
                        key: "parseFunctionParamType",
                        value: function parseFunctionParamType(param) {
                            if (this.eat(17)) {
                                if (param.type !== "Identifier") {
                                    this.raise(FlowErrors.PatternIsOptional, param);
                                }
                                if (this.isThisParam(param)) {
                                    this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
                                }
                                param.optional = true;
                            }
                            if (this.match(14)) {
                                param.typeAnnotation = this.flowParseTypeAnnotation();
                            } else if (this.isThisParam(param)) {
                                this.raise(FlowErrors.ThisParamAnnotationRequired, param);
                            }
                            if (this.match(29) && this.isThisParam(param)) {
                                this.raise(FlowErrors.ThisParamNoDefault, param);
                            }
                            this.resetEndLocation(param);
                            return param;
                        }
                    },
                    {
                        key: "parseMaybeDefault",
                        value: function parseMaybeDefault(startLoc, left) {
                            var node = _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeDefault", this).call(this, startLoc, left);
                            if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
                                this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
                            }
                            return node;
                        }
                    },
                    {
                        key: "checkImportReflection",
                        value: function checkImportReflection(node) {
                            _get(_get_prototype_of(FlowParserMixin.prototype), "checkImportReflection", this).call(this, node);
                            if (node.module && node.importKind !== "value") {
                                this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
                            }
                        }
                    },
                    {
                        key: "parseImportSpecifierLocal",
                        value: function parseImportSpecifierLocal(node, specifier, type) {
                            specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
                            node.specifiers.push(this.finishImportSpecifier(specifier, type));
                        }
                    },
                    {
                        key: "isPotentialImportPhase",
                        value: function isPotentialImportPhase(isExport) {
                            if (_get(_get_prototype_of(FlowParserMixin.prototype), "isPotentialImportPhase", this).call(this, isExport)) return true;
                            if (this.isContextual(130)) {
                                if (!isExport) return true;
                                var ch = this.lookaheadCharCode();
                                return ch === 123 || ch === 42;
                            }
                            return !isExport && this.isContextual(87);
                        }
                    },
                    {
                        key: "applyImportPhase",
                        value: function applyImportPhase(node, isExport, phase, loc) {
                            _get(_get_prototype_of(FlowParserMixin.prototype), "applyImportPhase", this).call(this, node, isExport, phase, loc);
                            if (isExport) {
                                if (!phase && this.match(65)) {
                                    return;
                                }
                                node.exportKind = phase === "type" ? phase : "value";
                            } else {
                                if (phase === "type" && this.match(55)) this.unexpected();
                                node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
                            }
                        }
                    },
                    {
                        key: "parseImportSpecifier",
                        value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
                            var firstIdent = specifier.imported;
                            var specifierTypeKind = null;
                            if (firstIdent.type === "Identifier") {
                                if (firstIdent.name === "type") {
                                    specifierTypeKind = "type";
                                } else if (firstIdent.name === "typeof") {
                                    specifierTypeKind = "typeof";
                                }
                            }
                            var isBinding = false;
                            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                                var as_ident = this.parseIdentifier(true);
                                if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                                    specifier.imported = as_ident;
                                    specifier.importKind = specifierTypeKind;
                                    specifier.local = cloneIdentifier(as_ident);
                                } else {
                                    specifier.imported = firstIdent;
                                    specifier.importKind = null;
                                    specifier.local = this.parseIdentifier();
                                }
                            } else {
                                if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                                    specifier.imported = this.parseIdentifier(true);
                                    specifier.importKind = specifierTypeKind;
                                } else {
                                    if (importedIsString) {
                                        throw this.raise(Errors.ImportBindingIsString, specifier, {
                                            importName: firstIdent.value
                                        });
                                    }
                                    specifier.imported = firstIdent;
                                    specifier.importKind = null;
                                }
                                if (this.eatContextual(93)) {
                                    specifier.local = this.parseIdentifier();
                                } else {
                                    isBinding = true;
                                    specifier.local = cloneIdentifier(specifier.imported);
                                }
                            }
                            var specifierIsTypeImport = hasTypeImportKind(specifier);
                            if (isInTypeOnlyImport && specifierIsTypeImport) {
                                this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
                            }
                            if (isInTypeOnlyImport || specifierIsTypeImport) {
                                this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
                            }
                            if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
                                this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
                            }
                            return this.finishImportSpecifier(specifier, "ImportSpecifier");
                        }
                    },
                    {
                        key: "parseBindingAtom",
                        value: function parseBindingAtom() {
                            switch(this.state.type){
                                case 78:
                                    return this.parseIdentifier(true);
                                default:
                                    return _get(_get_prototype_of(FlowParserMixin.prototype), "parseBindingAtom", this).call(this);
                            }
                        }
                    },
                    {
                        key: "parseFunctionParams",
                        value: function parseFunctionParams(node, isConstructor) {
                            var kind = node.kind;
                            if (kind !== "get" && kind !== "set" && this.match(47)) {
                                node.typeParameters = this.flowParseTypeParameterDeclaration();
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionParams", this).call(this, node, isConstructor);
                        }
                    },
                    {
                        key: "parseVarId",
                        value: function parseVarId(decl, kind) {
                            _get(_get_prototype_of(FlowParserMixin.prototype), "parseVarId", this).call(this, decl, kind);
                            if (this.match(14)) {
                                decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                                this.resetEndLocation(decl.id);
                            }
                        }
                    },
                    {
                        key: "parseAsyncArrowFromCallExpression",
                        value: function parseAsyncArrowFromCallExpression(node, call) {
                            if (this.match(14)) {
                                var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                                this.state.noAnonFunctionType = true;
                                node.returnType = this.flowParseTypeAnnotation();
                                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
                        }
                    },
                    {
                        key: "shouldParseAsyncArrow",
                        value: function shouldParseAsyncArrow() {
                            return this.match(14) || _get(_get_prototype_of(FlowParserMixin.prototype), "shouldParseAsyncArrow", this).call(this);
                        }
                    },
                    {
                        key: "parseMaybeAssign",
                        value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
                            var _this = this;
                            var _jsx104;
                            var state = null;
                            var jsx2;
                            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
                                state = this.state.clone();
                                jsx2 = this.tryParse(function() {
                                    return _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                }, state);
                                if (!jsx2.error) return jsx2.node;
                                var context = this.state.context;
                                var currentContext = context[context.length - 1];
                                if (currentContext === types.j_oTag || currentContext === types.j_expr) {
                                    context.pop();
                                }
                            }
                            if ((_jsx104 = jsx2) != null && _jsx104.error || this.match(47)) {
                                var _jsx210, _jsx310;
                                state = state || this.state.clone();
                                var typeParameters;
                                var arrow = this.tryParse(function(abort) {
                                    var _arrowExpression$extr;
                                    typeParameters = _this.flowParseTypeParameterDeclaration();
                                    var arrowExpression2 = _this.forwardNoArrowParamsConversionAt(typeParameters, function() {
                                        var result = _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                        _this.resetStartLocationFromNode(result, typeParameters);
                                        return result;
                                    });
                                    if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
                                    var expr = _this.maybeUnwrapTypeCastExpression(arrowExpression2);
                                    if (expr.type !== "ArrowFunctionExpression") abort();
                                    expr.typeParameters = typeParameters;
                                    _this.resetStartLocationFromNode(expr, typeParameters);
                                    return arrowExpression2;
                                }, state);
                                var arrowExpression = null;
                                if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                                    if (!arrow.error && !arrow.aborted) {
                                        if (arrow.node.async) {
                                            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
                                        }
                                        return arrow.node;
                                    }
                                    arrowExpression = arrow.node;
                                }
                                if ((_jsx210 = jsx2) != null && _jsx210.node) {
                                    this.state = jsx2.failState;
                                    return jsx2.node;
                                }
                                if (arrowExpression) {
                                    this.state = arrow.failState;
                                    return arrowExpression;
                                }
                                if ((_jsx310 = jsx2) != null && _jsx310.thrown) throw jsx2.error;
                                if (arrow.thrown) throw arrow.error;
                                throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
                        }
                    },
                    {
                        key: "parseArrow",
                        value: function parseArrow(node) {
                            var _this = this;
                            if (this.match(14)) {
                                var result = this.tryParse(function() {
                                    var oldNoAnonFunctionType = _this.state.noAnonFunctionType;
                                    _this.state.noAnonFunctionType = true;
                                    var typeNode = _this.startNode();
                                    var ref;
                                    ref = _sliced_to_array(_this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.typeAnnotation = ref[0], node.predicate = ref[1], ref;
                                    _this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                    if (_this.canInsertSemicolon()) _this.unexpected();
                                    if (!_this.match(19)) _this.unexpected();
                                    return typeNode;
                                });
                                if (result.thrown) return null;
                                if (result.error) this.state = result.failState;
                                node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseArrow", this).call(this, node);
                        }
                    },
                    {
                        key: "shouldParseArrow",
                        value: function shouldParseArrow(params) {
                            return this.match(14) || _get(_get_prototype_of(FlowParserMixin.prototype), "shouldParseArrow", this).call(this, params);
                        }
                    },
                    {
                        key: "setArrowFunctionParameters",
                        value: function setArrowFunctionParameters(node, params) {
                            if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
                                node.params = params;
                            } else {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "setArrowFunctionParameters", this).call(this, node, params);
                            }
                        }
                    },
                    {
                        key: "checkParams",
                        value: function checkParams(node, allowDuplicates, isArrowFunction) {
                            var strictModeChanged = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                            if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
                                return;
                            }
                            for(var i = 0; i < node.params.length; i++){
                                if (this.isThisParam(node.params[i]) && i > 0) {
                                    this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
                                }
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "checkParams", this).call(this, node, allowDuplicates, isArrowFunction, strictModeChanged);
                        }
                    },
                    {
                        key: "parseParenAndDistinguishExpression",
                        value: function parseParenAndDistinguishExpression(canBeArrow) {
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseParenAndDistinguishExpression", this).call(this, canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
                        }
                    },
                    {
                        key: "parseSubscripts",
                        value: function parseSubscripts(base, startLoc, noCalls) {
                            var _this = this;
                            if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
                                this.next();
                                var node = this.startNodeAt(startLoc);
                                node.callee = base;
                                node.arguments = _get(_get_prototype_of(FlowParserMixin.prototype), "parseCallExpressionArguments", this).call(this, 11);
                                base = this.finishNode(node, "CallExpression");
                            } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
                                var state = this.state.clone();
                                var arrow = this.tryParse(function(abort) {
                                    return _this.parseAsyncArrowWithTypeParameters(startLoc) || abort();
                                }, state);
                                if (!arrow.error && !arrow.aborted) return arrow.node;
                                var result = this.tryParse(function() {
                                    return _get(_get_prototype_of(FlowParserMixin.prototype), "parseSubscripts", _this).call(_this, base, startLoc, noCalls);
                                }, state);
                                if (result.node && !result.error) return result.node;
                                if (arrow.node) {
                                    this.state = arrow.failState;
                                    return arrow.node;
                                }
                                if (result.node) {
                                    this.state = result.failState;
                                    return result.node;
                                }
                                throw arrow.error || result.error;
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseSubscripts", this).call(this, base, startLoc, noCalls);
                        }
                    },
                    {
                        key: "parseSubscript",
                        value: function parseSubscript(base, startLoc, noCalls, subscriptState) {
                            var _this = this;
                            if (this.match(18) && this.isLookaheadToken_lt()) {
                                subscriptState.optionalChainMember = true;
                                if (noCalls) {
                                    subscriptState.stop = true;
                                    return base;
                                }
                                this.next();
                                var node = this.startNodeAt(startLoc);
                                node.callee = base;
                                node.typeArguments = this.flowParseTypeParameterInstantiation();
                                this.expect(10);
                                node.arguments = this.parseCallExpressionArguments(11);
                                node.optional = true;
                                return this.finishCallExpression(node, true);
                            } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
                                var _node6 = this.startNodeAt(startLoc);
                                _node6.callee = base;
                                var result = this.tryParse(function() {
                                    _node6.typeArguments = _this.flowParseTypeParameterInstantiationCallOrNew();
                                    _this.expect(10);
                                    _node6.arguments = _get(_get_prototype_of(FlowParserMixin.prototype), "parseCallExpressionArguments", _this).call(_this, 11);
                                    if (subscriptState.optionalChainMember) {
                                        _node6.optional = false;
                                    }
                                    return _this.finishCallExpression(_node6, subscriptState.optionalChainMember);
                                });
                                if (result.node) {
                                    if (result.error) this.state = result.failState;
                                    return result.node;
                                }
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, subscriptState);
                        }
                    },
                    {
                        key: "parseNewCallee",
                        value: function parseNewCallee(node) {
                            var _this = this;
                            _get(_get_prototype_of(FlowParserMixin.prototype), "parseNewCallee", this).call(this, node);
                            var targs = null;
                            if (this.shouldParseTypes() && this.match(47)) {
                                targs = this.tryParse(function() {
                                    return _this.flowParseTypeParameterInstantiationCallOrNew();
                                }).node;
                            }
                            node.typeArguments = targs;
                        }
                    },
                    {
                        key: "parseAsyncArrowWithTypeParameters",
                        value: function parseAsyncArrowWithTypeParameters(startLoc) {
                            var node = this.startNodeAt(startLoc);
                            this.parseFunctionParams(node, false);
                            if (!this.parseArrow(node)) return;
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "parseArrowExpression", this).call(this, node, void 0, true);
                        }
                    },
                    {
                        key: "readToken_mult_modulo",
                        value: function readToken_mult_modulo(code2) {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
                                this.state.hasFlowComment = false;
                                this.state.pos += 2;
                                this.nextToken();
                                return;
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "readToken_mult_modulo", this).call(this, code2);
                        }
                    },
                    {
                        key: "readToken_pipe_amp",
                        value: function readToken_pipe_amp(code2) {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (code2 === 124 && next === 125) {
                                this.finishOp(9, 2);
                                return;
                            }
                            _get(_get_prototype_of(FlowParserMixin.prototype), "readToken_pipe_amp", this).call(this, code2);
                        }
                    },
                    {
                        key: "parseTopLevel",
                        value: function parseTopLevel(file, program) {
                            var fileNode = _get(_get_prototype_of(FlowParserMixin.prototype), "parseTopLevel", this).call(this, file, program);
                            if (this.state.hasFlowComment) {
                                this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
                            }
                            return fileNode;
                        }
                    },
                    {
                        key: "skipBlockComment",
                        value: function skipBlockComment() {
                            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                                if (this.state.hasFlowComment) {
                                    throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
                                }
                                this.hasFlowCommentCompletion();
                                var commentSkip = this.skipFlowComment();
                                if (commentSkip) {
                                    this.state.pos += commentSkip;
                                    this.state.hasFlowComment = true;
                                }
                                return;
                            }
                            return _get(_get_prototype_of(FlowParserMixin.prototype), "skipBlockComment", this).call(this, this.state.hasFlowComment ? "*-/" : "*/");
                        }
                    },
                    {
                        key: "skipFlowComment",
                        value: function skipFlowComment() {
                            var pos = this.state.pos;
                            var shiftToFirstNonWhiteSpace = 2;
                            while([
                                32,
                                9
                            ].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))){
                                shiftToFirstNonWhiteSpace++;
                            }
                            var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
                            var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
                            if (ch2 === 58 && ch3 === 58) {
                                return shiftToFirstNonWhiteSpace + 2;
                            }
                            if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
                                return shiftToFirstNonWhiteSpace + 12;
                            }
                            if (ch2 === 58 && ch3 !== 58) {
                                return shiftToFirstNonWhiteSpace;
                            }
                            return false;
                        }
                    },
                    {
                        key: "hasFlowCommentCompletion",
                        value: function hasFlowCommentCompletion() {
                            var end = this.input.indexOf("*/", this.state.pos);
                            if (end === -1) {
                                throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
                            }
                        }
                    },
                    {
                        key: "flowEnumErrorBooleanMemberNotInitialized",
                        value: function flowEnumErrorBooleanMemberNotInitialized(loc, _ref56) {
                            var enumName = _ref56.enumName, memberName = _ref56.memberName;
                            this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
                                memberName: memberName,
                                enumName: enumName
                            });
                        }
                    },
                    {
                        key: "flowEnumErrorInvalidMemberInitializer",
                        value: function flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
                            return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
                        }
                    },
                    {
                        key: "flowEnumErrorNumberMemberNotInitialized",
                        value: function flowEnumErrorNumberMemberNotInitialized(loc, details) {
                            this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
                        }
                    },
                    {
                        key: "flowEnumErrorStringMemberInconsistentlyInitialized",
                        value: function flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
                            this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
                        }
                    },
                    {
                        key: "flowEnumMemberInit",
                        value: function flowEnumMemberInit() {
                            var _this = this;
                            var startLoc = this.state.startLoc;
                            var endOfInit = function() {
                                return _this.match(12) || _this.match(8);
                            };
                            switch(this.state.type){
                                case 135:
                                    {
                                        var literal = this.parseNumericLiteral(this.state.value);
                                        if (endOfInit()) {
                                            return {
                                                type: "number",
                                                loc: literal.loc.start,
                                                value: literal
                                            };
                                        }
                                        return {
                                            type: "invalid",
                                            loc: startLoc
                                        };
                                    }
                                case 134:
                                    {
                                        var _literal = this.parseStringLiteral(this.state.value);
                                        if (endOfInit()) {
                                            return {
                                                type: "string",
                                                loc: _literal.loc.start,
                                                value: _literal
                                            };
                                        }
                                        return {
                                            type: "invalid",
                                            loc: startLoc
                                        };
                                    }
                                case 85:
                                case 86:
                                    {
                                        var _literal2 = this.parseBooleanLiteral(this.match(85));
                                        if (endOfInit()) {
                                            return {
                                                type: "boolean",
                                                loc: _literal2.loc.start,
                                                value: _literal2
                                            };
                                        }
                                        return {
                                            type: "invalid",
                                            loc: startLoc
                                        };
                                    }
                                default:
                                    return {
                                        type: "invalid",
                                        loc: startLoc
                                    };
                            }
                        }
                    },
                    {
                        key: "flowEnumMemberRaw",
                        value: function flowEnumMemberRaw() {
                            var loc = this.state.startLoc;
                            var id = this.parseIdentifier(true);
                            var init = this.eat(29) ? this.flowEnumMemberInit() : {
                                type: "none",
                                loc: loc
                            };
                            return {
                                id: id,
                                init: init
                            };
                        }
                    },
                    {
                        key: "flowEnumCheckExplicitTypeMismatch",
                        value: function flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
                            var explicitType = context.explicitType;
                            if (explicitType === null) {
                                return;
                            }
                            if (explicitType !== expectedType) {
                                this.flowEnumErrorInvalidMemberInitializer(loc, context);
                            }
                        }
                    },
                    {
                        key: "flowEnumMembers",
                        value: function flowEnumMembers(_ref57) {
                            var enumName = _ref57.enumName, explicitType = _ref57.explicitType;
                            var seenNames = /* @__PURE__ */ new Set();
                            var members = {
                                booleanMembers: [],
                                numberMembers: [],
                                stringMembers: [],
                                defaultedMembers: []
                            };
                            var hasUnknownMembers = false;
                            while(!this.match(8)){
                                if (this.eat(21)) {
                                    hasUnknownMembers = true;
                                    break;
                                }
                                var memberNode = this.startNode();
                                var _this_flowEnumMemberRaw = this.flowEnumMemberRaw(), id = _this_flowEnumMemberRaw.id, init = _this_flowEnumMemberRaw.init;
                                var memberName = id.name;
                                if (memberName === "") {
                                    continue;
                                }
                                if (/^[a-z]/.test(memberName)) {
                                    this.raise(FlowErrors.EnumInvalidMemberName, id, {
                                        memberName: memberName,
                                        suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                                        enumName: enumName
                                    });
                                }
                                if (seenNames.has(memberName)) {
                                    this.raise(FlowErrors.EnumDuplicateMemberName, id, {
                                        memberName: memberName,
                                        enumName: enumName
                                    });
                                }
                                seenNames.add(memberName);
                                var context = {
                                    enumName: enumName,
                                    explicitType: explicitType,
                                    memberName: memberName
                                };
                                memberNode.id = id;
                                switch(init.type){
                                    case "boolean":
                                        {
                                            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                                            memberNode.init = init.value;
                                            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                                            break;
                                        }
                                    case "number":
                                        {
                                            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                                            memberNode.init = init.value;
                                            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                                            break;
                                        }
                                    case "string":
                                        {
                                            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                                            memberNode.init = init.value;
                                            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                                            break;
                                        }
                                    case "invalid":
                                        {
                                            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
                                        }
                                    case "none":
                                        {
                                            switch(explicitType){
                                                case "boolean":
                                                    this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                                                    break;
                                                case "number":
                                                    this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                                                    break;
                                                default:
                                                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                                            }
                                        }
                                }
                                if (!this.match(8)) {
                                    this.expect(12);
                                }
                            }
                            return {
                                members: members,
                                hasUnknownMembers: hasUnknownMembers
                            };
                        }
                    },
                    {
                        key: "flowEnumStringMembers",
                        value: function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref58) {
                            var enumName = _ref58.enumName;
                            if (initializedMembers.length === 0) {
                                return defaultedMembers;
                            } else if (defaultedMembers.length === 0) {
                                return initializedMembers;
                            } else if (defaultedMembers.length > initializedMembers.length) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = initializedMembers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var member = _step.value;
                                        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
                                            enumName: enumName
                                        });
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                return defaultedMembers;
                            } else {
                                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                try {
                                    for(var _iterator1 = defaultedMembers[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                        var _member = _step1.value;
                                        this.flowEnumErrorStringMemberInconsistentlyInitialized(_member, {
                                            enumName: enumName
                                        });
                                    }
                                } catch (err) {
                                    _didIteratorError1 = true;
                                    _iteratorError1 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                            _iterator1.return();
                                        }
                                    } finally{
                                        if (_didIteratorError1) {
                                            throw _iteratorError1;
                                        }
                                    }
                                }
                                return initializedMembers;
                            }
                        }
                    },
                    {
                        key: "flowEnumParseExplicitType",
                        value: function flowEnumParseExplicitType(_ref59) {
                            var enumName = _ref59.enumName;
                            if (!this.eatContextual(102)) return null;
                            if (!tokenIsIdentifier(this.state.type)) {
                                throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
                                    enumName: enumName
                                });
                            }
                            var value = this.state.value;
                            this.next();
                            if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
                                this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
                                    enumName: enumName,
                                    invalidEnumType: value
                                });
                            }
                            return value;
                        }
                    },
                    {
                        key: "flowEnumBody",
                        value: function flowEnumBody(node, id) {
                            var _this = this;
                            var enumName = id.name;
                            var nameLoc = id.loc.start;
                            var explicitType = this.flowEnumParseExplicitType({
                                enumName: enumName
                            });
                            this.expect(5);
                            var _this_flowEnumMembers = this.flowEnumMembers({
                                enumName: enumName,
                                explicitType: explicitType
                            }), members = _this_flowEnumMembers.members, hasUnknownMembers = _this_flowEnumMembers.hasUnknownMembers;
                            node.hasUnknownMembers = hasUnknownMembers;
                            switch(explicitType){
                                case "boolean":
                                    node.explicitType = true;
                                    node.members = members.booleanMembers;
                                    this.expect(8);
                                    return this.finishNode(node, "EnumBooleanBody");
                                case "number":
                                    node.explicitType = true;
                                    node.members = members.numberMembers;
                                    this.expect(8);
                                    return this.finishNode(node, "EnumNumberBody");
                                case "string":
                                    node.explicitType = true;
                                    node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                                        enumName: enumName
                                    });
                                    this.expect(8);
                                    return this.finishNode(node, "EnumStringBody");
                                case "symbol":
                                    node.members = members.defaultedMembers;
                                    this.expect(8);
                                    return this.finishNode(node, "EnumSymbolBody");
                                default:
                                    {
                                        var empty = function() {
                                            node.members = [];
                                            _this.expect(8);
                                            return _this.finishNode(node, "EnumStringBody");
                                        };
                                        node.explicitType = false;
                                        var boolsLen = members.booleanMembers.length;
                                        var numsLen = members.numberMembers.length;
                                        var strsLen = members.stringMembers.length;
                                        var defaultedLen = members.defaultedMembers.length;
                                        if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                                            return empty();
                                        } else if (!boolsLen && !numsLen) {
                                            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                                                enumName: enumName
                                            });
                                            this.expect(8);
                                            return this.finishNode(node, "EnumStringBody");
                                        } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                            try {
                                                for(var _iterator = members.defaultedMembers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                                    var member = _step.value;
                                                    this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                                                        enumName: enumName,
                                                        memberName: member.id.name
                                                    });
                                                }
                                            } catch (err) {
                                                _didIteratorError = true;
                                                _iteratorError = err;
                                            } finally{
                                                try {
                                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                        _iterator.return();
                                                    }
                                                } finally{
                                                    if (_didIteratorError) {
                                                        throw _iteratorError;
                                                    }
                                                }
                                            }
                                            node.members = members.booleanMembers;
                                            this.expect(8);
                                            return this.finishNode(node, "EnumBooleanBody");
                                        } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                            try {
                                                for(var _iterator1 = members.defaultedMembers[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                                    var _member2 = _step1.value;
                                                    this.flowEnumErrorNumberMemberNotInitialized(_member2.loc.start, {
                                                        enumName: enumName,
                                                        memberName: _member2.id.name
                                                    });
                                                }
                                            } catch (err) {
                                                _didIteratorError1 = true;
                                                _iteratorError1 = err;
                                            } finally{
                                                try {
                                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                                        _iterator1.return();
                                                    }
                                                } finally{
                                                    if (_didIteratorError1) {
                                                        throw _iteratorError1;
                                                    }
                                                }
                                            }
                                            node.members = members.numberMembers;
                                            this.expect(8);
                                            return this.finishNode(node, "EnumNumberBody");
                                        } else {
                                            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                                                enumName: enumName
                                            });
                                            return empty();
                                        }
                                    }
                            }
                        }
                    },
                    {
                        key: "flowParseEnumDeclaration",
                        value: function flowParseEnumDeclaration(node) {
                            var id = this.parseIdentifier();
                            node.id = id;
                            node.body = this.flowEnumBody(this.startNode(), id);
                            return this.finishNode(node, "EnumDeclaration");
                        }
                    },
                    {
                        key: "isLookaheadToken_lt",
                        value: function isLookaheadToken_lt() {
                            var next = this.nextTokenStart();
                            if (this.input.charCodeAt(next) === 60) {
                                var afterNext = this.input.charCodeAt(next + 1);
                                return afterNext !== 60 && afterNext !== 61;
                            }
                            return false;
                        }
                    },
                    {
                        key: "maybeUnwrapTypeCastExpression",
                        value: function maybeUnwrapTypeCastExpression(node) {
                            return node.type === "TypeCastExpression" ? node.expression : node;
                        }
                    }
                ]);
                return FlowParserMixin;
            }(superClass);
            return FlowParserMixin;
        };
        var entities = {
            __proto__: null,
            quot: '"',
            amp: "&",
            apos: "'",
            lt: "<",
            gt: ">",
            nbsp: "\xA0",
            iexcl: "\xA1",
            cent: "\xA2",
            pound: "\xA3",
            curren: "\xA4",
            yen: "\xA5",
            brvbar: "\xA6",
            sect: "\xA7",
            uml: "\xA8",
            copy: "\xA9",
            ordf: "\xAA",
            laquo: "\xAB",
            not: "\xAC",
            shy: "\xAD",
            reg: "\xAE",
            macr: "\xAF",
            deg: "\xB0",
            plusmn: "\xB1",
            sup2: "\xB2",
            sup3: "\xB3",
            acute: "\xB4",
            micro: "\xB5",
            para: "\xB6",
            middot: "\xB7",
            cedil: "\xB8",
            sup1: "\xB9",
            ordm: "\xBA",
            raquo: "\xBB",
            frac14: "\xBC",
            frac12: "\xBD",
            frac34: "\xBE",
            iquest: "\xBF",
            Agrave: "\xC0",
            Aacute: "\xC1",
            Acirc: "\xC2",
            Atilde: "\xC3",
            Auml: "\xC4",
            Aring: "\xC5",
            AElig: "\xC6",
            Ccedil: "\xC7",
            Egrave: "\xC8",
            Eacute: "\xC9",
            Ecirc: "\xCA",
            Euml: "\xCB",
            Igrave: "\xCC",
            Iacute: "\xCD",
            Icirc: "\xCE",
            Iuml: "\xCF",
            ETH: "\xD0",
            Ntilde: "\xD1",
            Ograve: "\xD2",
            Oacute: "\xD3",
            Ocirc: "\xD4",
            Otilde: "\xD5",
            Ouml: "\xD6",
            times: "\xD7",
            Oslash: "\xD8",
            Ugrave: "\xD9",
            Uacute: "\xDA",
            Ucirc: "\xDB",
            Uuml: "\xDC",
            Yacute: "\xDD",
            THORN: "\xDE",
            szlig: "\xDF",
            agrave: "\xE0",
            aacute: "\xE1",
            acirc: "\xE2",
            atilde: "\xE3",
            auml: "\xE4",
            aring: "\xE5",
            aelig: "\xE6",
            ccedil: "\xE7",
            egrave: "\xE8",
            eacute: "\xE9",
            ecirc: "\xEA",
            euml: "\xEB",
            igrave: "\xEC",
            iacute: "\xED",
            icirc: "\xEE",
            iuml: "\xEF",
            eth: "\xF0",
            ntilde: "\xF1",
            ograve: "\xF2",
            oacute: "\xF3",
            ocirc: "\xF4",
            otilde: "\xF5",
            ouml: "\xF6",
            divide: "\xF7",
            oslash: "\xF8",
            ugrave: "\xF9",
            uacute: "\xFA",
            ucirc: "\xFB",
            uuml: "\xFC",
            yacute: "\xFD",
            thorn: "\xFE",
            yuml: "\xFF",
            OElig: "\u0152",
            oelig: "\u0153",
            Scaron: "\u0160",
            scaron: "\u0161",
            Yuml: "\u0178",
            fnof: "\u0192",
            circ: "\u02C6",
            tilde: "\u02DC",
            Alpha: "\u0391",
            Beta: "\u0392",
            Gamma: "\u0393",
            Delta: "\u0394",
            Epsilon: "\u0395",
            Zeta: "\u0396",
            Eta: "\u0397",
            Theta: "\u0398",
            Iota: "\u0399",
            Kappa: "\u039A",
            Lambda: "\u039B",
            Mu: "\u039C",
            Nu: "\u039D",
            Xi: "\u039E",
            Omicron: "\u039F",
            Pi: "\u03A0",
            Rho: "\u03A1",
            Sigma: "\u03A3",
            Tau: "\u03A4",
            Upsilon: "\u03A5",
            Phi: "\u03A6",
            Chi: "\u03A7",
            Psi: "\u03A8",
            Omega: "\u03A9",
            alpha: "\u03B1",
            beta: "\u03B2",
            gamma: "\u03B3",
            delta: "\u03B4",
            epsilon: "\u03B5",
            zeta: "\u03B6",
            eta: "\u03B7",
            theta: "\u03B8",
            iota: "\u03B9",
            kappa: "\u03BA",
            lambda: "\u03BB",
            mu: "\u03BC",
            nu: "\u03BD",
            xi: "\u03BE",
            omicron: "\u03BF",
            pi: "\u03C0",
            rho: "\u03C1",
            sigmaf: "\u03C2",
            sigma: "\u03C3",
            tau: "\u03C4",
            upsilon: "\u03C5",
            phi: "\u03C6",
            chi: "\u03C7",
            psi: "\u03C8",
            omega: "\u03C9",
            thetasym: "\u03D1",
            upsih: "\u03D2",
            piv: "\u03D6",
            ensp: "\u2002",
            emsp: "\u2003",
            thinsp: "\u2009",
            zwnj: "\u200C",
            zwj: "\u200D",
            lrm: "\u200E",
            rlm: "\u200F",
            ndash: "\u2013",
            mdash: "\u2014",
            lsquo: "\u2018",
            rsquo: "\u2019",
            sbquo: "\u201A",
            ldquo: "\u201C",
            rdquo: "\u201D",
            bdquo: "\u201E",
            dagger: "\u2020",
            Dagger: "\u2021",
            bull: "\u2022",
            hellip: "\u2026",
            permil: "\u2030",
            prime: "\u2032",
            Prime: "\u2033",
            lsaquo: "\u2039",
            rsaquo: "\u203A",
            oline: "\u203E",
            frasl: "\u2044",
            euro: "\u20AC",
            image: "\u2111",
            weierp: "\u2118",
            real: "\u211C",
            trade: "\u2122",
            alefsym: "\u2135",
            larr: "\u2190",
            uarr: "\u2191",
            rarr: "\u2192",
            darr: "\u2193",
            harr: "\u2194",
            crarr: "\u21B5",
            lArr: "\u21D0",
            uArr: "\u21D1",
            rArr: "\u21D2",
            dArr: "\u21D3",
            hArr: "\u21D4",
            forall: "\u2200",
            part: "\u2202",
            exist: "\u2203",
            empty: "\u2205",
            nabla: "\u2207",
            isin: "\u2208",
            notin: "\u2209",
            ni: "\u220B",
            prod: "\u220F",
            sum: "\u2211",
            minus: "\u2212",
            lowast: "\u2217",
            radic: "\u221A",
            prop: "\u221D",
            infin: "\u221E",
            ang: "\u2220",
            and: "\u2227",
            or: "\u2228",
            cap: "\u2229",
            cup: "\u222A",
            int: "\u222B",
            there4: "\u2234",
            sim: "\u223C",
            cong: "\u2245",
            asymp: "\u2248",
            ne: "\u2260",
            equiv: "\u2261",
            le: "\u2264",
            ge: "\u2265",
            sub: "\u2282",
            sup: "\u2283",
            nsub: "\u2284",
            sube: "\u2286",
            supe: "\u2287",
            oplus: "\u2295",
            otimes: "\u2297",
            perp: "\u22A5",
            sdot: "\u22C5",
            lceil: "\u2308",
            rceil: "\u2309",
            lfloor: "\u230A",
            rfloor: "\u230B",
            lang: "\u2329",
            rang: "\u232A",
            loz: "\u25CA",
            spades: "\u2660",
            clubs: "\u2663",
            hearts: "\u2665",
            diams: "\u2666"
        };
        var JsxErrors = ParseErrorEnum(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([
            "jsx"
        ])))({
            AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
            MissingClosingTagElement: function(_ref60) {
                var openingTagName = _ref60.openingTagName;
                return "Expected corresponding JSX closing tag for <".concat(openingTagName, ">.");
            },
            MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
            UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
            UnexpectedToken: function(_ref61) {
                var unexpected = _ref61.unexpected, HTMLEntity = _ref61.HTMLEntity;
                return "Unexpected token `".concat(unexpected, "`. Did you mean `").concat(HTMLEntity, "` or `{'").concat(unexpected, "'}`?");
            },
            UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
            UnterminatedJsxContent: "Unterminated JSX contents.",
            UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
        });
        function isFragment(object) {
            return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
        }
        function getQualifiedJSXName(object) {
            if (object.type === "JSXIdentifier") {
                return object.name;
            }
            if (object.type === "JSXNamespacedName") {
                return object.namespace.name + ":" + object.name.name;
            }
            if (object.type === "JSXMemberExpression") {
                return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
            }
            throw new Error("Node had unexpected type: " + object.type);
        }
        var jsx = function(superClass) {
            var JSXParserMixin = /*#__PURE__*/ function(superClass) {
                _inherits(JSXParserMixin, superClass);
                function JSXParserMixin() {
                    _class_call_check(this, JSXParserMixin);
                    return _call_super(this, JSXParserMixin, arguments);
                }
                _create_class(JSXParserMixin, [
                    {
                        key: "jsxReadToken",
                        value: function jsxReadToken() {
                            var out = "";
                            var chunkStart = this.state.pos;
                            for(;;){
                                if (this.state.pos >= this.length) {
                                    throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
                                }
                                var ch = this.input.charCodeAt(this.state.pos);
                                switch(ch){
                                    case 60:
                                    case 123:
                                        if (this.state.pos === this.state.start) {
                                            if (ch === 60 && this.state.canStartJSXElement) {
                                                ++this.state.pos;
                                                this.finishToken(143);
                                            } else {
                                                _get(_get_prototype_of(JSXParserMixin.prototype), "getTokenFromCode", this).call(this, ch);
                                            }
                                            return;
                                        }
                                        out += this.input.slice(chunkStart, this.state.pos);
                                        this.finishToken(142, out);
                                        return;
                                    case 38:
                                        out += this.input.slice(chunkStart, this.state.pos);
                                        out += this.jsxReadEntity();
                                        chunkStart = this.state.pos;
                                        break;
                                    case 62:
                                    case 125:
                                    default:
                                        if (isNewLine(ch)) {
                                            out += this.input.slice(chunkStart, this.state.pos);
                                            out += this.jsxReadNewLine(true);
                                            chunkStart = this.state.pos;
                                        } else {
                                            ++this.state.pos;
                                        }
                                }
                            }
                        }
                    },
                    {
                        key: "jsxReadNewLine",
                        value: function jsxReadNewLine(normalizeCRLF) {
                            var ch = this.input.charCodeAt(this.state.pos);
                            var out;
                            ++this.state.pos;
                            if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                                ++this.state.pos;
                                out = normalizeCRLF ? "\n" : "\r\n";
                            } else {
                                out = String.fromCharCode(ch);
                            }
                            ++this.state.curLine;
                            this.state.lineStart = this.state.pos;
                            return out;
                        }
                    },
                    {
                        key: "jsxReadString",
                        value: function jsxReadString(quote) {
                            var out = "";
                            var chunkStart = ++this.state.pos;
                            for(;;){
                                if (this.state.pos >= this.length) {
                                    throw this.raise(Errors.UnterminatedString, this.state.startLoc);
                                }
                                var ch = this.input.charCodeAt(this.state.pos);
                                if (ch === quote) break;
                                if (ch === 38) {
                                    out += this.input.slice(chunkStart, this.state.pos);
                                    out += this.jsxReadEntity();
                                    chunkStart = this.state.pos;
                                } else if (isNewLine(ch)) {
                                    out += this.input.slice(chunkStart, this.state.pos);
                                    out += this.jsxReadNewLine(false);
                                    chunkStart = this.state.pos;
                                } else {
                                    ++this.state.pos;
                                }
                            }
                            out += this.input.slice(chunkStart, this.state.pos++);
                            this.finishToken(134, out);
                        }
                    },
                    {
                        key: "jsxReadEntity",
                        value: function jsxReadEntity() {
                            var startPos = ++this.state.pos;
                            if (this.codePointAtPos(this.state.pos) === 35) {
                                ++this.state.pos;
                                var radix = 10;
                                if (this.codePointAtPos(this.state.pos) === 120) {
                                    radix = 16;
                                    ++this.state.pos;
                                }
                                var codePoint = this.readInt(radix, void 0, false, "bail");
                                if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
                                    ++this.state.pos;
                                    return String.fromCodePoint(codePoint);
                                }
                            } else {
                                var count = 0;
                                var semi = false;
                                while(count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)){
                                    ++this.state.pos;
                                }
                                if (semi) {
                                    var desc = this.input.slice(startPos, this.state.pos);
                                    var entity = entities[desc];
                                    ++this.state.pos;
                                    if (entity) {
                                        return entity;
                                    }
                                }
                            }
                            this.state.pos = startPos;
                            return "&";
                        }
                    },
                    {
                        key: "jsxReadWord",
                        value: function jsxReadWord() {
                            var ch;
                            var start = this.state.pos;
                            do {
                                ch = this.input.charCodeAt(++this.state.pos);
                            }while (isIdentifierChar(ch) || ch === 45);
                            this.finishToken(141, this.input.slice(start, this.state.pos));
                        }
                    },
                    {
                        key: "jsxParseIdentifier",
                        value: function jsxParseIdentifier() {
                            var node = this.startNode();
                            if (this.match(141)) {
                                node.name = this.state.value;
                            } else if (tokenIsKeyword(this.state.type)) {
                                node.name = tokenLabelName(this.state.type);
                            } else {
                                this.unexpected();
                            }
                            this.next();
                            return this.finishNode(node, "JSXIdentifier");
                        }
                    },
                    {
                        key: "jsxParseNamespacedName",
                        value: function jsxParseNamespacedName() {
                            var startLoc = this.state.startLoc;
                            var name = this.jsxParseIdentifier();
                            if (!this.eat(14)) return name;
                            var node = this.startNodeAt(startLoc);
                            node.namespace = name;
                            node.name = this.jsxParseIdentifier();
                            return this.finishNode(node, "JSXNamespacedName");
                        }
                    },
                    {
                        key: "jsxParseElementName",
                        value: function jsxParseElementName() {
                            var startLoc = this.state.startLoc;
                            var node = this.jsxParseNamespacedName();
                            if (node.type === "JSXNamespacedName") {
                                return node;
                            }
                            while(this.eat(16)){
                                var newNode = this.startNodeAt(startLoc);
                                newNode.object = node;
                                newNode.property = this.jsxParseIdentifier();
                                node = this.finishNode(newNode, "JSXMemberExpression");
                            }
                            return node;
                        }
                    },
                    {
                        key: "jsxParseAttributeValue",
                        value: function jsxParseAttributeValue() {
                            var node;
                            switch(this.state.type){
                                case 5:
                                    node = this.startNode();
                                    this.setContext(types.brace);
                                    this.next();
                                    node = this.jsxParseExpressionContainer(node, types.j_oTag);
                                    if (node.expression.type === "JSXEmptyExpression") {
                                        this.raise(JsxErrors.AttributeIsEmpty, node);
                                    }
                                    return node;
                                case 143:
                                case 134:
                                    return this.parseExprAtom();
                                default:
                                    throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
                            }
                        }
                    },
                    {
                        key: "jsxParseEmptyExpression",
                        value: function jsxParseEmptyExpression() {
                            var node = this.startNodeAt(this.state.lastTokEndLoc);
                            return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
                        }
                    },
                    {
                        key: "jsxParseSpreadChild",
                        value: function jsxParseSpreadChild(node) {
                            this.next();
                            node.expression = this.parseExpression();
                            this.setContext(types.j_expr);
                            this.state.canStartJSXElement = true;
                            this.expect(8);
                            return this.finishNode(node, "JSXSpreadChild");
                        }
                    },
                    {
                        key: "jsxParseExpressionContainer",
                        value: function jsxParseExpressionContainer(node, previousContext) {
                            if (this.match(8)) {
                                node.expression = this.jsxParseEmptyExpression();
                            } else {
                                var expression = this.parseExpression();
                                node.expression = expression;
                            }
                            this.setContext(previousContext);
                            this.state.canStartJSXElement = true;
                            this.expect(8);
                            return this.finishNode(node, "JSXExpressionContainer");
                        }
                    },
                    {
                        key: "jsxParseAttribute",
                        value: function jsxParseAttribute() {
                            var node = this.startNode();
                            if (this.match(5)) {
                                this.setContext(types.brace);
                                this.next();
                                this.expect(21);
                                node.argument = this.parseMaybeAssignAllowIn();
                                this.setContext(types.j_oTag);
                                this.state.canStartJSXElement = true;
                                this.expect(8);
                                return this.finishNode(node, "JSXSpreadAttribute");
                            }
                            node.name = this.jsxParseNamespacedName();
                            node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
                            return this.finishNode(node, "JSXAttribute");
                        }
                    },
                    {
                        key: "jsxParseOpeningElementAt",
                        value: function jsxParseOpeningElementAt(startLoc) {
                            var node = this.startNodeAt(startLoc);
                            if (this.eat(144)) {
                                return this.finishNode(node, "JSXOpeningFragment");
                            }
                            node.name = this.jsxParseElementName();
                            return this.jsxParseOpeningElementAfterName(node);
                        }
                    },
                    {
                        key: "jsxParseOpeningElementAfterName",
                        value: function jsxParseOpeningElementAfterName(node) {
                            var attributes = [];
                            while(!this.match(56) && !this.match(144)){
                                attributes.push(this.jsxParseAttribute());
                            }
                            node.attributes = attributes;
                            node.selfClosing = this.eat(56);
                            this.expect(144);
                            return this.finishNode(node, "JSXOpeningElement");
                        }
                    },
                    {
                        key: "jsxParseClosingElementAt",
                        value: function jsxParseClosingElementAt(startLoc) {
                            var node = this.startNodeAt(startLoc);
                            if (this.eat(144)) {
                                return this.finishNode(node, "JSXClosingFragment");
                            }
                            node.name = this.jsxParseElementName();
                            this.expect(144);
                            return this.finishNode(node, "JSXClosingElement");
                        }
                    },
                    {
                        key: "jsxParseElementAt",
                        value: function jsxParseElementAt(startLoc) {
                            var node = this.startNodeAt(startLoc);
                            var children = [];
                            var openingElement = this.jsxParseOpeningElementAt(startLoc);
                            var closingElement = null;
                            if (!openingElement.selfClosing) {
                                contents: for(;;){
                                    switch(this.state.type){
                                        case 143:
                                            startLoc = this.state.startLoc;
                                            this.next();
                                            if (this.eat(56)) {
                                                closingElement = this.jsxParseClosingElementAt(startLoc);
                                                break contents;
                                            }
                                            children.push(this.jsxParseElementAt(startLoc));
                                            break;
                                        case 142:
                                            children.push(this.parseLiteral(this.state.value, "JSXText"));
                                            break;
                                        case 5:
                                            {
                                                var _node7 = this.startNode();
                                                this.setContext(types.brace);
                                                this.next();
                                                if (this.match(21)) {
                                                    children.push(this.jsxParseSpreadChild(_node7));
                                                } else {
                                                    children.push(this.jsxParseExpressionContainer(_node7, types.j_expr));
                                                }
                                                break;
                                            }
                                        default:
                                            this.unexpected();
                                    }
                                }
                                if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
                                    this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
                                } else if (!isFragment(openingElement) && isFragment(closingElement)) {
                                    this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                                        openingTagName: getQualifiedJSXName(openingElement.name)
                                    });
                                } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                                    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                                        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                                            openingTagName: getQualifiedJSXName(openingElement.name)
                                        });
                                    }
                                }
                            }
                            if (isFragment(openingElement)) {
                                node.openingFragment = openingElement;
                                node.closingFragment = closingElement;
                            } else {
                                node.openingElement = openingElement;
                                node.closingElement = closingElement;
                            }
                            node.children = children;
                            if (this.match(47)) {
                                throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
                            }
                            return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
                        }
                    },
                    {
                        key: "jsxParseElement",
                        value: function jsxParseElement() {
                            var startLoc = this.state.startLoc;
                            this.next();
                            return this.jsxParseElementAt(startLoc);
                        }
                    },
                    {
                        key: "setContext",
                        value: function setContext(newContext) {
                            var context = this.state.context;
                            context[context.length - 1] = newContext;
                        }
                    },
                    {
                        key: "parseExprAtom",
                        value: function parseExprAtom(refExpressionErrors) {
                            if (this.match(143)) {
                                return this.jsxParseElement();
                            } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
                                this.replaceToken(143);
                                return this.jsxParseElement();
                            } else {
                                return _get(_get_prototype_of(JSXParserMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
                            }
                        }
                    },
                    {
                        key: "skipSpace",
                        value: function skipSpace() {
                            var curContext = this.curContext();
                            if (!curContext.preserveSpace) _get(_get_prototype_of(JSXParserMixin.prototype), "skipSpace", this).call(this);
                        }
                    },
                    {
                        key: "getTokenFromCode",
                        value: function getTokenFromCode(code2) {
                            var context = this.curContext();
                            if (context === types.j_expr) {
                                this.jsxReadToken();
                                return;
                            }
                            if (context === types.j_oTag || context === types.j_cTag) {
                                if (isIdentifierStart(code2)) {
                                    this.jsxReadWord();
                                    return;
                                }
                                if (code2 === 62) {
                                    ++this.state.pos;
                                    this.finishToken(144);
                                    return;
                                }
                                if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
                                    this.jsxReadString(code2);
                                    return;
                                }
                            }
                            if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                                ++this.state.pos;
                                this.finishToken(143);
                                return;
                            }
                            _get(_get_prototype_of(JSXParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                        }
                    },
                    {
                        key: "updateContext",
                        value: function updateContext(prevType) {
                            var _this_state = this.state, context = _this_state.context, type = _this_state.type;
                            if (type === 56 && prevType === 143) {
                                context.splice(-2, 2, types.j_cTag);
                                this.state.canStartJSXElement = false;
                            } else if (type === 143) {
                                context.push(types.j_oTag);
                            } else if (type === 144) {
                                var out = context[context.length - 1];
                                if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
                                    context.pop();
                                    this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
                                } else {
                                    this.setContext(types.j_expr);
                                    this.state.canStartJSXElement = true;
                                }
                            } else {
                                this.state.canStartJSXElement = tokenComesBeforeExpression(type);
                            }
                        }
                    }
                ]);
                return JSXParserMixin;
            }(superClass);
            return JSXParserMixin;
        };
        var TypeScriptScope = /*#__PURE__*/ function(Scope) {
            _inherits(TypeScriptScope, Scope);
            function TypeScriptScope() {
                _class_call_check(this, TypeScriptScope);
                var _this;
                _this = _call_super(this, TypeScriptScope, arguments);
                _this.tsNames = /* @__PURE__ */ new Map();
                return _this;
            }
            return TypeScriptScope;
        }(Scope);
        var TypeScriptScopeHandler = /*#__PURE__*/ function(ScopeHandler) {
            _inherits(TypeScriptScopeHandler, ScopeHandler);
            function TypeScriptScopeHandler() {
                _class_call_check(this, TypeScriptScopeHandler);
                var _this;
                _this = _call_super(this, TypeScriptScopeHandler, arguments);
                _this.importsStack = [];
                return _this;
            }
            _create_class(TypeScriptScopeHandler, [
                {
                    key: "createScope",
                    value: function createScope(flags) {
                        this.importsStack.push(/* @__PURE__ */ new Set());
                        return new TypeScriptScope(flags);
                    }
                },
                {
                    key: "enter",
                    value: function enter(flags) {
                        if (flags === 256) {
                            this.importsStack.push(/* @__PURE__ */ new Set());
                        }
                        _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "enter", this).call(this, flags);
                    }
                },
                {
                    key: "exit",
                    value: function exit() {
                        var flags = _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "exit", this).call(this);
                        if (flags === 256) {
                            this.importsStack.pop();
                        }
                        return flags;
                    }
                },
                {
                    key: "hasImport",
                    value: function hasImport(name, allowShadow) {
                        var len = this.importsStack.length;
                        if (this.importsStack[len - 1].has(name)) {
                            return true;
                        }
                        if (!allowShadow && len > 1) {
                            for(var i = 0; i < len - 1; i++){
                                if (this.importsStack[i].has(name)) return true;
                            }
                        }
                        return false;
                    }
                },
                {
                    key: "declareName",
                    value: function declareName(name, bindingType, loc) {
                        if (bindingType & 4096) {
                            if (this.hasImport(name, true)) {
                                this.parser.raise(Errors.VarRedeclaration, loc, {
                                    identifierName: name
                                });
                            }
                            this.importsStack[this.importsStack.length - 1].add(name);
                            return;
                        }
                        var scope = this.currentScope();
                        var type = scope.tsNames.get(name) || 0;
                        if (bindingType & 1024) {
                            this.maybeExportDefined(scope, name);
                            scope.tsNames.set(name, type | 16);
                            return;
                        }
                        _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "declareName", this).call(this, name, bindingType, loc);
                        if (bindingType & 2) {
                            if (!(bindingType & 1)) {
                                this.checkRedeclarationInScope(scope, name, bindingType, loc);
                                this.maybeExportDefined(scope, name);
                            }
                            type = type | 1;
                        }
                        if (bindingType & 256) {
                            type = type | 2;
                        }
                        if (bindingType & 512) {
                            type = type | 4;
                        }
                        if (bindingType & 128) {
                            type = type | 8;
                        }
                        if (type) scope.tsNames.set(name, type);
                    }
                },
                {
                    key: "isRedeclaredInScope",
                    value: function isRedeclaredInScope(scope, name, bindingType) {
                        var type = scope.tsNames.get(name);
                        if ((type & 2) > 0) {
                            if (bindingType & 256) {
                                var isConst = !!(bindingType & 512);
                                var wasConst = (type & 4) > 0;
                                return isConst !== wasConst;
                            }
                            return true;
                        }
                        if (bindingType & 128 && (type & 8) > 0) {
                            if (scope.names.get(name) & 2) {
                                return !!(bindingType & 1);
                            } else {
                                return false;
                            }
                        }
                        if (bindingType & 2 && (type & 1) > 0) {
                            return true;
                        }
                        return _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "isRedeclaredInScope", this).call(this, scope, name, bindingType);
                    }
                },
                {
                    key: "checkLocalExport",
                    value: function checkLocalExport(id) {
                        var name = id.name;
                        if (this.hasImport(name)) return;
                        var len = this.scopeStack.length;
                        for(var i = len - 1; i >= 0; i--){
                            var scope = this.scopeStack[i];
                            var type = scope.tsNames.get(name);
                            if ((type & 1) > 0 || (type & 16) > 0) {
                                return;
                            }
                        }
                        _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "checkLocalExport", this).call(this, id);
                    }
                }
            ]);
            return TypeScriptScopeHandler;
        }(ScopeHandler);
        var unwrapParenthesizedExpression = function(node) {
            return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
        };
        var LValParser = /*#__PURE__*/ function(NodeUtils) {
            _inherits(LValParser, NodeUtils);
            function LValParser() {
                _class_call_check(this, LValParser);
                return _call_super(this, LValParser, arguments);
            }
            _create_class(LValParser, [
                {
                    key: "toAssignable",
                    value: function toAssignable(node) {
                        var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                        var _node$extra, _node$extra3;
                        var parenthesized = void 0;
                        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
                            parenthesized = unwrapParenthesizedExpression(node);
                            if (isLHS) {
                                if (parenthesized.type === "Identifier") {
                                    this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
                                } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
                                    this.raise(Errors.InvalidParenthesizedAssignment, node);
                                }
                            } else {
                                this.raise(Errors.InvalidParenthesizedAssignment, node);
                            }
                        }
                        switch(node.type){
                            case "Identifier":
                            case "ObjectPattern":
                            case "ArrayPattern":
                            case "AssignmentPattern":
                            case "RestElement":
                                break;
                            case "ObjectExpression":
                                node.type = "ObjectPattern";
                                for(var i = 0, length = node.properties.length, last3 = length - 1; i < length; i++){
                                    var _node$extra2;
                                    var prop = node.properties[i];
                                    var isLast = i === last3;
                                    this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                                    if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                                        this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
                                    }
                                }
                                break;
                            case "ObjectProperty":
                                {
                                    var key2 = node.key, value = node.value;
                                    if (this.isPrivateName(key2)) {
                                        this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start);
                                    }
                                    this.toAssignable(value, isLHS);
                                    break;
                                }
                            case "SpreadElement":
                                {
                                    throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                                }
                            case "ArrayExpression":
                                node.type = "ArrayPattern";
                                this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
                                break;
                            case "AssignmentExpression":
                                if (node.operator !== "=") {
                                    this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
                                }
                                node.type = "AssignmentPattern";
                                delete node.operator;
                                this.toAssignable(node.left, isLHS);
                                break;
                            case "ParenthesizedExpression":
                                this.toAssignable(parenthesized, isLHS);
                                break;
                        }
                    }
                },
                {
                    key: "toAssignableObjectExpressionProp",
                    value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
                        if (prop.type === "ObjectMethod") {
                            this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
                        } else if (prop.type === "SpreadElement") {
                            prop.type = "RestElement";
                            var arg = prop.argument;
                            this.checkToRestConversion(arg, false);
                            this.toAssignable(arg, isLHS);
                            if (!isLast) {
                                this.raise(Errors.RestTrailingComma, prop);
                            }
                        } else {
                            this.toAssignable(prop, isLHS);
                        }
                    }
                },
                {
                    key: "toAssignableList",
                    value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
                        var end = exprList.length - 1;
                        for(var i = 0; i <= end; i++){
                            var elt = exprList[i];
                            if (!elt) continue;
                            if (elt.type === "SpreadElement") {
                                elt.type = "RestElement";
                                var arg = elt.argument;
                                this.checkToRestConversion(arg, true);
                                this.toAssignable(arg, isLHS);
                            } else {
                                this.toAssignable(elt, isLHS);
                            }
                            if (elt.type === "RestElement") {
                                if (i < end) {
                                    this.raise(Errors.RestTrailingComma, elt);
                                } else if (trailingCommaLoc) {
                                    this.raise(Errors.RestTrailingComma, trailingCommaLoc);
                                }
                            }
                        }
                    }
                },
                {
                    key: "isAssignable",
                    value: function isAssignable(node, isBinding) {
                        var _this = this;
                        switch(node.type){
                            case "Identifier":
                            case "ObjectPattern":
                            case "ArrayPattern":
                            case "AssignmentPattern":
                            case "RestElement":
                                return true;
                            case "ObjectExpression":
                                {
                                    var last3 = node.properties.length - 1;
                                    return node.properties.every(function(prop, i) {
                                        return prop.type !== "ObjectMethod" && (i === last3 || prop.type !== "SpreadElement") && _this.isAssignable(prop);
                                    });
                                }
                            case "ObjectProperty":
                                return this.isAssignable(node.value);
                            case "SpreadElement":
                                return this.isAssignable(node.argument);
                            case "ArrayExpression":
                                return node.elements.every(function(element) {
                                    return element === null || _this.isAssignable(element);
                                });
                            case "AssignmentExpression":
                                return node.operator === "=";
                            case "ParenthesizedExpression":
                                return this.isAssignable(node.expression);
                            case "MemberExpression":
                            case "OptionalMemberExpression":
                                return !isBinding;
                            default:
                                return false;
                        }
                    }
                },
                {
                    key: "toReferencedList",
                    value: function toReferencedList(exprList, isParenthesizedExpr) {
                        return exprList;
                    }
                },
                {
                    key: "toReferencedListDeep",
                    value: function toReferencedListDeep(exprList, isParenthesizedExpr) {
                        this.toReferencedList(exprList, isParenthesizedExpr);
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = exprList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var expr = _step.value;
                                if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
                                    this.toReferencedListDeep(expr.elements);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                },
                {
                    key: "parseSpread",
                    value: function parseSpread(refExpressionErrors) {
                        var node = this.startNode();
                        this.next();
                        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
                        return this.finishNode(node, "SpreadElement");
                    }
                },
                {
                    key: "parseRestBinding",
                    value: function parseRestBinding() {
                        var node = this.startNode();
                        this.next();
                        node.argument = this.parseBindingAtom();
                        return this.finishNode(node, "RestElement");
                    }
                },
                {
                    key: "parseBindingAtom",
                    value: function parseBindingAtom() {
                        switch(this.state.type){
                            case 0:
                                {
                                    var node = this.startNode();
                                    this.next();
                                    node.elements = this.parseBindingList(3, 93, 1);
                                    return this.finishNode(node, "ArrayPattern");
                                }
                            case 5:
                                return this.parseObjectLike(8, true);
                        }
                        return this.parseIdentifier();
                    }
                },
                {
                    key: "parseBindingList",
                    value: function parseBindingList(close, closeCharCode, flags) {
                        var allowEmpty = flags & 1;
                        var elts = [];
                        var first = true;
                        while(!this.eat(close)){
                            if (first) {
                                first = false;
                            } else {
                                this.expect(12);
                            }
                            if (allowEmpty && this.match(12)) {
                                elts.push(null);
                            } else if (this.eat(close)) {
                                break;
                            } else if (this.match(21)) {
                                var rest = this.parseRestBinding();
                                if (this.hasPlugin("flow") || flags & 2) {
                                    rest = this.parseFunctionParamType(rest);
                                }
                                elts.push(rest);
                                if (!this.checkCommaAfterRest(closeCharCode)) {
                                    this.expect(close);
                                    break;
                                }
                            } else {
                                var decorators = [];
                                if (this.match(26) && this.hasPlugin("decorators")) {
                                    this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
                                }
                                while(this.match(26)){
                                    decorators.push(this.parseDecorator());
                                }
                                elts.push(this.parseAssignableListItem(flags, decorators));
                            }
                        }
                        return elts;
                    }
                },
                {
                    key: "parseBindingRestProperty",
                    value: function parseBindingRestProperty(prop) {
                        this.next();
                        prop.argument = this.parseIdentifier();
                        this.checkCommaAfterRest(125);
                        return this.finishNode(prop, "RestElement");
                    }
                },
                {
                    key: "parseBindingProperty",
                    value: function parseBindingProperty() {
                        var _this_state = this.state, type = _this_state.type, startLoc = _this_state.startLoc;
                        if (type === 21) {
                            return this.parseBindingRestProperty(this.startNode());
                        }
                        var prop = this.startNode();
                        if (type === 139) {
                            this.expectPlugin("destructuringPrivate", startLoc);
                            this.classScope.usePrivateName(this.state.value, startLoc);
                            prop.key = this.parsePrivateName();
                        } else {
                            this.parsePropertyName(prop);
                        }
                        prop.method = false;
                        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
                    }
                },
                {
                    key: "parseAssignableListItem",
                    value: function parseAssignableListItem(flags, decorators) {
                        var left = this.parseMaybeDefault();
                        if (this.hasPlugin("flow") || flags & 2) {
                            this.parseFunctionParamType(left);
                        }
                        var elt = this.parseMaybeDefault(left.loc.start, left);
                        if (decorators.length) {
                            left.decorators = decorators;
                        }
                        return elt;
                    }
                },
                {
                    key: "parseFunctionParamType",
                    value: function parseFunctionParamType(param) {
                        return param;
                    }
                },
                {
                    key: "parseMaybeDefault",
                    value: function parseMaybeDefault(startLoc, left) {
                        var _startLoc, _left;
                        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
                        left = (_left = left) != null ? _left : this.parseBindingAtom();
                        if (!this.eat(29)) return left;
                        var node = this.startNodeAt(startLoc);
                        node.left = left;
                        node.right = this.parseMaybeAssignAllowIn();
                        return this.finishNode(node, "AssignmentPattern");
                    }
                },
                {
                    key: "isValidLVal",
                    value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
                        switch(type){
                            case "AssignmentPattern":
                                return "left";
                            case "RestElement":
                                return "argument";
                            case "ObjectProperty":
                                return "value";
                            case "ParenthesizedExpression":
                                return "expression";
                            case "ArrayPattern":
                                return "elements";
                            case "ObjectPattern":
                                return "properties";
                        }
                        return false;
                    }
                },
                {
                    key: "isOptionalMemberExpression",
                    value: function isOptionalMemberExpression(expression) {
                        return expression.type === "OptionalMemberExpression";
                    }
                },
                {
                    key: "checkLVal",
                    value: function checkLVal(expression, ancestor) {
                        var binding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 64;
                        var checkClashes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                        var strictModeChanged = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                        var hasParenthesizedAncestor = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                        var _expression$extra;
                        var type = expression.type;
                        if (this.isObjectMethod(expression)) return;
                        var isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
                        if (isOptionalMemberExpression || type === "MemberExpression") {
                            if (isOptionalMemberExpression) {
                                this.expectPlugin("optionalChainingAssign", expression.loc.start);
                                if (ancestor.type !== "AssignmentExpression") {
                                    this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                                        ancestor: ancestor
                                    });
                                }
                            }
                            if (binding !== 64) {
                                this.raise(Errors.InvalidPropertyBindingPattern, expression);
                            }
                            return;
                        }
                        if (type === "Identifier") {
                            this.checkIdentifier(expression, binding, strictModeChanged);
                            var name = expression.name;
                            if (checkClashes) {
                                if (checkClashes.has(name)) {
                                    this.raise(Errors.ParamDupe, expression);
                                } else {
                                    checkClashes.add(name);
                                }
                            }
                            return;
                        }
                        var validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
                        if (validity === true) return;
                        if (validity === false) {
                            var ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
                            this.raise(ParseErrorClass, expression, {
                                ancestor: ancestor
                            });
                            return;
                        }
                        var key2, isParenthesizedExpression;
                        if (typeof validity === "string") {
                            key2 = validity;
                            isParenthesizedExpression = type === "ParenthesizedExpression";
                        } else {
                            var ref;
                            ref = _sliced_to_array(validity, 2), key2 = ref[0], isParenthesizedExpression = ref[1], ref;
                        }
                        var nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
                            type: type
                        } : ancestor;
                        var val = expression[key2];
                        if (Array.isArray(val)) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = val[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var child = _step.value;
                                    if (child) {
                                        this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        } else if (val) {
                            this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
                        }
                    }
                },
                {
                    key: "checkIdentifier",
                    value: function checkIdentifier(at, bindingType) {
                        var strictModeChanged = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
                            if (bindingType === 64) {
                                this.raise(Errors.StrictEvalArguments, at, {
                                    referenceName: at.name
                                });
                            } else {
                                this.raise(Errors.StrictEvalArgumentsBinding, at, {
                                    bindingName: at.name
                                });
                            }
                        }
                        if (bindingType & 8192 && at.name === "let") {
                            this.raise(Errors.LetInLexicalBinding, at);
                        }
                        if (!(bindingType & 64)) {
                            this.declareNameFromIdentifier(at, bindingType);
                        }
                    }
                },
                {
                    key: "declareNameFromIdentifier",
                    value: function declareNameFromIdentifier(identifier, binding) {
                        this.scope.declareName(identifier.name, binding, identifier.loc.start);
                    }
                },
                {
                    key: "checkToRestConversion",
                    value: function checkToRestConversion(node, allowPattern) {
                        switch(node.type){
                            case "ParenthesizedExpression":
                                this.checkToRestConversion(node.expression, allowPattern);
                                break;
                            case "Identifier":
                            case "MemberExpression":
                                break;
                            case "ArrayExpression":
                            case "ObjectExpression":
                                if (allowPattern) break;
                            default:
                                this.raise(Errors.InvalidRestAssignmentPattern, node);
                        }
                    }
                },
                {
                    key: "checkCommaAfterRest",
                    value: function checkCommaAfterRest(close) {
                        if (!this.match(12)) {
                            return false;
                        }
                        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
                        return true;
                    }
                }
            ]);
            return LValParser;
        }(NodeUtils);
        function nonNull(x) {
            if (x == null) {
                throw new Error("Unexpected ".concat(x, " value."));
            }
            return x;
        }
        function assert(x) {
            if (!x) {
                throw new Error("Assert fail");
            }
        }
        var TSErrors = ParseErrorEnum(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([
            "typescript"
        ])))({
            AbstractMethodHasImplementation: function(_ref62) {
                var methodName = _ref62.methodName;
                return "Method '".concat(methodName, "' cannot have an implementation because it is marked abstract.");
            },
            AbstractPropertyHasInitializer: function(_ref63) {
                var propertyName = _ref63.propertyName;
                return "Property '".concat(propertyName, "' cannot have an initializer because it is marked abstract.");
            },
            AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
            AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
            AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
            ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
            ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
            ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
            ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
            DeclareAccessor: function(_ref64) {
                var kind = _ref64.kind;
                return "'declare' is not allowed in ".concat(kind, "ters.");
            },
            DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
            DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
            DuplicateAccessibilityModifier: function(_ref65) {
                var modifier = _ref65.modifier;
                return "Accessibility modifier already seen.";
            },
            DuplicateModifier: function(_ref66) {
                var modifier = _ref66.modifier;
                return "Duplicate modifier: '".concat(modifier, "'.");
            },
            EmptyHeritageClauseType: function(_ref67) {
                var token = _ref67.token;
                return "'".concat(token, "' list cannot be empty.");
            },
            EmptyTypeArguments: "Type argument list cannot be empty.",
            EmptyTypeParameters: "Type parameter list cannot be empty.",
            ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
            ImportAliasHasImportType: "An import alias can not use 'import type'.",
            ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
            IncompatibleModifiers: function(_ref68) {
                var modifiers = _ref68.modifiers;
                return "'".concat(modifiers[0], "' modifier cannot be used with '").concat(modifiers[1], "' modifier.");
            },
            IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
            IndexSignatureHasAccessibility: function(_ref69) {
                var modifier = _ref69.modifier;
                return "Index signatures cannot have an accessibility modifier ('".concat(modifier, "').");
            },
            IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
            IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
            IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
            InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
            InvalidModifierOnTypeMember: function(_ref70) {
                var modifier = _ref70.modifier;
                return "'".concat(modifier, "' modifier cannot appear on a type member.");
            },
            InvalidModifierOnTypeParameter: function(_ref71) {
                var modifier = _ref71.modifier;
                return "'".concat(modifier, "' modifier cannot appear on a type parameter.");
            },
            InvalidModifierOnTypeParameterPositions: function(_ref72) {
                var modifier = _ref72.modifier;
                return "'".concat(modifier, "' modifier can only appear on a type parameter of a class, interface or type alias.");
            },
            InvalidModifiersOrder: function(_ref73) {
                var orderedModifiers = _ref73.orderedModifiers;
                return "'".concat(orderedModifiers[0], "' modifier must precede '").concat(orderedModifiers[1], "' modifier.");
            },
            InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
            InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
            MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
            NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
            NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
            OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
            OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
            PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
            PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
            PrivateElementHasAccessibility: function(_ref74) {
                var modifier = _ref74.modifier;
                return "Private elements cannot have an accessibility modifier ('".concat(modifier, "').");
            },
            ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
            ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
            ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
            SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
            SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
            SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
            SingleTypeParameterWithoutTrailingComma: function(_ref75) {
                var typeParameterName = _ref75.typeParameterName;
                return "Single type parameter ".concat(typeParameterName, " should have a trailing comma. Example usage: <").concat(typeParameterName, ",>.");
            },
            StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
            TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
            TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
            TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
            TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
            TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
            UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
            UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
            UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
            UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
            UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
            UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
            UnsupportedSignatureParameterKind: function(_ref76) {
                var type = _ref76.type;
                return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(type, ".");
            }
        });
        function keywordTypeFromName(value) {
            switch(value){
                case "any":
                    return "TSAnyKeyword";
                case "boolean":
                    return "TSBooleanKeyword";
                case "bigint":
                    return "TSBigIntKeyword";
                case "never":
                    return "TSNeverKeyword";
                case "number":
                    return "TSNumberKeyword";
                case "object":
                    return "TSObjectKeyword";
                case "string":
                    return "TSStringKeyword";
                case "symbol":
                    return "TSSymbolKeyword";
                case "undefined":
                    return "TSUndefinedKeyword";
                case "unknown":
                    return "TSUnknownKeyword";
                default:
                    return void 0;
            }
        }
        function tsIsAccessModifier(modifier) {
            return modifier === "private" || modifier === "public" || modifier === "protected";
        }
        function tsIsVarianceAnnotations(modifier) {
            return modifier === "in" || modifier === "out";
        }
        var typescript = function(superClass) {
            var TypeScriptParserMixin = /*#__PURE__*/ function(superClass) {
                _inherits(TypeScriptParserMixin, superClass);
                function TypeScriptParserMixin() {
                    _class_call_check(this, TypeScriptParserMixin);
                    var _this;
                    _this = _call_super(this, TypeScriptParserMixin, arguments);
                    _this.tsParseInOutModifiers = _this.tsParseModifiers.bind(_this, {
                        allowedModifiers: [
                            "in",
                            "out"
                        ],
                        disallowedModifiers: [
                            "const",
                            "public",
                            "private",
                            "protected",
                            "readonly",
                            "declare",
                            "abstract",
                            "override"
                        ],
                        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
                    });
                    _this.tsParseConstModifier = _this.tsParseModifiers.bind(_this, {
                        allowedModifiers: [
                            "const"
                        ],
                        disallowedModifiers: [
                            "in",
                            "out"
                        ],
                        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
                    });
                    _this.tsParseInOutConstModifiers = _this.tsParseModifiers.bind(_this, {
                        allowedModifiers: [
                            "in",
                            "out",
                            "const"
                        ],
                        disallowedModifiers: [
                            "public",
                            "private",
                            "protected",
                            "readonly",
                            "declare",
                            "abstract",
                            "override"
                        ],
                        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
                    });
                    return _this;
                }
                _create_class(TypeScriptParserMixin, [
                    {
                        key: "getScopeHandler",
                        value: function getScopeHandler() {
                            return TypeScriptScopeHandler;
                        }
                    },
                    {
                        key: "tsIsIdentifier",
                        value: function tsIsIdentifier() {
                            return tokenIsIdentifier(this.state.type);
                        }
                    },
                    {
                        key: "tsTokenCanFollowModifier",
                        value: function tsTokenCanFollowModifier() {
                            return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
                        }
                    },
                    {
                        key: "tsNextTokenOnSameLineAndCanFollowModifier",
                        value: function tsNextTokenOnSameLineAndCanFollowModifier() {
                            this.next();
                            if (this.hasPrecedingLineBreak()) {
                                return false;
                            }
                            return this.tsTokenCanFollowModifier();
                        }
                    },
                    {
                        key: "tsNextTokenCanFollowModifier",
                        value: function tsNextTokenCanFollowModifier() {
                            if (this.match(106)) {
                                this.next();
                                return this.tsTokenCanFollowModifier();
                            }
                            return this.tsNextTokenOnSameLineAndCanFollowModifier();
                        }
                    },
                    {
                        key: "tsParseModifier",
                        value: function tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
                            if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
                                return void 0;
                            }
                            var modifier = this.state.value;
                            if (allowedModifiers.includes(modifier)) {
                                if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
                                    return void 0;
                                }
                                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                                    return modifier;
                                }
                            }
                            return void 0;
                        }
                    },
                    {
                        key: "tsParseModifiers",
                        value: function tsParseModifiers(_ref77, modified) {
                            var _this = this;
                            var allowedModifiers = _ref77.allowedModifiers, disallowedModifiers = _ref77.disallowedModifiers, stopOnStartOfClassStaticBlock = _ref77.stopOnStartOfClassStaticBlock, _ref77_errorTemplate = _ref77.errorTemplate, errorTemplate = _ref77_errorTemplate === void 0 ? TSErrors.InvalidModifierOnTypeMember : _ref77_errorTemplate;
                            var enforceOrder = function(loc, modifier2, before, after) {
                                if (modifier2 === before && modified[after]) {
                                    _this.raise(TSErrors.InvalidModifiersOrder, loc, {
                                        orderedModifiers: [
                                            before,
                                            after
                                        ]
                                    });
                                }
                            };
                            var incompatible = function(loc, modifier2, mod1, mod2) {
                                if (modified[mod1] && modifier2 === mod2 || modified[mod2] && modifier2 === mod1) {
                                    _this.raise(TSErrors.IncompatibleModifiers, loc, {
                                        modifiers: [
                                            mod1,
                                            mod2
                                        ]
                                    });
                                }
                            };
                            for(;;){
                                var startLoc = this.state.startLoc;
                                var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
                                if (!modifier) break;
                                if (tsIsAccessModifier(modifier)) {
                                    if (modified.accessibility) {
                                        this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                                            modifier: modifier
                                        });
                                    } else {
                                        enforceOrder(startLoc, modifier, modifier, "override");
                                        enforceOrder(startLoc, modifier, modifier, "static");
                                        enforceOrder(startLoc, modifier, modifier, "readonly");
                                        modified.accessibility = modifier;
                                    }
                                } else if (tsIsVarianceAnnotations(modifier)) {
                                    if (modified[modifier]) {
                                        this.raise(TSErrors.DuplicateModifier, startLoc, {
                                            modifier: modifier
                                        });
                                    }
                                    modified[modifier] = true;
                                    enforceOrder(startLoc, modifier, "in", "out");
                                } else {
                                    if (hasOwnProperty.call(modified, modifier)) {
                                        this.raise(TSErrors.DuplicateModifier, startLoc, {
                                            modifier: modifier
                                        });
                                    } else {
                                        enforceOrder(startLoc, modifier, "static", "readonly");
                                        enforceOrder(startLoc, modifier, "static", "override");
                                        enforceOrder(startLoc, modifier, "override", "readonly");
                                        enforceOrder(startLoc, modifier, "abstract", "override");
                                        incompatible(startLoc, modifier, "declare", "override");
                                        incompatible(startLoc, modifier, "static", "abstract");
                                    }
                                    modified[modifier] = true;
                                }
                                if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
                                    this.raise(errorTemplate, startLoc, {
                                        modifier: modifier
                                    });
                                }
                            }
                        }
                    },
                    {
                        key: "tsIsListTerminator",
                        value: function tsIsListTerminator(kind) {
                            switch(kind){
                                case "EnumMembers":
                                case "TypeMembers":
                                    return this.match(8);
                                case "HeritageClauseElement":
                                    return this.match(5);
                                case "TupleElementTypes":
                                    return this.match(3);
                                case "TypeParametersOrArguments":
                                    return this.match(48);
                            }
                        }
                    },
                    {
                        key: "tsParseList",
                        value: function tsParseList(kind, parseElement) {
                            var result = [];
                            while(!this.tsIsListTerminator(kind)){
                                result.push(parseElement());
                            }
                            return result;
                        }
                    },
                    {
                        key: "tsParseDelimitedList",
                        value: function tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
                            return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
                        }
                    },
                    {
                        key: "tsParseDelimitedListWorker",
                        value: function tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
                            var result = [];
                            var trailingCommaPos = -1;
                            for(;;){
                                if (this.tsIsListTerminator(kind)) {
                                    break;
                                }
                                trailingCommaPos = -1;
                                var element = parseElement();
                                if (element == null) {
                                    return void 0;
                                }
                                result.push(element);
                                if (this.eat(12)) {
                                    trailingCommaPos = this.state.lastTokStartLoc.index;
                                    continue;
                                }
                                if (this.tsIsListTerminator(kind)) {
                                    break;
                                }
                                if (expectSuccess) {
                                    this.expect(12);
                                }
                                return void 0;
                            }
                            if (refTrailingCommaPos) {
                                refTrailingCommaPos.value = trailingCommaPos;
                            }
                            return result;
                        }
                    },
                    {
                        key: "tsParseBracketedList",
                        value: function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
                            if (!skipFirstToken) {
                                if (bracket) {
                                    this.expect(0);
                                } else {
                                    this.expect(47);
                                }
                            }
                            var result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
                            if (bracket) {
                                this.expect(3);
                            } else {
                                this.expect(48);
                            }
                            return result;
                        }
                    },
                    {
                        key: "tsParseImportType",
                        value: function tsParseImportType() {
                            var node = this.startNode();
                            this.expect(83);
                            this.expect(10);
                            if (!this.match(134)) {
                                this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
                            }
                            node.argument = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
                            if (this.eat(12) && !this.match(11)) {
                                node.options = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssignAllowIn", this).call(this);
                                this.eat(12);
                            } else {
                                node.options = null;
                            }
                            this.expect(11);
                            if (this.eat(16)) {
                                node.qualifier = this.tsParseEntityName();
                            }
                            if (this.match(47)) {
                                node.typeParameters = this.tsParseTypeArguments();
                            }
                            return this.finishNode(node, "TSImportType");
                        }
                    },
                    {
                        key: "tsParseEntityName",
                        value: function tsParseEntityName() {
                            var allowReservedWords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                            var entity = this.parseIdentifier(allowReservedWords);
                            while(this.eat(16)){
                                var node = this.startNodeAtNode(entity);
                                node.left = entity;
                                node.right = this.parseIdentifier(allowReservedWords);
                                entity = this.finishNode(node, "TSQualifiedName");
                            }
                            return entity;
                        }
                    },
                    {
                        key: "tsParseTypeReference",
                        value: function tsParseTypeReference() {
                            var node = this.startNode();
                            node.typeName = this.tsParseEntityName();
                            if (!this.hasPrecedingLineBreak() && this.match(47)) {
                                node.typeParameters = this.tsParseTypeArguments();
                            }
                            return this.finishNode(node, "TSTypeReference");
                        }
                    },
                    {
                        key: "tsParseThisTypePredicate",
                        value: function tsParseThisTypePredicate(lhs) {
                            this.next();
                            var node = this.startNodeAtNode(lhs);
                            node.parameterName = lhs;
                            node.typeAnnotation = this.tsParseTypeAnnotation(false);
                            node.asserts = false;
                            return this.finishNode(node, "TSTypePredicate");
                        }
                    },
                    {
                        key: "tsParseThisTypeNode",
                        value: function tsParseThisTypeNode() {
                            var node = this.startNode();
                            this.next();
                            return this.finishNode(node, "TSThisType");
                        }
                    },
                    {
                        key: "tsParseTypeQuery",
                        value: function tsParseTypeQuery() {
                            var node = this.startNode();
                            this.expect(87);
                            if (this.match(83)) {
                                node.exprName = this.tsParseImportType();
                            } else {
                                node.exprName = this.tsParseEntityName();
                            }
                            if (!this.hasPrecedingLineBreak() && this.match(47)) {
                                node.typeParameters = this.tsParseTypeArguments();
                            }
                            return this.finishNode(node, "TSTypeQuery");
                        }
                    },
                    {
                        key: "tsParseTypeParameter",
                        value: function tsParseTypeParameter(parseModifiers) {
                            var node = this.startNode();
                            parseModifiers(node);
                            node.name = this.tsParseTypeParameterName();
                            node.constraint = this.tsEatThenParseType(81);
                            node.default = this.tsEatThenParseType(29);
                            return this.finishNode(node, "TSTypeParameter");
                        }
                    },
                    {
                        key: "tsTryParseTypeParameters",
                        value: function tsTryParseTypeParameters(parseModifiers) {
                            if (this.match(47)) {
                                return this.tsParseTypeParameters(parseModifiers);
                            }
                        }
                    },
                    {
                        key: "tsParseTypeParameters",
                        value: function tsParseTypeParameters(parseModifiers) {
                            var node = this.startNode();
                            if (this.match(47) || this.match(143)) {
                                this.next();
                            } else {
                                this.unexpected();
                            }
                            var refTrailingCommaPos = {
                                value: -1
                            };
                            node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
                            if (node.params.length === 0) {
                                this.raise(TSErrors.EmptyTypeParameters, node);
                            }
                            if (refTrailingCommaPos.value !== -1) {
                                this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
                            }
                            return this.finishNode(node, "TSTypeParameterDeclaration");
                        }
                    },
                    {
                        key: "tsFillSignature",
                        value: function tsFillSignature(returnToken, signature) {
                            var returnTokenRequired = returnToken === 19;
                            var paramsKey = "parameters";
                            var returnTypeKey = "typeAnnotation";
                            signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                            this.expect(10);
                            signature[paramsKey] = this.tsParseBindingListForSignature();
                            if (returnTokenRequired) {
                                signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
                            } else if (this.match(returnToken)) {
                                signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
                            }
                        }
                    },
                    {
                        key: "tsParseBindingListForSignature",
                        value: function tsParseBindingListForSignature() {
                            var list = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBindingList", this).call(this, 11, 41, 2);
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var pattern = _step.value;
                                    var type = pattern.type;
                                    if (type === "AssignmentPattern" || type === "TSParameterProperty") {
                                        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
                                            type: type
                                        });
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            return list;
                        }
                    },
                    {
                        key: "tsParseTypeMemberSemicolon",
                        value: function tsParseTypeMemberSemicolon() {
                            if (!this.eat(12) && !this.isLineTerminator()) {
                                this.expect(13);
                            }
                        }
                    },
                    {
                        key: "tsParseSignatureMember",
                        value: function tsParseSignatureMember(kind, node) {
                            this.tsFillSignature(14, node);
                            this.tsParseTypeMemberSemicolon();
                            return this.finishNode(node, kind);
                        }
                    },
                    {
                        key: "tsIsUnambiguouslyIndexSignature",
                        value: function tsIsUnambiguouslyIndexSignature() {
                            this.next();
                            if (tokenIsIdentifier(this.state.type)) {
                                this.next();
                                return this.match(14);
                            }
                            return false;
                        }
                    },
                    {
                        key: "tsTryParseIndexSignature",
                        value: function tsTryParseIndexSignature(node) {
                            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
                                return;
                            }
                            this.expect(0);
                            var id = this.parseIdentifier();
                            id.typeAnnotation = this.tsParseTypeAnnotation();
                            this.resetEndLocation(id);
                            this.expect(3);
                            node.parameters = [
                                id
                            ];
                            var type = this.tsTryParseTypeAnnotation();
                            if (type) node.typeAnnotation = type;
                            this.tsParseTypeMemberSemicolon();
                            return this.finishNode(node, "TSIndexSignature");
                        }
                    },
                    {
                        key: "tsParsePropertyOrMethodSignature",
                        value: function tsParsePropertyOrMethodSignature(node, readonly) {
                            if (this.eat(17)) node.optional = true;
                            var nodeAny = node;
                            if (this.match(10) || this.match(47)) {
                                if (readonly) {
                                    this.raise(TSErrors.ReadonlyForMethodSignature, node);
                                }
                                var method = nodeAny;
                                if (method.kind && this.match(47)) {
                                    this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
                                }
                                this.tsFillSignature(14, method);
                                this.tsParseTypeMemberSemicolon();
                                var paramsKey = "parameters";
                                var returnTypeKey = "typeAnnotation";
                                if (method.kind === "get") {
                                    if (method[paramsKey].length > 0) {
                                        this.raise(Errors.BadGetterArity, this.state.curPosition());
                                        if (this.isThisParam(method[paramsKey][0])) {
                                            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                                        }
                                    }
                                } else if (method.kind === "set") {
                                    if (method[paramsKey].length !== 1) {
                                        this.raise(Errors.BadSetterArity, this.state.curPosition());
                                    } else {
                                        var firstParameter = method[paramsKey][0];
                                        if (this.isThisParam(firstParameter)) {
                                            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                                        }
                                        if (firstParameter.type === "Identifier" && firstParameter.optional) {
                                            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
                                        }
                                        if (firstParameter.type === "RestElement") {
                                            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                                        }
                                    }
                                    if (method[returnTypeKey]) {
                                        this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
                                    }
                                } else {
                                    method.kind = "method";
                                }
                                return this.finishNode(method, "TSMethodSignature");
                            } else {
                                var property = nodeAny;
                                if (readonly) property.readonly = true;
                                var type = this.tsTryParseTypeAnnotation();
                                if (type) property.typeAnnotation = type;
                                this.tsParseTypeMemberSemicolon();
                                return this.finishNode(property, "TSPropertySignature");
                            }
                        }
                    },
                    {
                        key: "tsParseTypeMember",
                        value: function tsParseTypeMember() {
                            var node = this.startNode();
                            if (this.match(10) || this.match(47)) {
                                return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
                            }
                            if (this.match(77)) {
                                var id = this.startNode();
                                this.next();
                                if (this.match(10) || this.match(47)) {
                                    return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
                                } else {
                                    node.key = this.createIdentifier(id, "new");
                                    return this.tsParsePropertyOrMethodSignature(node, false);
                                }
                            }
                            this.tsParseModifiers({
                                allowedModifiers: [
                                    "readonly"
                                ],
                                disallowedModifiers: [
                                    "declare",
                                    "abstract",
                                    "private",
                                    "protected",
                                    "public",
                                    "static",
                                    "override"
                                ]
                            }, node);
                            var idx = this.tsTryParseIndexSignature(node);
                            if (idx) {
                                return idx;
                            }
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parsePropertyName", this).call(this, node);
                            if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
                                node.kind = node.key.name;
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parsePropertyName", this).call(this, node);
                            }
                            return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
                        }
                    },
                    {
                        key: "tsParseTypeLiteral",
                        value: function tsParseTypeLiteral() {
                            var node = this.startNode();
                            node.members = this.tsParseObjectTypeMembers();
                            return this.finishNode(node, "TSTypeLiteral");
                        }
                    },
                    {
                        key: "tsParseObjectTypeMembers",
                        value: function tsParseObjectTypeMembers() {
                            this.expect(5);
                            var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                            this.expect(8);
                            return members;
                        }
                    },
                    {
                        key: "tsIsStartOfMappedType",
                        value: function tsIsStartOfMappedType() {
                            this.next();
                            if (this.eat(53)) {
                                return this.isContextual(122);
                            }
                            if (this.isContextual(122)) {
                                this.next();
                            }
                            if (!this.match(0)) {
                                return false;
                            }
                            this.next();
                            if (!this.tsIsIdentifier()) {
                                return false;
                            }
                            this.next();
                            return this.match(58);
                        }
                    },
                    {
                        key: "tsParseMappedType",
                        value: function tsParseMappedType() {
                            var node = this.startNode();
                            this.expect(5);
                            if (this.match(53)) {
                                node.readonly = this.state.value;
                                this.next();
                                this.expectContextual(122);
                            } else if (this.eatContextual(122)) {
                                node.readonly = true;
                            }
                            this.expect(0);
                            {
                                var typeParameter = this.startNode();
                                typeParameter.name = this.tsParseTypeParameterName();
                                typeParameter.constraint = this.tsExpectThenParseType(58);
                                node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
                            }
                            node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
                            this.expect(3);
                            if (this.match(53)) {
                                node.optional = this.state.value;
                                this.next();
                                this.expect(17);
                            } else if (this.eat(17)) {
                                node.optional = true;
                            }
                            node.typeAnnotation = this.tsTryParseType();
                            this.semicolon();
                            this.expect(8);
                            return this.finishNode(node, "TSMappedType");
                        }
                    },
                    {
                        key: "tsParseTupleType",
                        value: function tsParseTupleType() {
                            var _this = this;
                            var node = this.startNode();
                            node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
                            var seenOptionalElement = false;
                            node.elementTypes.forEach(function(elementNode) {
                                var type = elementNode.type;
                                if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
                                    _this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
                                }
                                seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
                            });
                            return this.finishNode(node, "TSTupleType");
                        }
                    },
                    {
                        key: "tsParseTupleElementType",
                        value: function tsParseTupleElementType() {
                            var startLoc = this.state.startLoc;
                            var rest = this.eat(21);
                            var labeled;
                            var label;
                            var optional;
                            var type;
                            var isWord = tokenIsKeywordOrIdentifier(this.state.type);
                            var chAfterWord = isWord ? this.lookaheadCharCode() : null;
                            if (chAfterWord === 58) {
                                labeled = true;
                                optional = false;
                                label = this.parseIdentifier(true);
                                this.expect(14);
                                type = this.tsParseType();
                            } else if (chAfterWord === 63) {
                                optional = true;
                                var _startLoc2 = this.state.startLoc;
                                var wordName = this.state.value;
                                var typeOrLabel = this.tsParseNonArrayType();
                                if (this.lookaheadCharCode() === 58) {
                                    labeled = true;
                                    label = this.createIdentifier(this.startNodeAt(_startLoc2), wordName);
                                    this.expect(17);
                                    this.expect(14);
                                    type = this.tsParseType();
                                } else {
                                    labeled = false;
                                    type = typeOrLabel;
                                    this.expect(17);
                                }
                            } else {
                                type = this.tsParseType();
                                optional = this.eat(17);
                                labeled = this.eat(14);
                            }
                            if (labeled) {
                                var labeledNode;
                                if (label) {
                                    labeledNode = this.startNodeAtNode(label);
                                    labeledNode.optional = optional;
                                    labeledNode.label = label;
                                    labeledNode.elementType = type;
                                    if (this.eat(17)) {
                                        labeledNode.optional = true;
                                        this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
                                    }
                                } else {
                                    labeledNode = this.startNodeAtNode(type);
                                    labeledNode.optional = optional;
                                    this.raise(TSErrors.InvalidTupleMemberLabel, type);
                                    labeledNode.label = type;
                                    labeledNode.elementType = this.tsParseType();
                                }
                                type = this.finishNode(labeledNode, "TSNamedTupleMember");
                            } else if (optional) {
                                var optionalTypeNode = this.startNodeAtNode(type);
                                optionalTypeNode.typeAnnotation = type;
                                type = this.finishNode(optionalTypeNode, "TSOptionalType");
                            }
                            if (rest) {
                                var restNode = this.startNodeAt(startLoc);
                                restNode.typeAnnotation = type;
                                type = this.finishNode(restNode, "TSRestType");
                            }
                            return type;
                        }
                    },
                    {
                        key: "tsParseParenthesizedType",
                        value: function tsParseParenthesizedType() {
                            var node = this.startNode();
                            this.expect(10);
                            node.typeAnnotation = this.tsParseType();
                            this.expect(11);
                            return this.finishNode(node, "TSParenthesizedType");
                        }
                    },
                    {
                        key: "tsParseFunctionOrConstructorType",
                        value: function tsParseFunctionOrConstructorType(type, abstract) {
                            var _this = this;
                            var node = this.startNode();
                            if (type === "TSConstructorType") {
                                node.abstract = !!abstract;
                                if (abstract) this.next();
                                this.next();
                            }
                            this.tsInAllowConditionalTypesContext(function() {
                                return _this.tsFillSignature(19, node);
                            });
                            return this.finishNode(node, type);
                        }
                    },
                    {
                        key: "tsParseLiteralTypeNode",
                        value: function tsParseLiteralTypeNode() {
                            var node = this.startNode();
                            switch(this.state.type){
                                case 135:
                                case 136:
                                case 134:
                                case 85:
                                case 86:
                                    node.literal = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
                                    break;
                                default:
                                    this.unexpected();
                            }
                            return this.finishNode(node, "TSLiteralType");
                        }
                    },
                    {
                        key: "tsParseTemplateLiteralType",
                        value: function tsParseTemplateLiteralType() {
                            var node = this.startNode();
                            node.literal = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseTemplate", this).call(this, false);
                            return this.finishNode(node, "TSLiteralType");
                        }
                    },
                    {
                        key: "parseTemplateSubstitution",
                        value: function parseTemplateSubstitution() {
                            if (this.state.inType) return this.tsParseType();
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseTemplateSubstitution", this).call(this);
                        }
                    },
                    {
                        key: "tsParseThisTypeOrThisTypePredicate",
                        value: function tsParseThisTypeOrThisTypePredicate() {
                            var thisKeyword = this.tsParseThisTypeNode();
                            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                                return this.tsParseThisTypePredicate(thisKeyword);
                            } else {
                                return thisKeyword;
                            }
                        }
                    },
                    {
                        key: "tsParseNonArrayType",
                        value: function tsParseNonArrayType() {
                            switch(this.state.type){
                                case 134:
                                case 135:
                                case 136:
                                case 85:
                                case 86:
                                    return this.tsParseLiteralTypeNode();
                                case 53:
                                    if (this.state.value === "-") {
                                        var node = this.startNode();
                                        var nextToken = this.lookahead();
                                        if (nextToken.type !== 135 && nextToken.type !== 136) {
                                            this.unexpected();
                                        }
                                        node.literal = this.parseMaybeUnary();
                                        return this.finishNode(node, "TSLiteralType");
                                    }
                                    break;
                                case 78:
                                    return this.tsParseThisTypeOrThisTypePredicate();
                                case 87:
                                    return this.tsParseTypeQuery();
                                case 83:
                                    return this.tsParseImportType();
                                case 5:
                                    return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                                case 0:
                                    return this.tsParseTupleType();
                                case 10:
                                    return this.tsParseParenthesizedType();
                                case 25:
                                case 24:
                                    return this.tsParseTemplateLiteralType();
                                default:
                                    {
                                        var type = this.state.type;
                                        if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                                            var nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                                            if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                                                var _node8 = this.startNode();
                                                this.next();
                                                return this.finishNode(_node8, nodeType);
                                            }
                                            return this.tsParseTypeReference();
                                        }
                                    }
                            }
                            this.unexpected();
                        }
                    },
                    {
                        key: "tsParseArrayTypeOrHigher",
                        value: function tsParseArrayTypeOrHigher() {
                            var type = this.tsParseNonArrayType();
                            while(!this.hasPrecedingLineBreak() && this.eat(0)){
                                if (this.match(3)) {
                                    var node = this.startNodeAtNode(type);
                                    node.elementType = type;
                                    this.expect(3);
                                    type = this.finishNode(node, "TSArrayType");
                                } else {
                                    var _node9 = this.startNodeAtNode(type);
                                    _node9.objectType = type;
                                    _node9.indexType = this.tsParseType();
                                    this.expect(3);
                                    type = this.finishNode(_node9, "TSIndexedAccessType");
                                }
                            }
                            return type;
                        }
                    },
                    {
                        key: "tsParseTypeOperator",
                        value: function tsParseTypeOperator() {
                            var node = this.startNode();
                            var operator = this.state.value;
                            this.next();
                            node.operator = operator;
                            node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
                            if (operator === "readonly") {
                                this.tsCheckTypeAnnotationForReadOnly(node);
                            }
                            return this.finishNode(node, "TSTypeOperator");
                        }
                    },
                    {
                        key: "tsCheckTypeAnnotationForReadOnly",
                        value: function tsCheckTypeAnnotationForReadOnly(node) {
                            switch(node.typeAnnotation.type){
                                case "TSTupleType":
                                case "TSArrayType":
                                    return;
                                default:
                                    this.raise(TSErrors.UnexpectedReadonly, node);
                            }
                        }
                    },
                    {
                        key: "tsParseInferType",
                        value: function tsParseInferType() {
                            var _this = this;
                            var node = this.startNode();
                            this.expectContextual(115);
                            var typeParameter = this.startNode();
                            typeParameter.name = this.tsParseTypeParameterName();
                            typeParameter.constraint = this.tsTryParse(function() {
                                return _this.tsParseConstraintForInferType();
                            });
                            node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
                            return this.finishNode(node, "TSInferType");
                        }
                    },
                    {
                        key: "tsParseConstraintForInferType",
                        value: function tsParseConstraintForInferType() {
                            var _this = this;
                            if (this.eat(81)) {
                                var constraint = this.tsInDisallowConditionalTypesContext(function() {
                                    return _this.tsParseType();
                                });
                                if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
                                    return constraint;
                                }
                            }
                        }
                    },
                    {
                        key: "tsParseTypeOperatorOrHigher",
                        value: function tsParseTypeOperatorOrHigher() {
                            var _this = this;
                            var isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
                            return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(function() {
                                return _this.tsParseArrayTypeOrHigher();
                            });
                        }
                    },
                    {
                        key: "tsParseUnionOrIntersectionType",
                        value: function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
                            var node = this.startNode();
                            var hasLeadingOperator = this.eat(operator);
                            var types2 = [];
                            do {
                                types2.push(parseConstituentType());
                            }while (this.eat(operator));
                            if (types2.length === 1 && !hasLeadingOperator) {
                                return types2[0];
                            }
                            node.types = types2;
                            return this.finishNode(node, kind);
                        }
                    },
                    {
                        key: "tsParseIntersectionTypeOrHigher",
                        value: function tsParseIntersectionTypeOrHigher() {
                            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
                        }
                    },
                    {
                        key: "tsParseUnionTypeOrHigher",
                        value: function tsParseUnionTypeOrHigher() {
                            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
                        }
                    },
                    {
                        key: "tsIsStartOfFunctionType",
                        value: function tsIsStartOfFunctionType() {
                            if (this.match(47)) {
                                return true;
                            }
                            return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                        }
                    },
                    {
                        key: "tsSkipParameterStart",
                        value: function tsSkipParameterStart() {
                            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                                this.next();
                                return true;
                            }
                            if (this.match(5)) {
                                var errors = this.state.errors;
                                var previousErrorCount = errors.length;
                                try {
                                    this.parseObjectLike(8, true);
                                    return errors.length === previousErrorCount;
                                } catch (_unused) {
                                    return false;
                                }
                            }
                            if (this.match(0)) {
                                this.next();
                                var _this_state = this.state, _errors = _this_state.errors;
                                var _previousErrorCount = _errors.length;
                                try {
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBindingList", this).call(this, 3, 93, 1);
                                    return _errors.length === _previousErrorCount;
                                } catch (_unused2) {
                                    return false;
                                }
                            }
                            return false;
                        }
                    },
                    {
                        key: "tsIsUnambiguouslyStartOfFunctionType",
                        value: function tsIsUnambiguouslyStartOfFunctionType() {
                            this.next();
                            if (this.match(11) || this.match(21)) {
                                return true;
                            }
                            if (this.tsSkipParameterStart()) {
                                if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
                                    return true;
                                }
                                if (this.match(11)) {
                                    this.next();
                                    if (this.match(19)) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        }
                    },
                    {
                        key: "tsParseTypeOrTypePredicateAnnotation",
                        value: function tsParseTypeOrTypePredicateAnnotation(returnToken) {
                            var _this = this;
                            return this.tsInType(function() {
                                var t = _this.startNode();
                                _this.expect(returnToken);
                                var node = _this.startNode();
                                var asserts = !!_this.tsTryParse(_this.tsParseTypePredicateAsserts.bind(_this));
                                if (asserts && _this.match(78)) {
                                    var thisTypePredicate = _this.tsParseThisTypeOrThisTypePredicate();
                                    if (thisTypePredicate.type === "TSThisType") {
                                        node.parameterName = thisTypePredicate;
                                        node.asserts = true;
                                        node.typeAnnotation = null;
                                        thisTypePredicate = _this.finishNode(node, "TSTypePredicate");
                                    } else {
                                        _this.resetStartLocationFromNode(thisTypePredicate, node);
                                        thisTypePredicate.asserts = true;
                                    }
                                    t.typeAnnotation = thisTypePredicate;
                                    return _this.finishNode(t, "TSTypeAnnotation");
                                }
                                var typePredicateVariable = _this.tsIsIdentifier() && _this.tsTryParse(_this.tsParseTypePredicatePrefix.bind(_this));
                                if (!typePredicateVariable) {
                                    if (!asserts) {
                                        return _this.tsParseTypeAnnotation(false, t);
                                    }
                                    node.parameterName = _this.parseIdentifier();
                                    node.asserts = asserts;
                                    node.typeAnnotation = null;
                                    t.typeAnnotation = _this.finishNode(node, "TSTypePredicate");
                                    return _this.finishNode(t, "TSTypeAnnotation");
                                }
                                var type = _this.tsParseTypeAnnotation(false);
                                node.parameterName = typePredicateVariable;
                                node.typeAnnotation = type;
                                node.asserts = asserts;
                                t.typeAnnotation = _this.finishNode(node, "TSTypePredicate");
                                return _this.finishNode(t, "TSTypeAnnotation");
                            });
                        }
                    },
                    {
                        key: "tsTryParseTypeOrTypePredicateAnnotation",
                        value: function tsTryParseTypeOrTypePredicateAnnotation() {
                            if (this.match(14)) {
                                return this.tsParseTypeOrTypePredicateAnnotation(14);
                            }
                        }
                    },
                    {
                        key: "tsTryParseTypeAnnotation",
                        value: function tsTryParseTypeAnnotation() {
                            if (this.match(14)) {
                                return this.tsParseTypeAnnotation();
                            }
                        }
                    },
                    {
                        key: "tsTryParseType",
                        value: function tsTryParseType() {
                            return this.tsEatThenParseType(14);
                        }
                    },
                    {
                        key: "tsParseTypePredicatePrefix",
                        value: function tsParseTypePredicatePrefix() {
                            var id = this.parseIdentifier();
                            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                                this.next();
                                return id;
                            }
                        }
                    },
                    {
                        key: "tsParseTypePredicateAsserts",
                        value: function tsParseTypePredicateAsserts() {
                            if (this.state.type !== 109) {
                                return false;
                            }
                            var containsEsc = this.state.containsEsc;
                            this.next();
                            if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
                                return false;
                            }
                            if (containsEsc) {
                                this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
                                    reservedWord: "asserts"
                                });
                            }
                            return true;
                        }
                    },
                    {
                        key: "tsParseTypeAnnotation",
                        value: function tsParseTypeAnnotation() {
                            var _this = this;
                            var eatColon = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                            var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
                            this.tsInType(function() {
                                if (eatColon) _this.expect(14);
                                t.typeAnnotation = _this.tsParseType();
                            });
                            return this.finishNode(t, "TSTypeAnnotation");
                        }
                    },
                    {
                        key: "tsParseType",
                        value: function tsParseType() {
                            var _this = this;
                            assert(this.state.inType);
                            var type = this.tsParseNonConditionalType();
                            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
                                return type;
                            }
                            var node = this.startNodeAtNode(type);
                            node.checkType = type;
                            node.extendsType = this.tsInDisallowConditionalTypesContext(function() {
                                return _this.tsParseNonConditionalType();
                            });
                            this.expect(17);
                            node.trueType = this.tsInAllowConditionalTypesContext(function() {
                                return _this.tsParseType();
                            });
                            this.expect(14);
                            node.falseType = this.tsInAllowConditionalTypesContext(function() {
                                return _this.tsParseType();
                            });
                            return this.finishNode(node, "TSConditionalType");
                        }
                    },
                    {
                        key: "isAbstractConstructorSignature",
                        value: function isAbstractConstructorSignature() {
                            return this.isContextual(124) && this.lookahead().type === 77;
                        }
                    },
                    {
                        key: "tsParseNonConditionalType",
                        value: function tsParseNonConditionalType() {
                            if (this.tsIsStartOfFunctionType()) {
                                return this.tsParseFunctionOrConstructorType("TSFunctionType");
                            }
                            if (this.match(77)) {
                                return this.tsParseFunctionOrConstructorType("TSConstructorType");
                            } else if (this.isAbstractConstructorSignature()) {
                                return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
                            }
                            return this.tsParseUnionTypeOrHigher();
                        }
                    },
                    {
                        key: "tsParseTypeAssertion",
                        value: function tsParseTypeAssertion() {
                            var _this = this;
                            if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                                this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
                            }
                            var node = this.startNode();
                            node.typeAnnotation = this.tsInType(function() {
                                _this.next();
                                return _this.match(75) ? _this.tsParseTypeReference() : _this.tsParseType();
                            });
                            this.expect(48);
                            node.expression = this.parseMaybeUnary();
                            return this.finishNode(node, "TSTypeAssertion");
                        }
                    },
                    {
                        key: "tsParseHeritageClause",
                        value: function tsParseHeritageClause(token) {
                            var _this = this;
                            var originalStartLoc = this.state.startLoc;
                            var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", function() {
                                var node = _this.startNode();
                                node.expression = _this.tsParseEntityName();
                                if (_this.match(47)) {
                                    node.typeParameters = _this.tsParseTypeArguments();
                                }
                                return _this.finishNode(node, "TSExpressionWithTypeArguments");
                            });
                            if (!delimitedList.length) {
                                this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
                                    token: token
                                });
                            }
                            return delimitedList;
                        }
                    },
                    {
                        key: "tsParseInterfaceDeclaration",
                        value: function tsParseInterfaceDeclaration(node) {
                            var properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            if (this.hasFollowingLineBreak()) return null;
                            this.expectContextual(129);
                            if (properties.declare) node.declare = true;
                            if (tokenIsIdentifier(this.state.type)) {
                                node.id = this.parseIdentifier();
                                this.checkIdentifier(node.id, 130);
                            } else {
                                node.id = null;
                                this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
                            }
                            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                            if (this.eat(81)) {
                                node.extends = this.tsParseHeritageClause("extends");
                            }
                            var body3 = this.startNode();
                            body3.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
                            node.body = this.finishNode(body3, "TSInterfaceBody");
                            return this.finishNode(node, "TSInterfaceDeclaration");
                        }
                    },
                    {
                        key: "tsParseTypeAliasDeclaration",
                        value: function tsParseTypeAliasDeclaration(node) {
                            var _this = this;
                            node.id = this.parseIdentifier();
                            this.checkIdentifier(node.id, 2);
                            node.typeAnnotation = this.tsInType(function() {
                                node.typeParameters = _this.tsTryParseTypeParameters(_this.tsParseInOutModifiers);
                                _this.expect(29);
                                if (_this.isContextual(114) && _this.lookahead().type !== 16) {
                                    var _node10 = _this.startNode();
                                    _this.next();
                                    return _this.finishNode(_node10, "TSIntrinsicKeyword");
                                }
                                return _this.tsParseType();
                            });
                            this.semicolon();
                            return this.finishNode(node, "TSTypeAliasDeclaration");
                        }
                    },
                    {
                        key: "tsInNoContext",
                        value: function tsInNoContext(cb) {
                            var oldContext = this.state.context;
                            this.state.context = [
                                oldContext[0]
                            ];
                            try {
                                return cb();
                            } finally{
                                this.state.context = oldContext;
                            }
                        }
                    },
                    {
                        key: "tsInType",
                        value: function tsInType(cb) {
                            var oldInType = this.state.inType;
                            this.state.inType = true;
                            try {
                                return cb();
                            } finally{
                                this.state.inType = oldInType;
                            }
                        }
                    },
                    {
                        key: "tsInDisallowConditionalTypesContext",
                        value: function tsInDisallowConditionalTypesContext(cb) {
                            var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
                            this.state.inDisallowConditionalTypesContext = true;
                            try {
                                return cb();
                            } finally{
                                this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
                            }
                        }
                    },
                    {
                        key: "tsInAllowConditionalTypesContext",
                        value: function tsInAllowConditionalTypesContext(cb) {
                            var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
                            this.state.inDisallowConditionalTypesContext = false;
                            try {
                                return cb();
                            } finally{
                                this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
                            }
                        }
                    },
                    {
                        key: "tsEatThenParseType",
                        value: function tsEatThenParseType(token) {
                            if (this.match(token)) {
                                return this.tsNextThenParseType();
                            }
                        }
                    },
                    {
                        key: "tsExpectThenParseType",
                        value: function tsExpectThenParseType(token) {
                            var _this = this;
                            return this.tsInType(function() {
                                _this.expect(token);
                                return _this.tsParseType();
                            });
                        }
                    },
                    {
                        key: "tsNextThenParseType",
                        value: function tsNextThenParseType() {
                            var _this = this;
                            return this.tsInType(function() {
                                _this.next();
                                return _this.tsParseType();
                            });
                        }
                    },
                    {
                        key: "tsParseEnumMember",
                        value: function tsParseEnumMember() {
                            var node = this.startNode();
                            node.id = this.match(134) ? _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseStringLiteral", this).call(this, this.state.value) : this.parseIdentifier(true);
                            if (this.eat(29)) {
                                node.initializer = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssignAllowIn", this).call(this);
                            }
                            return this.finishNode(node, "TSEnumMember");
                        }
                    },
                    {
                        key: "tsParseEnumDeclaration",
                        value: function tsParseEnumDeclaration(node) {
                            var properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            if (properties.const) node.const = true;
                            if (properties.declare) node.declare = true;
                            this.expectContextual(126);
                            node.id = this.parseIdentifier();
                            this.checkIdentifier(node.id, node.const ? 8971 : 8459);
                            this.expect(5);
                            node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
                            this.expect(8);
                            return this.finishNode(node, "TSEnumDeclaration");
                        }
                    },
                    {
                        key: "tsParseModuleBlock",
                        value: function tsParseModuleBlock() {
                            var node = this.startNode();
                            this.scope.enter(0);
                            this.expect(5);
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBlockOrModuleBlockBody", this).call(this, node.body = [], void 0, true, 8);
                            this.scope.exit();
                            return this.finishNode(node, "TSModuleBlock");
                        }
                    },
                    {
                        key: "tsParseModuleOrNamespaceDeclaration",
                        value: function tsParseModuleOrNamespaceDeclaration(node) {
                            var nested = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                            node.id = this.parseIdentifier();
                            if (!nested) {
                                this.checkIdentifier(node.id, 1024);
                            }
                            if (this.eat(16)) {
                                var inner = this.startNode();
                                this.tsParseModuleOrNamespaceDeclaration(inner, true);
                                node.body = inner;
                            } else {
                                this.scope.enter(256);
                                this.prodParam.enter(0);
                                node.body = this.tsParseModuleBlock();
                                this.prodParam.exit();
                                this.scope.exit();
                            }
                            return this.finishNode(node, "TSModuleDeclaration");
                        }
                    },
                    {
                        key: "tsParseAmbientExternalModuleDeclaration",
                        value: function tsParseAmbientExternalModuleDeclaration(node) {
                            if (this.isContextual(112)) {
                                node.kind = "global";
                                {
                                    node.global = true;
                                }
                                node.id = this.parseIdentifier();
                            } else if (this.match(134)) {
                                node.kind = "module";
                                node.id = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseStringLiteral", this).call(this, this.state.value);
                            } else {
                                this.unexpected();
                            }
                            if (this.match(5)) {
                                this.scope.enter(256);
                                this.prodParam.enter(0);
                                node.body = this.tsParseModuleBlock();
                                this.prodParam.exit();
                                this.scope.exit();
                            } else {
                                this.semicolon();
                            }
                            return this.finishNode(node, "TSModuleDeclaration");
                        }
                    },
                    {
                        key: "tsParseImportEqualsDeclaration",
                        value: function tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
                            node.isExport = isExport || false;
                            node.id = maybeDefaultIdentifier || this.parseIdentifier();
                            this.checkIdentifier(node.id, 4096);
                            this.expect(29);
                            var moduleReference = this.tsParseModuleReference();
                            if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
                                this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
                            }
                            node.moduleReference = moduleReference;
                            this.semicolon();
                            return this.finishNode(node, "TSImportEqualsDeclaration");
                        }
                    },
                    {
                        key: "tsIsExternalModuleReference",
                        value: function tsIsExternalModuleReference() {
                            return this.isContextual(119) && this.lookaheadCharCode() === 40;
                        }
                    },
                    {
                        key: "tsParseModuleReference",
                        value: function tsParseModuleReference() {
                            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
                        }
                    },
                    {
                        key: "tsParseExternalModuleReference",
                        value: function tsParseExternalModuleReference() {
                            var node = this.startNode();
                            this.expectContextual(119);
                            this.expect(10);
                            if (!this.match(134)) {
                                this.unexpected();
                            }
                            node.expression = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
                            this.expect(11);
                            this.sawUnambiguousESM = true;
                            return this.finishNode(node, "TSExternalModuleReference");
                        }
                    },
                    {
                        key: "tsLookAhead",
                        value: function tsLookAhead(f) {
                            var state = this.state.clone();
                            var res = f();
                            this.state = state;
                            return res;
                        }
                    },
                    {
                        key: "tsTryParseAndCatch",
                        value: function tsTryParseAndCatch(f) {
                            var result = this.tryParse(function(abort) {
                                return f() || abort();
                            });
                            if (result.aborted || !result.node) return;
                            if (result.error) this.state = result.failState;
                            return result.node;
                        }
                    },
                    {
                        key: "tsTryParse",
                        value: function tsTryParse(f) {
                            var state = this.state.clone();
                            var result = f();
                            if (result !== void 0 && result !== false) {
                                return result;
                            }
                            this.state = state;
                        }
                    },
                    {
                        key: "tsTryParseDeclare",
                        value: function tsTryParseDeclare(nany) {
                            var _this = this;
                            if (this.isLineTerminator()) {
                                return;
                            }
                            var startType = this.state.type;
                            var kind;
                            if (this.isContextual(100)) {
                                startType = 74;
                                kind = "let";
                            }
                            return this.tsInAmbientContext(function() {
                                switch(startType){
                                    case 68:
                                        nany.declare = true;
                                        return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionStatement", _this).call(_this, nany, false, false);
                                    case 80:
                                        nany.declare = true;
                                        return _this.parseClass(nany, true, false);
                                    case 126:
                                        return _this.tsParseEnumDeclaration(nany, {
                                            declare: true
                                        });
                                    case 112:
                                        return _this.tsParseAmbientExternalModuleDeclaration(nany);
                                    case 75:
                                    case 74:
                                        if (!_this.match(75) || !_this.isLookaheadContextual("enum")) {
                                            nany.declare = true;
                                            return _this.parseVarStatement(nany, kind || _this.state.value, true);
                                        }
                                        _this.expect(75);
                                        return _this.tsParseEnumDeclaration(nany, {
                                            const: true,
                                            declare: true
                                        });
                                    case 129:
                                        {
                                            var result = _this.tsParseInterfaceDeclaration(nany, {
                                                declare: true
                                            });
                                            if (result) return result;
                                        }
                                    default:
                                        if (tokenIsIdentifier(startType)) {
                                            return _this.tsParseDeclaration(nany, _this.state.value, true, null);
                                        }
                                }
                            });
                        }
                    },
                    {
                        key: "tsTryParseExportDeclaration",
                        value: function tsTryParseExportDeclaration() {
                            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
                        }
                    },
                    {
                        key: "tsParseExpressionStatement",
                        value: function tsParseExpressionStatement(node, expr, decorators) {
                            switch(expr.name){
                                case "declare":
                                    {
                                        var declaration = this.tsTryParseDeclare(node);
                                        if (declaration) {
                                            declaration.declare = true;
                                        }
                                        return declaration;
                                    }
                                case "global":
                                    if (this.match(5)) {
                                        this.scope.enter(256);
                                        this.prodParam.enter(0);
                                        var mod = node;
                                        mod.kind = "global";
                                        {
                                            node.global = true;
                                        }
                                        mod.id = expr;
                                        mod.body = this.tsParseModuleBlock();
                                        this.scope.exit();
                                        this.prodParam.exit();
                                        return this.finishNode(mod, "TSModuleDeclaration");
                                    }
                                    break;
                                default:
                                    return this.tsParseDeclaration(node, expr.name, false, decorators);
                            }
                        }
                    },
                    {
                        key: "tsParseDeclaration",
                        value: function tsParseDeclaration(node, value, next, decorators) {
                            switch(value){
                                case "abstract":
                                    if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                                        return this.tsParseAbstractDeclaration(node, decorators);
                                    }
                                    break;
                                case "module":
                                    if (this.tsCheckLineTerminator(next)) {
                                        if (this.match(134)) {
                                            return this.tsParseAmbientExternalModuleDeclaration(node);
                                        } else if (tokenIsIdentifier(this.state.type)) {
                                            node.kind = "module";
                                            return this.tsParseModuleOrNamespaceDeclaration(node);
                                        }
                                    }
                                    break;
                                case "namespace":
                                    if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                                        node.kind = "namespace";
                                        return this.tsParseModuleOrNamespaceDeclaration(node);
                                    }
                                    break;
                                case "type":
                                    if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                                        return this.tsParseTypeAliasDeclaration(node);
                                    }
                                    break;
                            }
                        }
                    },
                    {
                        key: "tsCheckLineTerminator",
                        value: function tsCheckLineTerminator(next) {
                            if (next) {
                                if (this.hasFollowingLineBreak()) return false;
                                this.next();
                                return true;
                            }
                            return !this.isLineTerminator();
                        }
                    },
                    {
                        key: "tsTryParseGenericAsyncArrowFunction",
                        value: function tsTryParseGenericAsyncArrowFunction(startLoc) {
                            var _this = this;
                            if (!this.match(47)) return;
                            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                            this.state.maybeInArrowParameters = true;
                            var res = this.tsTryParseAndCatch(function() {
                                var node = _this.startNodeAt(startLoc);
                                node.typeParameters = _this.tsParseTypeParameters(_this.tsParseConstModifier);
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionParams", _this).call(_this, node);
                                node.returnType = _this.tsTryParseTypeOrTypePredicateAnnotation();
                                _this.expect(19);
                                return node;
                            });
                            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                            if (!res) return;
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseArrowExpression", this).call(this, res, null, true);
                        }
                    },
                    {
                        key: "tsParseTypeArgumentsInExpression",
                        value: function tsParseTypeArgumentsInExpression() {
                            if (this.reScan_lt() !== 47) return;
                            return this.tsParseTypeArguments();
                        }
                    },
                    {
                        key: "tsParseTypeArguments",
                        value: function tsParseTypeArguments() {
                            var _this = this;
                            var node = this.startNode();
                            node.params = this.tsInType(function() {
                                return _this.tsInNoContext(function() {
                                    _this.expect(47);
                                    return _this.tsParseDelimitedList("TypeParametersOrArguments", _this.tsParseType.bind(_this));
                                });
                            });
                            if (node.params.length === 0) {
                                this.raise(TSErrors.EmptyTypeArguments, node);
                            } else if (!this.state.inType && this.curContext() === types.brace) {
                                this.reScan_lt_gt();
                            }
                            this.expect(48);
                            return this.finishNode(node, "TSTypeParameterInstantiation");
                        }
                    },
                    {
                        key: "tsIsDeclarationStart",
                        value: function tsIsDeclarationStart() {
                            return tokenIsTSDeclarationStart(this.state.type);
                        }
                    },
                    {
                        key: "isExportDefaultSpecifier",
                        value: function isExportDefaultSpecifier() {
                            if (this.tsIsDeclarationStart()) return false;
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
                        }
                    },
                    {
                        key: "parseAssignableListItem",
                        value: function parseAssignableListItem(flags, decorators) {
                            var startLoc = this.state.startLoc;
                            var modified = {};
                            this.tsParseModifiers({
                                allowedModifiers: [
                                    "public",
                                    "private",
                                    "protected",
                                    "override",
                                    "readonly"
                                ]
                            }, modified);
                            var accessibility = modified.accessibility;
                            var override = modified.override;
                            var readonly = modified.readonly;
                            if (!(flags & 4) && (accessibility || readonly || override)) {
                                this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
                            }
                            var left = this.parseMaybeDefault();
                            if (flags & 2) {
                                this.parseFunctionParamType(left);
                            }
                            var elt = this.parseMaybeDefault(left.loc.start, left);
                            if (accessibility || readonly || override) {
                                var pp = this.startNodeAt(startLoc);
                                if (decorators.length) {
                                    pp.decorators = decorators;
                                }
                                if (accessibility) pp.accessibility = accessibility;
                                if (readonly) pp.readonly = readonly;
                                if (override) pp.override = override;
                                if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
                                    this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
                                }
                                pp.parameter = elt;
                                return this.finishNode(pp, "TSParameterProperty");
                            }
                            if (decorators.length) {
                                left.decorators = decorators;
                            }
                            return elt;
                        }
                    },
                    {
                        key: "isSimpleParameter",
                        value: function isSimpleParameter(node) {
                            return node.type === "TSParameterProperty" && _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isSimpleParameter", this).call(this, node.parameter) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isSimpleParameter", this).call(this, node);
                        }
                    },
                    {
                        key: "tsDisallowOptionalPattern",
                        value: function tsDisallowOptionalPattern(node) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = node.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var param = _step.value;
                                    if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
                                        this.raise(TSErrors.PatternIsOptional, param);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "setArrowFunctionParameters",
                        value: function setArrowFunctionParameters(node, params, trailingCommaLoc) {
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "setArrowFunctionParameters", this).call(this, node, params, trailingCommaLoc);
                            this.tsDisallowOptionalPattern(node);
                        }
                    },
                    {
                        key: "parseFunctionBodyAndFinish",
                        value: function parseFunctionBodyAndFinish(node, type) {
                            var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            if (this.match(14)) {
                                node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                            }
                            var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
                            if (bodilessType && !this.match(5) && this.isLineTerminator()) {
                                return this.finishNode(node, bodilessType);
                            }
                            if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
                                this.raise(TSErrors.DeclareFunctionHasImplementation, node);
                                if (node.declare) {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, bodilessType, isMethod);
                                }
                            }
                            this.tsDisallowOptionalPattern(node);
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
                        }
                    },
                    {
                        key: "registerFunctionStatementId",
                        value: function registerFunctionStatementId(node) {
                            if (!node.body && node.id) {
                                this.checkIdentifier(node.id, 1024);
                            } else {
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "registerFunctionStatementId", this).call(this, node);
                            }
                        }
                    },
                    {
                        key: "tsCheckForInvalidTypeCasts",
                        value: function tsCheckForInvalidTypeCasts(items) {
                            var _this = this;
                            items.forEach(function(node) {
                                if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
                                    _this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
                                }
                            });
                        }
                    },
                    {
                        key: "toReferencedList",
                        value: function toReferencedList(exprList, isInParens) {
                            this.tsCheckForInvalidTypeCasts(exprList);
                            return exprList;
                        }
                    },
                    {
                        key: "parseArrayLike",
                        value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
                            var node = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);
                            if (node.type === "ArrayExpression") {
                                this.tsCheckForInvalidTypeCasts(node.elements);
                            }
                            return node;
                        }
                    },
                    {
                        key: "parseSubscript",
                        value: function parseSubscript(base, startLoc, noCalls, state) {
                            var _this = this;
                            if (!this.hasPrecedingLineBreak() && this.match(35)) {
                                this.state.canStartJSXElement = false;
                                this.next();
                                var nonNullExpression = this.startNodeAt(startLoc);
                                nonNullExpression.expression = base;
                                return this.finishNode(nonNullExpression, "TSNonNullExpression");
                            }
                            var isOptionalCall = false;
                            if (this.match(18) && this.lookaheadCharCode() === 60) {
                                if (noCalls) {
                                    state.stop = true;
                                    return base;
                                }
                                state.optionalChainMember = isOptionalCall = true;
                                this.next();
                            }
                            if (this.match(47) || this.match(51)) {
                                var missingParenErrorLoc;
                                var result = this.tsTryParseAndCatch(function() {
                                    if (!noCalls && _this.atPossibleAsyncArrow(base)) {
                                        var asyncArrowFn = _this.tsTryParseGenericAsyncArrowFunction(startLoc);
                                        if (asyncArrowFn) {
                                            return asyncArrowFn;
                                        }
                                    }
                                    var typeArguments = _this.tsParseTypeArgumentsInExpression();
                                    if (!typeArguments) return;
                                    if (isOptionalCall && !_this.match(10)) {
                                        missingParenErrorLoc = _this.state.curPosition();
                                        return;
                                    }
                                    if (tokenIsTemplate(_this.state.type)) {
                                        var _result = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseTaggedTemplateExpression", _this).call(_this, base, startLoc, state);
                                        _result.typeParameters = typeArguments;
                                        return _result;
                                    }
                                    if (!noCalls && _this.eat(10)) {
                                        var _node11 = _this.startNodeAt(startLoc);
                                        _node11.callee = base;
                                        _node11.arguments = _this.parseCallExpressionArguments(11);
                                        _this.tsCheckForInvalidTypeCasts(_node11.arguments);
                                        _node11.typeParameters = typeArguments;
                                        if (state.optionalChainMember) {
                                            _node11.optional = isOptionalCall;
                                        }
                                        return _this.finishCallExpression(_node11, state.optionalChainMember);
                                    }
                                    var tokenType = _this.state.type;
                                    if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !_this.hasPrecedingLineBreak()) {
                                        return;
                                    }
                                    var node = _this.startNodeAt(startLoc);
                                    node.expression = base;
                                    node.typeParameters = typeArguments;
                                    return _this.finishNode(node, "TSInstantiationExpression");
                                });
                                if (missingParenErrorLoc) {
                                    this.unexpected(missingParenErrorLoc, 10);
                                }
                                if (result) {
                                    if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                                        this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
                                    }
                                    return result;
                                }
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, state);
                        }
                    },
                    {
                        key: "parseNewCallee",
                        value: function parseNewCallee(node) {
                            var _callee$extra;
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseNewCallee", this).call(this, node);
                            var callee = node.callee;
                            if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
                                node.typeParameters = callee.typeParameters;
                                node.callee = callee.expression;
                            }
                        }
                    },
                    {
                        key: "parseExprOp",
                        value: function parseExprOp(left, leftStartLoc, minPrec) {
                            var _this = this;
                            var isSatisfies;
                            if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
                                var node = this.startNodeAt(leftStartLoc);
                                node.expression = left;
                                node.typeAnnotation = this.tsInType(function() {
                                    _this.next();
                                    if (_this.match(75)) {
                                        if (isSatisfies) {
                                            _this.raise(Errors.UnexpectedKeyword, _this.state.startLoc, {
                                                keyword: "const"
                                            });
                                        }
                                        return _this.tsParseTypeReference();
                                    }
                                    return _this.tsParseType();
                                });
                                this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
                                this.reScan_lt_gt();
                                return this.parseExprOp(node, leftStartLoc, minPrec);
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprOp", this).call(this, left, leftStartLoc, minPrec);
                        }
                    },
                    {
                        key: "checkReservedWord",
                        value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
                            if (!this.state.isAmbientContext) {
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding);
                            }
                        }
                    },
                    {
                        key: "checkImportReflection",
                        value: function checkImportReflection(node) {
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkImportReflection", this).call(this, node);
                            if (node.module && node.importKind !== "value") {
                                this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
                            }
                        }
                    },
                    {
                        key: "checkDuplicateExports",
                        value: function checkDuplicateExports() {}
                    },
                    {
                        key: "isPotentialImportPhase",
                        value: function isPotentialImportPhase(isExport) {
                            if (_get(_get_prototype_of(TypeScriptParserMixin.prototype), "isPotentialImportPhase", this).call(this, isExport)) return true;
                            if (this.isContextual(130)) {
                                var ch = this.lookaheadCharCode();
                                return isExport ? ch === 123 || ch === 42 : ch !== 61;
                            }
                            return !isExport && this.isContextual(87);
                        }
                    },
                    {
                        key: "applyImportPhase",
                        value: function applyImportPhase(node, isExport, phase, loc) {
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "applyImportPhase", this).call(this, node, isExport, phase, loc);
                            if (isExport) {
                                node.exportKind = phase === "type" ? "type" : "value";
                            } else {
                                node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
                            }
                        }
                    },
                    {
                        key: "parseImport",
                        value: function parseImport(node) {
                            if (this.match(134)) {
                                node.importKind = "value";
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImport", this).call(this, node);
                            }
                            var importNode;
                            if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
                                node.importKind = "value";
                                return this.tsParseImportEqualsDeclaration(node);
                            } else if (this.isContextual(130)) {
                                var maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
                                if (this.lookaheadCharCode() === 61) {
                                    return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
                                } else {
                                    importNode = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImportSpecifiersAndAfter", this).call(this, node, maybeDefaultIdentifier);
                                }
                            } else {
                                importNode = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImport", this).call(this, node);
                            }
                            if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
                                this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
                            }
                            return importNode;
                        }
                    },
                    {
                        key: "parseExport",
                        value: function parseExport(node, decorators) {
                            if (this.match(83)) {
                                this.next();
                                var nodeImportEquals = node;
                                var maybeDefaultIdentifier = null;
                                if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
                                    maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
                                } else {
                                    nodeImportEquals.importKind = "value";
                                }
                                return this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
                            } else if (this.eat(29)) {
                                var assign = node;
                                assign.expression = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExpression", this).call(this);
                                this.semicolon();
                                this.sawUnambiguousESM = true;
                                return this.finishNode(assign, "TSExportAssignment");
                            } else if (this.eatContextual(93)) {
                                var decl = node;
                                this.expectContextual(128);
                                decl.id = this.parseIdentifier();
                                this.semicolon();
                                return this.finishNode(decl, "TSNamespaceExportDeclaration");
                            } else {
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExport", this).call(this, node, decorators);
                            }
                        }
                    },
                    {
                        key: "isAbstractClass",
                        value: function isAbstractClass() {
                            return this.isContextual(124) && this.lookahead().type === 80;
                        }
                    },
                    {
                        key: "parseExportDefaultExpression",
                        value: function parseExportDefaultExpression() {
                            if (this.isAbstractClass()) {
                                var cls = this.startNode();
                                this.next();
                                cls.abstract = true;
                                return this.parseClass(cls, true, true);
                            }
                            if (this.match(129)) {
                                var result = this.tsParseInterfaceDeclaration(this.startNode());
                                if (result) return result;
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExportDefaultExpression", this).call(this);
                        }
                    },
                    {
                        key: "parseVarStatement",
                        value: function parseVarStatement(node, kind) {
                            var allowMissingInitializer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            var isAmbientContext = this.state.isAmbientContext;
                            var declaration = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseVarStatement", this).call(this, node, kind, allowMissingInitializer || isAmbientContext);
                            if (!isAmbientContext) return declaration;
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = declaration.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var _step_value = _step.value, id = _step_value.id, init = _step_value.init;
                                    if (!init) continue;
                                    if (kind !== "const" || !!id.typeAnnotation) {
                                        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
                                    } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
                                        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            return declaration;
                        }
                    },
                    {
                        key: "parseStatementContent",
                        value: function parseStatementContent(flags, decorators) {
                            if (this.match(75) && this.isLookaheadContextual("enum")) {
                                var node = this.startNode();
                                this.expect(75);
                                return this.tsParseEnumDeclaration(node, {
                                    const: true
                                });
                            }
                            if (this.isContextual(126)) {
                                return this.tsParseEnumDeclaration(this.startNode());
                            }
                            if (this.isContextual(129)) {
                                var result = this.tsParseInterfaceDeclaration(this.startNode());
                                if (result) return result;
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseStatementContent", this).call(this, flags, decorators);
                        }
                    },
                    {
                        key: "parseAccessModifier",
                        value: function parseAccessModifier() {
                            return this.tsParseModifier([
                                "public",
                                "protected",
                                "private"
                            ]);
                        }
                    },
                    {
                        key: "tsHasSomeModifiers",
                        value: function tsHasSomeModifiers(member, modifiers) {
                            return modifiers.some(function(modifier) {
                                if (tsIsAccessModifier(modifier)) {
                                    return member.accessibility === modifier;
                                }
                                return !!member[modifier];
                            });
                        }
                    },
                    {
                        key: "tsIsStartOfStaticBlocks",
                        value: function tsIsStartOfStaticBlocks() {
                            return this.isContextual(106) && this.lookaheadCharCode() === 123;
                        }
                    },
                    {
                        key: "parseClassMember",
                        value: function parseClassMember(classBody, member, state) {
                            var _this = this;
                            var modifiers = [
                                "declare",
                                "private",
                                "public",
                                "protected",
                                "override",
                                "abstract",
                                "readonly",
                                "static"
                            ];
                            this.tsParseModifiers({
                                allowedModifiers: modifiers,
                                disallowedModifiers: [
                                    "in",
                                    "out"
                                ],
                                stopOnStartOfClassStaticBlock: true,
                                errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
                            }, member);
                            var callParseClassMemberWithIsStatic = function() {
                                if (_this.tsIsStartOfStaticBlocks()) {
                                    _this.next();
                                    _this.next();
                                    if (_this.tsHasSomeModifiers(member, modifiers)) {
                                        _this.raise(TSErrors.StaticBlockCannotHaveModifier, _this.state.curPosition());
                                    }
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassStaticBlock", _this).call(_this, classBody, member);
                                } else {
                                    _this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
                                }
                            };
                            if (member.declare) {
                                this.tsInAmbientContext(callParseClassMemberWithIsStatic);
                            } else {
                                callParseClassMemberWithIsStatic();
                            }
                        }
                    },
                    {
                        key: "parseClassMemberWithIsStatic",
                        value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
                            var idx = this.tsTryParseIndexSignature(member);
                            if (idx) {
                                classBody.body.push(idx);
                                if (member.abstract) {
                                    this.raise(TSErrors.IndexSignatureHasAbstract, member);
                                }
                                if (member.accessibility) {
                                    this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
                                        modifier: member.accessibility
                                    });
                                }
                                if (member.declare) {
                                    this.raise(TSErrors.IndexSignatureHasDeclare, member);
                                }
                                if (member.override) {
                                    this.raise(TSErrors.IndexSignatureHasOverride, member);
                                }
                                return;
                            }
                            if (!this.state.inAbstractClass && member.abstract) {
                                this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
                            }
                            if (member.override) {
                                if (!state.hadSuperClass) {
                                    this.raise(TSErrors.OverrideNotInSubClass, member);
                                }
                            }
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassMemberWithIsStatic", this).call(this, classBody, member, state, isStatic);
                        }
                    },
                    {
                        key: "parsePostMemberNameModifiers",
                        value: function parsePostMemberNameModifiers(methodOrProp) {
                            var optional = this.eat(17);
                            if (optional) methodOrProp.optional = true;
                            if (methodOrProp.readonly && this.match(10)) {
                                this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
                            }
                            if (methodOrProp.declare && this.match(10)) {
                                this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
                            }
                        }
                    },
                    {
                        key: "parseExpressionStatement",
                        value: function parseExpressionStatement(node, expr, decorators) {
                            var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
                            return decl || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr, decorators);
                        }
                    },
                    {
                        key: "shouldParseExportDeclaration",
                        value: function shouldParseExportDeclaration() {
                            if (this.tsIsDeclarationStart()) return true;
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "shouldParseExportDeclaration", this).call(this);
                        }
                    },
                    {
                        key: "parseConditional",
                        value: function parseConditional(expr, startLoc, refExpressionErrors) {
                            var _this = this;
                            if (!this.state.maybeInArrowParameters || !this.match(17)) {
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseConditional", this).call(this, expr, startLoc, refExpressionErrors);
                            }
                            var result = this.tryParse(function() {
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseConditional", _this).call(_this, expr, startLoc);
                            });
                            if (!result.node) {
                                if (result.error) {
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "setOptionalParametersError", this).call(this, refExpressionErrors, result.error);
                                }
                                return expr;
                            }
                            if (result.error) this.state = result.failState;
                            return result.node;
                        }
                    },
                    {
                        key: "parseParenItem",
                        value: function parseParenItem(node, startLoc) {
                            var newNode = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseParenItem", this).call(this, node, startLoc);
                            if (this.eat(17)) {
                                newNode.optional = true;
                                this.resetEndLocation(node);
                            }
                            if (this.match(14)) {
                                var typeCastNode = this.startNodeAt(startLoc);
                                typeCastNode.expression = node;
                                typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
                                return this.finishNode(typeCastNode, "TSTypeCastExpression");
                            }
                            return node;
                        }
                    },
                    {
                        key: "parseExportDeclaration",
                        value: function parseExportDeclaration(node) {
                            var _this = this;
                            if (!this.state.isAmbientContext && this.isContextual(125)) {
                                return this.tsInAmbientContext(function() {
                                    return _this.parseExportDeclaration(node);
                                });
                            }
                            var startLoc = this.state.startLoc;
                            var isDeclare = this.eatContextual(125);
                            if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
                                throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
                            }
                            var isIdentifier2 = tokenIsIdentifier(this.state.type);
                            var declaration = isIdentifier2 && this.tsTryParseExportDeclaration() || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExportDeclaration", this).call(this, node);
                            if (!declaration) return null;
                            if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
                                node.exportKind = "type";
                            }
                            if (isDeclare) {
                                this.resetStartLocation(declaration, startLoc);
                                declaration.declare = true;
                            }
                            return declaration;
                        }
                    },
                    {
                        key: "parseClassId",
                        value: function parseClassId(node, isStatement, optionalId, bindingType) {
                            if ((!isStatement || optionalId) && this.isContextual(113)) {
                                return;
                            }
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassId", this).call(this, node, isStatement, optionalId, node.declare ? 1024 : 8331);
                            var typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                            if (typeParameters) node.typeParameters = typeParameters;
                        }
                    },
                    {
                        key: "parseClassPropertyAnnotation",
                        value: function parseClassPropertyAnnotation(node) {
                            if (!node.optional) {
                                if (this.eat(35)) {
                                    node.definite = true;
                                } else if (this.eat(17)) {
                                    node.optional = true;
                                }
                            }
                            var type = this.tsTryParseTypeAnnotation();
                            if (type) node.typeAnnotation = type;
                        }
                    },
                    {
                        key: "parseClassProperty",
                        value: function parseClassProperty(node) {
                            this.parseClassPropertyAnnotation(node);
                            if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
                                this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
                            }
                            if (node.abstract && this.match(29)) {
                                var key2 = node.key;
                                this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
                                    propertyName: key2.type === "Identifier" && !node.computed ? key2.name : "[".concat(this.input.slice(this.offsetToSourcePos(key2.start), this.offsetToSourcePos(key2.end)), "]")
                                });
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassProperty", this).call(this, node);
                        }
                    },
                    {
                        key: "parseClassPrivateProperty",
                        value: function parseClassPrivateProperty(node) {
                            if (node.abstract) {
                                this.raise(TSErrors.PrivateElementHasAbstract, node);
                            }
                            if (node.accessibility) {
                                this.raise(TSErrors.PrivateElementHasAccessibility, node, {
                                    modifier: node.accessibility
                                });
                            }
                            this.parseClassPropertyAnnotation(node);
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassPrivateProperty", this).call(this, node);
                        }
                    },
                    {
                        key: "parseClassAccessorProperty",
                        value: function parseClassAccessorProperty(node) {
                            this.parseClassPropertyAnnotation(node);
                            if (node.optional) {
                                this.raise(TSErrors.AccessorCannotBeOptional, node);
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassAccessorProperty", this).call(this, node);
                        }
                    },
                    {
                        key: "pushClassMethod",
                        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                            var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                            if (typeParameters && isConstructor) {
                                this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
                            }
                            var _method_declare = method.declare, declare = _method_declare === void 0 ? false : _method_declare, kind = method.kind;
                            if (declare && (kind === "get" || kind === "set")) {
                                this.raise(TSErrors.DeclareAccessor, method, {
                                    kind: kind
                                });
                            }
                            if (typeParameters) method.typeParameters = typeParameters;
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
                        }
                    },
                    {
                        key: "pushClassPrivateMethod",
                        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
                            var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                            if (typeParameters) method.typeParameters = typeParameters;
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
                        }
                    },
                    {
                        key: "declareClassPrivateMethodInScope",
                        value: function declareClassPrivateMethodInScope(node, kind) {
                            if (node.type === "TSDeclareMethod") return;
                            if (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body")) {
                                return;
                            }
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "declareClassPrivateMethodInScope", this).call(this, node, kind);
                        }
                    },
                    {
                        key: "parseClassSuper",
                        value: function parseClassSuper(node) {
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassSuper", this).call(this, node);
                            if (node.superClass && (this.match(47) || this.match(51))) {
                                node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
                            }
                            if (this.eatContextual(113)) {
                                node.implements = this.tsParseHeritageClause("implements");
                            }
                        }
                    },
                    {
                        key: "parseObjPropValue",
                        value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
                            var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                            if (typeParameters) prop.typeParameters = typeParameters;
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseObjPropValue", this).call(this, prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
                        }
                    },
                    {
                        key: "parseFunctionParams",
                        value: function parseFunctionParams(node, isConstructor) {
                            var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                            if (typeParameters) node.typeParameters = typeParameters;
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionParams", this).call(this, node, isConstructor);
                        }
                    },
                    {
                        key: "parseVarId",
                        value: function parseVarId(decl, kind) {
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseVarId", this).call(this, decl, kind);
                            if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
                                decl.definite = true;
                            }
                            var type = this.tsTryParseTypeAnnotation();
                            if (type) {
                                decl.id.typeAnnotation = type;
                                this.resetEndLocation(decl.id);
                            }
                        }
                    },
                    {
                        key: "parseAsyncArrowFromCallExpression",
                        value: function parseAsyncArrowFromCallExpression(node, call) {
                            if (this.match(14)) {
                                node.returnType = this.tsParseTypeAnnotation();
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
                        }
                    },
                    {
                        key: "parseMaybeAssign",
                        value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
                            var _this = this;
                            var _jsx104, _jsx210, _typeCast, _jsx310, _typeCast2;
                            var state;
                            var jsx2;
                            var typeCast;
                            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
                                state = this.state.clone();
                                jsx2 = this.tryParse(function() {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                }, state);
                                if (!jsx2.error) return jsx2.node;
                                var context = this.state.context;
                                var currentContext = context[context.length - 1];
                                if (currentContext === types.j_oTag || currentContext === types.j_expr) {
                                    context.pop();
                                }
                            }
                            if (!((_jsx104 = jsx2) != null && _jsx104.error) && !this.match(47)) {
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
                            }
                            if (!state || state === this.state) state = this.state.clone();
                            var typeParameters;
                            var arrow = this.tryParse(function(abort) {
                                var _expr$extra, _typeParameters;
                                typeParameters = _this.tsParseTypeParameters(_this.tsParseConstModifier);
                                var expr = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
                                    abort();
                                }
                                if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
                                    _this.resetStartLocationFromNode(expr, typeParameters);
                                }
                                expr.typeParameters = typeParameters;
                                return expr;
                            }, state);
                            if (!arrow.error && !arrow.aborted) {
                                if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                                return arrow.node;
                            }
                            if (!jsx2) {
                                assert(!this.hasPlugin("jsx"));
                                typeCast = this.tryParse(function() {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                }, state);
                                if (!typeCast.error) return typeCast.node;
                            }
                            if ((_jsx210 = jsx2) != null && _jsx210.node) {
                                this.state = jsx2.failState;
                                return jsx2.node;
                            }
                            if (arrow.node) {
                                this.state = arrow.failState;
                                if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                                return arrow.node;
                            }
                            if ((_typeCast = typeCast) != null && _typeCast.node) {
                                this.state = typeCast.failState;
                                return typeCast.node;
                            }
                            throw ((_jsx310 = jsx2) == null ? void 0 : _jsx310.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
                        }
                    },
                    {
                        key: "reportReservedArrowTypeParam",
                        value: function reportReservedArrowTypeParam(node) {
                            var _node$extra;
                            if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                                this.raise(TSErrors.ReservedArrowTypeParam, node);
                            }
                        }
                    },
                    {
                        key: "parseMaybeUnary",
                        value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
                            if (!this.hasPlugin("jsx") && this.match(47)) {
                                return this.tsParseTypeAssertion();
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeUnary", this).call(this, refExpressionErrors, sawUnary);
                        }
                    },
                    {
                        key: "parseArrow",
                        value: function parseArrow(node) {
                            var _this = this;
                            if (this.match(14)) {
                                var result = this.tryParse(function(abort) {
                                    var returnType = _this.tsParseTypeOrTypePredicateAnnotation(14);
                                    if (_this.canInsertSemicolon() || !_this.match(19)) abort();
                                    return returnType;
                                });
                                if (result.aborted) return;
                                if (!result.thrown) {
                                    if (result.error) this.state = result.failState;
                                    node.returnType = result.node;
                                }
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseArrow", this).call(this, node);
                        }
                    },
                    {
                        key: "parseFunctionParamType",
                        value: function parseFunctionParamType(param) {
                            if (this.eat(17)) {
                                param.optional = true;
                            }
                            var type = this.tsTryParseTypeAnnotation();
                            if (type) param.typeAnnotation = type;
                            this.resetEndLocation(param);
                            return param;
                        }
                    },
                    {
                        key: "isAssignable",
                        value: function isAssignable(node, isBinding) {
                            switch(node.type){
                                case "TSTypeCastExpression":
                                    return this.isAssignable(node.expression, isBinding);
                                case "TSParameterProperty":
                                    return true;
                                default:
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
                            }
                        }
                    },
                    {
                        key: "toAssignable",
                        value: function toAssignable(node) {
                            var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                            switch(node.type){
                                case "ParenthesizedExpression":
                                    this.toAssignableParenthesizedExpression(node, isLHS);
                                    break;
                                case "TSAsExpression":
                                case "TSSatisfiesExpression":
                                case "TSNonNullExpression":
                                case "TSTypeAssertion":
                                    if (isLHS) {
                                        this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
                                    } else {
                                        this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
                                    }
                                    this.toAssignable(node.expression, isLHS);
                                    break;
                                case "AssignmentExpression":
                                    if (!isLHS && node.left.type === "TSTypeCastExpression") {
                                        node.left = this.typeCastToParameter(node.left);
                                    }
                                default:
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                            }
                        }
                    },
                    {
                        key: "toAssignableParenthesizedExpression",
                        value: function toAssignableParenthesizedExpression(node, isLHS) {
                            switch(node.expression.type){
                                case "TSAsExpression":
                                case "TSSatisfiesExpression":
                                case "TSNonNullExpression":
                                case "TSTypeAssertion":
                                case "ParenthesizedExpression":
                                    this.toAssignable(node.expression, isLHS);
                                    break;
                                default:
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                            }
                        }
                    },
                    {
                        key: "checkToRestConversion",
                        value: function checkToRestConversion(node, allowPattern) {
                            switch(node.type){
                                case "TSAsExpression":
                                case "TSSatisfiesExpression":
                                case "TSTypeAssertion":
                                case "TSNonNullExpression":
                                    this.checkToRestConversion(node.expression, false);
                                    break;
                                default:
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkToRestConversion", this).call(this, node, allowPattern);
                            }
                        }
                    },
                    {
                        key: "isValidLVal",
                        value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
                            switch(type){
                                case "TSTypeCastExpression":
                                    return true;
                                case "TSParameterProperty":
                                    return "parameter";
                                case "TSNonNullExpression":
                                case "TSInstantiationExpression":
                                    return "expression";
                                case "TSAsExpression":
                                case "TSSatisfiesExpression":
                                case "TSTypeAssertion":
                                    return (binding !== 64 || !isUnparenthesizedInAssign) && [
                                        "expression",
                                        true
                                    ];
                                default:
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isValidLVal", this).call(this, type, isUnparenthesizedInAssign, binding);
                            }
                        }
                    },
                    {
                        key: "parseBindingAtom",
                        value: function parseBindingAtom() {
                            if (this.state.type === 78) {
                                return this.parseIdentifier(true);
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBindingAtom", this).call(this);
                        }
                    },
                    {
                        key: "parseMaybeDecoratorArguments",
                        value: function parseMaybeDecoratorArguments(expr) {
                            if (this.match(47) || this.match(51)) {
                                var typeArguments = this.tsParseTypeArgumentsInExpression();
                                if (this.match(10)) {
                                    var call = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
                                    call.typeParameters = typeArguments;
                                    return call;
                                }
                                this.unexpected(null, 10);
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
                        }
                    },
                    {
                        key: "checkCommaAfterRest",
                        value: function checkCommaAfterRest(close) {
                            if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
                                this.next();
                                return false;
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkCommaAfterRest", this).call(this, close);
                        }
                    },
                    {
                        key: "isClassMethod",
                        value: function isClassMethod() {
                            return this.match(47) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isClassMethod", this).call(this);
                        }
                    },
                    {
                        key: "isClassProperty",
                        value: function isClassProperty() {
                            return this.match(35) || this.match(14) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isClassProperty", this).call(this);
                        }
                    },
                    {
                        key: "parseMaybeDefault",
                        value: function parseMaybeDefault(startLoc, left) {
                            var node = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeDefault", this).call(this, startLoc, left);
                            if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
                                this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
                            }
                            return node;
                        }
                    },
                    {
                        key: "getTokenFromCode",
                        value: function getTokenFromCode(code2) {
                            if (this.state.inType) {
                                if (code2 === 62) {
                                    this.finishOp(48, 1);
                                    return;
                                }
                                if (code2 === 60) {
                                    this.finishOp(47, 1);
                                    return;
                                }
                            }
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                        }
                    },
                    {
                        key: "reScan_lt_gt",
                        value: function reScan_lt_gt() {
                            var type = this.state.type;
                            if (type === 47) {
                                this.state.pos -= 1;
                                this.readToken_lt();
                            } else if (type === 48) {
                                this.state.pos -= 1;
                                this.readToken_gt();
                            }
                        }
                    },
                    {
                        key: "reScan_lt",
                        value: function reScan_lt() {
                            var type = this.state.type;
                            if (type === 51) {
                                this.state.pos -= 2;
                                this.finishOp(47, 1);
                                return 47;
                            }
                            return type;
                        }
                    },
                    {
                        key: "toAssignableList",
                        value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
                            for(var i = 0; i < exprList.length; i++){
                                var expr = exprList[i];
                                if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
                                    exprList[i] = this.typeCastToParameter(expr);
                                }
                            }
                            _get(_get_prototype_of(TypeScriptParserMixin.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
                        }
                    },
                    {
                        key: "typeCastToParameter",
                        value: function typeCastToParameter(node) {
                            node.expression.typeAnnotation = node.typeAnnotation;
                            this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
                            return node.expression;
                        }
                    },
                    {
                        key: "shouldParseArrow",
                        value: function shouldParseArrow(params) {
                            var _this = this;
                            if (this.match(14)) {
                                return params.every(function(expr) {
                                    return _this.isAssignable(expr, true);
                                });
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "shouldParseArrow", this).call(this, params);
                        }
                    },
                    {
                        key: "shouldParseAsyncArrow",
                        value: function shouldParseAsyncArrow() {
                            return this.match(14) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "shouldParseAsyncArrow", this).call(this);
                        }
                    },
                    {
                        key: "canHaveLeadingDecorator",
                        value: function canHaveLeadingDecorator() {
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass();
                        }
                    },
                    {
                        key: "jsxParseOpeningElementAfterName",
                        value: function jsxParseOpeningElementAfterName(node) {
                            var _this = this;
                            if (this.match(47) || this.match(51)) {
                                var typeArguments = this.tsTryParseAndCatch(function() {
                                    return _this.tsParseTypeArgumentsInExpression();
                                });
                                if (typeArguments) node.typeParameters = typeArguments;
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "jsxParseOpeningElementAfterName", this).call(this, node);
                        }
                    },
                    {
                        key: "getGetterSetterExpectedParamCount",
                        value: function getGetterSetterExpectedParamCount(method) {
                            var baseCount = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "getGetterSetterExpectedParamCount", this).call(this, method);
                            var params = this.getObjectOrClassMethodParams(method);
                            var firstParam = params[0];
                            var hasContextParam = firstParam && this.isThisParam(firstParam);
                            return hasContextParam ? baseCount + 1 : baseCount;
                        }
                    },
                    {
                        key: "parseCatchClauseParam",
                        value: function parseCatchClauseParam() {
                            var param = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseCatchClauseParam", this).call(this);
                            var type = this.tsTryParseTypeAnnotation();
                            if (type) {
                                param.typeAnnotation = type;
                                this.resetEndLocation(param);
                            }
                            return param;
                        }
                    },
                    {
                        key: "tsInAmbientContext",
                        value: function tsInAmbientContext(cb) {
                            var _this_state = this.state, oldIsAmbientContext = _this_state.isAmbientContext, oldStrict = _this_state.strict;
                            this.state.isAmbientContext = true;
                            this.state.strict = false;
                            try {
                                return cb();
                            } finally{
                                this.state.isAmbientContext = oldIsAmbientContext;
                                this.state.strict = oldStrict;
                            }
                        }
                    },
                    {
                        key: "parseClass",
                        value: function parseClass(node, isStatement, optionalId) {
                            var oldInAbstractClass = this.state.inAbstractClass;
                            this.state.inAbstractClass = !!node.abstract;
                            try {
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClass", this).call(this, node, isStatement, optionalId);
                            } finally{
                                this.state.inAbstractClass = oldInAbstractClass;
                            }
                        }
                    },
                    {
                        key: "tsParseAbstractDeclaration",
                        value: function tsParseAbstractDeclaration(node, decorators) {
                            if (this.match(80)) {
                                node.abstract = true;
                                return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
                            } else if (this.isContextual(129)) {
                                if (!this.hasFollowingLineBreak()) {
                                    node.abstract = true;
                                    this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);
                                    return this.tsParseInterfaceDeclaration(node);
                                }
                            } else {
                                this.unexpected(null, 80);
                            }
                        }
                    },
                    {
                        key: "parseMethod",
                        value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
                            var method = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMethod", this).call(this, node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
                            if (method.abstract) {
                                var hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
                                if (hasBody) {
                                    var key2 = method.key;
                                    this.raise(TSErrors.AbstractMethodHasImplementation, method, {
                                        methodName: key2.type === "Identifier" && !method.computed ? key2.name : "[".concat(this.input.slice(this.offsetToSourcePos(key2.start), this.offsetToSourcePos(key2.end)), "]")
                                    });
                                }
                            }
                            return method;
                        }
                    },
                    {
                        key: "tsParseTypeParameterName",
                        value: function tsParseTypeParameterName() {
                            var typeName = this.parseIdentifier();
                            return typeName.name;
                        }
                    },
                    {
                        key: "shouldParseAsAmbientContext",
                        value: function shouldParseAsAmbientContext() {
                            return !!this.getPluginOption("typescript", "dts");
                        }
                    },
                    {
                        key: "parse",
                        value: function parse() {
                            if (this.shouldParseAsAmbientContext()) {
                                this.state.isAmbientContext = true;
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parse", this).call(this);
                        }
                    },
                    {
                        key: "getExpression",
                        value: function getExpression() {
                            if (this.shouldParseAsAmbientContext()) {
                                this.state.isAmbientContext = true;
                            }
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "getExpression", this).call(this);
                        }
                    },
                    {
                        key: "parseExportSpecifier",
                        value: function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
                            if (!isString && isMaybeTypeOnly) {
                                this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
                                return this.finishNode(node, "ExportSpecifier");
                            }
                            node.exportKind = "value";
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExportSpecifier", this).call(this, node, isString, isInTypeExport, isMaybeTypeOnly);
                        }
                    },
                    {
                        key: "parseImportSpecifier",
                        value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
                            if (!importedIsString && isMaybeTypeOnly) {
                                this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
                                return this.finishNode(specifier, "ImportSpecifier");
                            }
                            specifier.importKind = "value";
                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImportSpecifier", this).call(this, specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
                        }
                    },
                    {
                        key: "parseTypeOnlyImportExportSpecifier",
                        value: function parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
                            var leftOfAsKey = isImport ? "imported" : "local";
                            var rightOfAsKey = isImport ? "local" : "exported";
                            var leftOfAs = node[leftOfAsKey];
                            var rightOfAs;
                            var hasTypeSpecifier = false;
                            var canParseAsKeyword = true;
                            var loc = leftOfAs.loc.start;
                            if (this.isContextual(93)) {
                                var firstAs = this.parseIdentifier();
                                if (this.isContextual(93)) {
                                    var secondAs = this.parseIdentifier();
                                    if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                        hasTypeSpecifier = true;
                                        leftOfAs = firstAs;
                                        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                                        canParseAsKeyword = false;
                                    } else {
                                        rightOfAs = secondAs;
                                        canParseAsKeyword = false;
                                    }
                                } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                    canParseAsKeyword = false;
                                    rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                                } else {
                                    hasTypeSpecifier = true;
                                    leftOfAs = firstAs;
                                }
                            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                hasTypeSpecifier = true;
                                if (isImport) {
                                    leftOfAs = this.parseIdentifier(true);
                                    if (!this.isContextual(93)) {
                                        this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
                                    }
                                } else {
                                    leftOfAs = this.parseModuleExportName();
                                }
                            }
                            if (hasTypeSpecifier && isInTypeOnlyImportExport) {
                                this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
                            }
                            node[leftOfAsKey] = leftOfAs;
                            node[rightOfAsKey] = rightOfAs;
                            var kindKey = isImport ? "importKind" : "exportKind";
                            node[kindKey] = hasTypeSpecifier ? "type" : "value";
                            if (canParseAsKeyword && this.eatContextual(93)) {
                                node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                            }
                            if (!node[rightOfAsKey]) {
                                node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
                            }
                            if (isImport) {
                                this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
                            }
                        }
                    }
                ]);
                return TypeScriptParserMixin;
            }(superClass);
            return TypeScriptParserMixin;
        };
        function isPossiblyLiteralEnum(expression) {
            if (expression.type !== "MemberExpression") return false;
            var computed = expression.computed, property = expression.property;
            if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
                return false;
            }
            return isUncomputedMemberExpressionChain(expression.object);
        }
        function isValidAmbientConstInitializer(expression, estree2) {
            var _expression$extra;
            var type = expression.type;
            if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
                return false;
            }
            if (estree2) {
                if (type === "Literal") {
                    var value = expression.value;
                    if (typeof value === "string" || typeof value === "boolean") {
                        return true;
                    }
                }
            } else {
                if (type === "StringLiteral" || type === "BooleanLiteral") {
                    return true;
                }
            }
            if (isNumber2(expression, estree2) || isNegativeNumber(expression, estree2)) {
                return true;
            }
            if (type === "TemplateLiteral" && expression.expressions.length === 0) {
                return true;
            }
            if (isPossiblyLiteralEnum(expression)) {
                return true;
            }
            return false;
        }
        function isNumber2(expression, estree2) {
            if (estree2) {
                return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
            }
            return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
        }
        function isNegativeNumber(expression, estree2) {
            if (expression.type === "UnaryExpression") {
                var operator = expression.operator, argument = expression.argument;
                if (operator === "-" && isNumber2(argument, estree2)) {
                    return true;
                }
            }
            return false;
        }
        function isUncomputedMemberExpressionChain(expression) {
            if (expression.type === "Identifier") return true;
            if (expression.type !== "MemberExpression" || expression.computed) {
                return false;
            }
            return isUncomputedMemberExpressionChain(expression.object);
        }
        var PlaceholderErrors = ParseErrorEnum(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([
            "placeholders"
        ])))({
            ClassNameIsRequired: "A class name is required.",
            UnexpectedSpace: "Unexpected space in placeholder."
        });
        var placeholders = function(superClass) {
            var PlaceholdersParserMixin = /*#__PURE__*/ function(superClass) {
                _inherits(PlaceholdersParserMixin, superClass);
                function PlaceholdersParserMixin() {
                    _class_call_check(this, PlaceholdersParserMixin);
                    return _call_super(this, PlaceholdersParserMixin, arguments);
                }
                _create_class(PlaceholdersParserMixin, [
                    {
                        key: "parsePlaceholder",
                        value: function parsePlaceholder(expectedNode) {
                            if (this.match(133)) {
                                var node = this.startNode();
                                this.next();
                                this.assertNoSpace();
                                node.name = _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseIdentifier", this).call(this, true);
                                this.assertNoSpace();
                                this.expect(133);
                                return this.finishPlaceholder(node, expectedNode);
                            }
                        }
                    },
                    {
                        key: "finishPlaceholder",
                        value: function finishPlaceholder(node, expectedNode) {
                            var placeholder = node;
                            if (!placeholder.expectedNode || !placeholder.type) {
                                placeholder = this.finishNode(placeholder, "Placeholder");
                            }
                            placeholder.expectedNode = expectedNode;
                            return placeholder;
                        }
                    },
                    {
                        key: "getTokenFromCode",
                        value: function getTokenFromCode(code2) {
                            if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
                                this.finishOp(133, 2);
                            } else {
                                _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                            }
                        }
                    },
                    {
                        key: "parseExprAtom",
                        value: function parseExprAtom(refExpressionErrors) {
                            return this.parsePlaceholder("Expression") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
                        }
                    },
                    {
                        key: "parseIdentifier",
                        value: function parseIdentifier(liberal) {
                            return this.parsePlaceholder("Identifier") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseIdentifier", this).call(this, liberal);
                        }
                    },
                    {
                        key: "checkReservedWord",
                        value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
                            if (word !== void 0) {
                                _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding);
                            }
                        }
                    },
                    {
                        key: "parseBindingAtom",
                        value: function parseBindingAtom() {
                            return this.parsePlaceholder("Pattern") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseBindingAtom", this).call(this);
                        }
                    },
                    {
                        key: "isValidLVal",
                        value: function isValidLVal(type, isParenthesized, binding) {
                            return type === "Placeholder" || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "isValidLVal", this).call(this, type, isParenthesized, binding);
                        }
                    },
                    {
                        key: "toAssignable",
                        value: function toAssignable(node, isLHS) {
                            if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
                                node.expectedNode = "Pattern";
                            } else {
                                _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                            }
                        }
                    },
                    {
                        key: "chStartsBindingIdentifier",
                        value: function chStartsBindingIdentifier(ch, pos) {
                            if (_get(_get_prototype_of(PlaceholdersParserMixin.prototype), "chStartsBindingIdentifier", this).call(this, ch, pos)) {
                                return true;
                            }
                            var nextToken = this.lookahead();
                            if (nextToken.type === 133) {
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "verifyBreakContinue",
                        value: function verifyBreakContinue(node, isBreak) {
                            if (node.label && node.label.type === "Placeholder") return;
                            _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "verifyBreakContinue", this).call(this, node, isBreak);
                        }
                    },
                    {
                        key: "parseExpressionStatement",
                        value: function parseExpressionStatement(node, expr) {
                            var _expr$extra;
                            if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
                                return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr);
                            }
                            if (this.match(14)) {
                                var stmt = node;
                                stmt.label = this.finishPlaceholder(expr, "Identifier");
                                this.next();
                                stmt.body = _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseStatementOrSloppyAnnexBFunctionDeclaration", this).call(this);
                                return this.finishNode(stmt, "LabeledStatement");
                            }
                            this.semicolon();
                            var stmtPlaceholder = node;
                            stmtPlaceholder.name = expr.name;
                            return this.finishPlaceholder(stmtPlaceholder, "Statement");
                        }
                    },
                    {
                        key: "parseBlock",
                        value: function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
                            return this.parsePlaceholder("BlockStatement") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseBlock", this).call(this, allowDirectives, createNewLexicalScope, afterBlockParse);
                        }
                    },
                    {
                        key: "parseFunctionId",
                        value: function parseFunctionId(requireId) {
                            return this.parsePlaceholder("Identifier") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseFunctionId", this).call(this, requireId);
                        }
                    },
                    {
                        key: "parseClass",
                        value: function parseClass(node, isStatement, optionalId) {
                            var type = isStatement ? "ClassDeclaration" : "ClassExpression";
                            this.next();
                            var oldStrict = this.state.strict;
                            var placeholder = this.parsePlaceholder("Identifier");
                            if (placeholder) {
                                if (this.match(81) || this.match(133) || this.match(5)) {
                                    node.id = placeholder;
                                } else if (optionalId || !isStatement) {
                                    node.id = null;
                                    node.body = this.finishPlaceholder(placeholder, "ClassBody");
                                    return this.finishNode(node, type);
                                } else {
                                    throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
                                }
                            } else {
                                this.parseClassId(node, isStatement, optionalId);
                            }
                            _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseClassSuper", this).call(this, node);
                            node.body = this.parsePlaceholder("ClassBody") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseClassBody", this).call(this, !!node.superClass, oldStrict);
                            return this.finishNode(node, type);
                        }
                    },
                    {
                        key: "parseExport",
                        value: function parseExport(node, decorators) {
                            var placeholder = this.parsePlaceholder("Identifier");
                            if (!placeholder) return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExport", this).call(this, node, decorators);
                            var node2 = node;
                            if (!this.isContextual(98) && !this.match(12)) {
                                node2.specifiers = [];
                                node2.source = null;
                                node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
                                return this.finishNode(node2, "ExportNamedDeclaration");
                            }
                            this.expectPlugin("exportDefaultFrom");
                            var specifier = this.startNode();
                            specifier.exported = placeholder;
                            node2.specifiers = [
                                this.finishNode(specifier, "ExportDefaultSpecifier")
                            ];
                            return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExport", this).call(this, node2, decorators);
                        }
                    },
                    {
                        key: "isExportDefaultSpecifier",
                        value: function isExportDefaultSpecifier() {
                            if (this.match(65)) {
                                var next = this.nextTokenStart();
                                if (this.isUnparsedContextual(next, "from")) {
                                    if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
                                        return true;
                                    }
                                }
                            }
                            return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
                        }
                    },
                    {
                        key: "maybeParseExportDefaultSpecifier",
                        value: function maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
                            var _specifiers;
                            if ((_specifiers = node.specifiers) != null && _specifiers.length) {
                                return true;
                            }
                            return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "maybeParseExportDefaultSpecifier", this).call(this, node, maybeDefaultIdentifier);
                        }
                    },
                    {
                        key: "checkExport",
                        value: function checkExport(node) {
                            var specifiers = node.specifiers;
                            if (specifiers != null && specifiers.length) {
                                node.specifiers = specifiers.filter(function(node2) {
                                    return node2.exported.type === "Placeholder";
                                });
                            }
                            _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "checkExport", this).call(this, node);
                            node.specifiers = specifiers;
                        }
                    },
                    {
                        key: "parseImport",
                        value: function parseImport(node) {
                            var placeholder = this.parsePlaceholder("Identifier");
                            if (!placeholder) return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseImport", this).call(this, node);
                            node.specifiers = [];
                            if (!this.isContextual(98) && !this.match(12)) {
                                node.source = this.finishPlaceholder(placeholder, "StringLiteral");
                                this.semicolon();
                                return this.finishNode(node, "ImportDeclaration");
                            }
                            var specifier = this.startNodeAtNode(placeholder);
                            specifier.local = placeholder;
                            node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
                            if (this.eat(12)) {
                                var hasStarImport = this.maybeParseStarImportSpecifier(node);
                                if (!hasStarImport) this.parseNamedImportSpecifiers(node);
                            }
                            this.expectContextual(98);
                            node.source = this.parseImportSource();
                            this.semicolon();
                            return this.finishNode(node, "ImportDeclaration");
                        }
                    },
                    {
                        key: "parseImportSource",
                        value: function parseImportSource() {
                            return this.parsePlaceholder("StringLiteral") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseImportSource", this).call(this);
                        }
                    },
                    {
                        key: "assertNoSpace",
                        value: function assertNoSpace() {
                            if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
                                this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
                            }
                        }
                    }
                ]);
                return PlaceholdersParserMixin;
            }(superClass);
            return PlaceholdersParserMixin;
        };
        var v8intrinsic = function(superClass) {
            var V8IntrinsicMixin = /*#__PURE__*/ function(superClass) {
                _inherits(V8IntrinsicMixin, superClass);
                function V8IntrinsicMixin() {
                    _class_call_check(this, V8IntrinsicMixin);
                    return _call_super(this, V8IntrinsicMixin, arguments);
                }
                _create_class(V8IntrinsicMixin, [
                    {
                        key: "parseV8Intrinsic",
                        value: function parseV8Intrinsic() {
                            if (this.match(54)) {
                                var v8IntrinsicStartLoc = this.state.startLoc;
                                var node = this.startNode();
                                this.next();
                                if (tokenIsIdentifier(this.state.type)) {
                                    var name = this.parseIdentifierName();
                                    var identifier = this.createIdentifier(node, name);
                                    identifier.type = "V8IntrinsicIdentifier";
                                    if (this.match(10)) {
                                        return identifier;
                                    }
                                }
                                this.unexpected(v8IntrinsicStartLoc);
                            }
                        }
                    },
                    {
                        key: "parseExprAtom",
                        value: function parseExprAtom(refExpressionErrors) {
                            return this.parseV8Intrinsic() || _get(_get_prototype_of(V8IntrinsicMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
                        }
                    }
                ]);
                return V8IntrinsicMixin;
            }(superClass);
            return V8IntrinsicMixin;
        };
        var PIPELINE_PROPOSALS = [
            "minimal",
            "fsharp",
            "hack",
            "smart"
        ];
        var TOPIC_TOKENS = [
            "^^",
            "@@",
            "^",
            "%",
            "#"
        ];
        function validatePlugins(pluginsMap) {
            if (pluginsMap.has("decorators")) {
                if (pluginsMap.has("decorators-legacy")) {
                    throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                }
                var decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
                if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
                    throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
                }
                var allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
                if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
                    throw new Error("'allowCallParenthesized' must be a boolean.");
                }
            }
            if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
                throw new Error("Cannot combine flow and typescript plugins.");
            }
            if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
                throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            }
            if (pluginsMap.has("pipelineOperator")) {
                var _pluginsMap$get;
                var proposal = pluginsMap.get("pipelineOperator").proposal;
                if (!PIPELINE_PROPOSALS.includes(proposal)) {
                    var proposalList = PIPELINE_PROPOSALS.map(function(p) {
                        return '"'.concat(p, '"');
                    }).join(", ");
                    throw new Error('"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(proposalList, "."));
                }
                var tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash";
                if (proposal === "hack") {
                    if (pluginsMap.has("placeholders")) {
                        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                    }
                    if (pluginsMap.has("v8intrinsic")) {
                        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                    }
                    var topicToken = pluginsMap.get("pipelineOperator").topicToken;
                    if (!TOPIC_TOKENS.includes(topicToken)) {
                        var tokenList = TOPIC_TOKENS.map(function(t) {
                            return '"'.concat(t, '"');
                        }).join(", ");
                        throw new Error('"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(tokenList, "."));
                    }
                    if (topicToken === "#" && tupleSyntaxIsHash) {
                        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `'.concat(JSON.stringify([
                            "recordAndTuple",
                            pluginsMap.get("recordAndTuple")
                        ]), "`."));
                    }
                } else if (proposal === "smart" && tupleSyntaxIsHash) {
                    throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `'.concat(JSON.stringify([
                        "recordAndTuple",
                        pluginsMap.get("recordAndTuple")
                    ]), "`."));
                }
            }
            if (pluginsMap.has("moduleAttributes")) {
                {
                    if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
                        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
                    }
                    var moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
                    if (moduleAttributesVersionPluginOption !== "may-2020") {
                        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
                    }
                }
            }
            if (pluginsMap.has("importAssertions")) {
                if (pluginsMap.has("deprecatedImportAssert")) {
                    throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
                }
            }
            if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
                {
                    pluginsMap.set("deprecatedImportAssert", {});
                }
            }
            if (pluginsMap.has("recordAndTuple")) {
                var syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
                if (syntaxType != null) {
                    {
                        var RECORD_AND_TUPLE_SYNTAX_TYPES = [
                            "hash",
                            "bar"
                        ];
                        if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
                            throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function(p) {
                                return "'".concat(p, "'");
                            }).join(", "));
                        }
                    }
                }
            }
            if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
                var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                error.missingPlugins = "doExpressions";
                throw error;
            }
            if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
                throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
            }
        }
        var mixinPlugins = {
            estree: estree,
            jsx: jsx,
            flow: flow,
            typescript: typescript,
            v8intrinsic: v8intrinsic,
            placeholders: placeholders
        };
        var mixinPluginNames = Object.keys(mixinPlugins);
        function createDefaultOptions() {
            return {
                sourceType: "script",
                sourceFilename: void 0,
                startIndex: 0,
                startColumn: 0,
                startLine: 1,
                allowAwaitOutsideFunction: false,
                allowReturnOutsideFunction: false,
                allowNewTargetOutsideFunction: false,
                allowImportExportEverywhere: false,
                allowSuperOutsideMethod: false,
                allowUndeclaredExports: false,
                plugins: [],
                strictMode: null,
                ranges: false,
                tokens: false,
                createImportExpressions: false,
                createParenthesizedExpressions: false,
                errorRecovery: false,
                attachComment: true,
                annexB: true
            };
        }
        function getOptions(opts) {
            var options = createDefaultOptions();
            if (opts == null) {
                return options;
            }
            if (opts.annexB != null && opts.annexB !== false) {
                throw new Error("The `annexB` option can only be set to `false`.");
            }
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.keys(options)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key2 = _step.value;
                    if (opts[key2] != null) options[key2] = opts[key2];
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            if (options.startLine === 1) {
                if (opts.startIndex == null && options.startColumn > 0) {
                    options.startIndex = options.startColumn;
                } else if (opts.startColumn == null && options.startIndex > 0) {
                    options.startColumn = options.startIndex;
                }
            } else if (opts.startColumn == null || opts.startIndex == null) {
                if (opts.startIndex != null) {
                    throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
                }
            }
            return options;
        }
        var ExpressionParser = /*#__PURE__*/ function(LValParser) {
            _inherits(ExpressionParser, LValParser);
            function ExpressionParser() {
                _class_call_check(this, ExpressionParser);
                return _call_super(this, ExpressionParser, arguments);
            }
            _create_class(ExpressionParser, [
                {
                    key: "checkProto",
                    value: function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
                        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
                            return;
                        }
                        var key2 = prop.key;
                        var name = key2.type === "Identifier" ? key2.name : key2.value;
                        if (name === "__proto__") {
                            if (isRecord) {
                                this.raise(Errors.RecordNoProto, key2);
                                return;
                            }
                            if (protoRef.used) {
                                if (refExpressionErrors) {
                                    if (refExpressionErrors.doubleProtoLoc === null) {
                                        refExpressionErrors.doubleProtoLoc = key2.loc.start;
                                    }
                                } else {
                                    this.raise(Errors.DuplicateProto, key2);
                                }
                            }
                            protoRef.used = true;
                        }
                    }
                },
                {
                    key: "shouldExitDescending",
                    value: function shouldExitDescending(expr, potentialArrowAt) {
                        return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
                    }
                },
                {
                    key: "getExpression",
                    value: function getExpression() {
                        this.enterInitialScopes();
                        this.nextToken();
                        var expr = this.parseExpression();
                        if (!this.match(140)) {
                            this.unexpected();
                        }
                        this.finalizeRemainingComments();
                        expr.comments = this.comments;
                        expr.errors = this.state.errors;
                        if (this.options.tokens) {
                            expr.tokens = this.tokens;
                        }
                        return expr;
                    }
                },
                {
                    key: "parseExpression",
                    value: function parseExpression(disallowIn, refExpressionErrors) {
                        var _this = this;
                        if (disallowIn) {
                            return this.disallowInAnd(function() {
                                return _this.parseExpressionBase(refExpressionErrors);
                            });
                        }
                        return this.allowInAnd(function() {
                            return _this.parseExpressionBase(refExpressionErrors);
                        });
                    }
                },
                {
                    key: "parseExpressionBase",
                    value: function parseExpressionBase(refExpressionErrors) {
                        var startLoc = this.state.startLoc;
                        var expr = this.parseMaybeAssign(refExpressionErrors);
                        if (this.match(12)) {
                            var node = this.startNodeAt(startLoc);
                            node.expressions = [
                                expr
                            ];
                            while(this.eat(12)){
                                node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
                            }
                            this.toReferencedList(node.expressions);
                            return this.finishNode(node, "SequenceExpression");
                        }
                        return expr;
                    }
                },
                {
                    key: "parseMaybeAssignDisallowIn",
                    value: function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
                        var _this = this;
                        return this.disallowInAnd(function() {
                            return _this.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                        });
                    }
                },
                {
                    key: "parseMaybeAssignAllowIn",
                    value: function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
                        var _this = this;
                        return this.allowInAnd(function() {
                            return _this.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                        });
                    }
                },
                {
                    key: "setOptionalParametersError",
                    value: function setOptionalParametersError(refExpressionErrors, resultError) {
                        var _resultError$loc;
                        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
                    }
                },
                {
                    key: "parseMaybeAssign",
                    value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
                        var startLoc = this.state.startLoc;
                        if (this.isContextual(108)) {
                            if (this.prodParam.hasYield) {
                                var _left2 = this.parseYield();
                                if (afterLeftParse) {
                                    _left2 = afterLeftParse.call(this, _left2, startLoc);
                                }
                                return _left2;
                            }
                        }
                        var ownExpressionErrors;
                        if (refExpressionErrors) {
                            ownExpressionErrors = false;
                        } else {
                            refExpressionErrors = new ExpressionErrors();
                            ownExpressionErrors = true;
                        }
                        var type = this.state.type;
                        if (type === 10 || tokenIsIdentifier(type)) {
                            this.state.potentialArrowAt = this.state.start;
                        }
                        var left = this.parseMaybeConditional(refExpressionErrors);
                        if (afterLeftParse) {
                            left = afterLeftParse.call(this, left, startLoc);
                        }
                        if (tokenIsAssignment(this.state.type)) {
                            var node = this.startNodeAt(startLoc);
                            var operator = this.state.value;
                            node.operator = operator;
                            if (this.match(29)) {
                                this.toAssignable(left, true);
                                node.left = left;
                                var startIndex = startLoc.index;
                                if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
                                    refExpressionErrors.doubleProtoLoc = null;
                                }
                                if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
                                    refExpressionErrors.shorthandAssignLoc = null;
                                }
                                if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                                    this.checkDestructuringPrivate(refExpressionErrors);
                                    refExpressionErrors.privateKeyLoc = null;
                                }
                            } else {
                                node.left = left;
                            }
                            this.next();
                            node.right = this.parseMaybeAssign();
                            this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));
                            return node;
                        } else if (ownExpressionErrors) {
                            this.checkExpressionErrors(refExpressionErrors, true);
                        }
                        return left;
                    }
                },
                {
                    key: "parseMaybeConditional",
                    value: function parseMaybeConditional(refExpressionErrors) {
                        var startLoc = this.state.startLoc;
                        var potentialArrowAt = this.state.potentialArrowAt;
                        var expr = this.parseExprOps(refExpressionErrors);
                        if (this.shouldExitDescending(expr, potentialArrowAt)) {
                            return expr;
                        }
                        return this.parseConditional(expr, startLoc, refExpressionErrors);
                    }
                },
                {
                    key: "parseConditional",
                    value: function parseConditional(expr, startLoc, refExpressionErrors) {
                        if (this.eat(17)) {
                            var node = this.startNodeAt(startLoc);
                            node.test = expr;
                            node.consequent = this.parseMaybeAssignAllowIn();
                            this.expect(14);
                            node.alternate = this.parseMaybeAssign();
                            return this.finishNode(node, "ConditionalExpression");
                        }
                        return expr;
                    }
                },
                {
                    key: "parseMaybeUnaryOrPrivate",
                    value: function parseMaybeUnaryOrPrivate(refExpressionErrors) {
                        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
                    }
                },
                {
                    key: "parseExprOps",
                    value: function parseExprOps(refExpressionErrors) {
                        var startLoc = this.state.startLoc;
                        var potentialArrowAt = this.state.potentialArrowAt;
                        var expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
                        if (this.shouldExitDescending(expr, potentialArrowAt)) {
                            return expr;
                        }
                        return this.parseExprOp(expr, startLoc, -1);
                    }
                },
                {
                    key: "parseExprOp",
                    value: function parseExprOp(left, leftStartLoc, minPrec) {
                        if (this.isPrivateName(left)) {
                            var value = this.getPrivateNameSV(left);
                            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
                                this.raise(Errors.PrivateInExpectedIn, left, {
                                    identifierName: value
                                });
                            }
                            this.classScope.usePrivateName(value, left.loc.start);
                        }
                        var op = this.state.type;
                        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
                            var prec = tokenOperatorPrecedence(op);
                            if (prec > minPrec) {
                                if (op === 39) {
                                    this.expectPlugin("pipelineOperator");
                                    if (this.state.inFSharpPipelineDirectBody) {
                                        return left;
                                    }
                                    this.checkPipelineAtInfixOperator(left, leftStartLoc);
                                }
                                var node = this.startNodeAt(leftStartLoc);
                                node.left = left;
                                node.operator = this.state.value;
                                var logical = op === 41 || op === 42;
                                var coalesce = op === 40;
                                if (coalesce) {
                                    prec = tokenOperatorPrecedence(42);
                                }
                                this.next();
                                if (op === 39 && this.hasPlugin([
                                    "pipelineOperator",
                                    {
                                        proposal: "minimal"
                                    }
                                ])) {
                                    if (this.state.type === 96 && this.prodParam.hasAwait) {
                                        throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                                    }
                                }
                                node.right = this.parseExprOpRightExpr(op, prec);
                                var finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                                var nextOp = this.state.type;
                                if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                                    throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
                                }
                                return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
                            }
                        }
                        return left;
                    }
                },
                {
                    key: "parseExprOpRightExpr",
                    value: function parseExprOpRightExpr(op, prec) {
                        var _this = this;
                        var startLoc = this.state.startLoc;
                        switch(op){
                            case 39:
                                switch(this.getPluginOption("pipelineOperator", "proposal")){
                                    case "hack":
                                        return this.withTopicBindingContext(function() {
                                            return _this.parseHackPipeBody();
                                        });
                                    case "smart":
                                        return this.withTopicBindingContext(function() {
                                            if (_this.prodParam.hasYield && _this.isContextual(108)) {
                                                throw _this.raise(Errors.PipeBodyIsTighter, _this.state.startLoc);
                                            }
                                            return _this.parseSmartPipelineBodyInStyle(_this.parseExprOpBaseRightExpr(op, prec), startLoc);
                                        });
                                    case "fsharp":
                                        return this.withSoloAwaitPermittingContext(function() {
                                            return _this.parseFSharpPipelineBody(prec);
                                        });
                                }
                            default:
                                return this.parseExprOpBaseRightExpr(op, prec);
                        }
                    }
                },
                {
                    key: "parseExprOpBaseRightExpr",
                    value: function parseExprOpBaseRightExpr(op, prec) {
                        var startLoc = this.state.startLoc;
                        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
                    }
                },
                {
                    key: "parseHackPipeBody",
                    value: function parseHackPipeBody() {
                        var _body$extra;
                        var startLoc = this.state.startLoc;
                        var body3 = this.parseMaybeAssign();
                        var requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body3.type);
                        if (requiredParentheses && !((_body$extra = body3.extra) != null && _body$extra.parenthesized)) {
                            this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
                                type: body3.type
                            });
                        }
                        if (!this.topicReferenceWasUsedInCurrentContext()) {
                            this.raise(Errors.PipeTopicUnused, startLoc);
                        }
                        return body3;
                    }
                },
                {
                    key: "checkExponentialAfterUnary",
                    value: function checkExponentialAfterUnary(node) {
                        if (this.match(57)) {
                            this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
                        }
                    }
                },
                {
                    key: "parseMaybeUnary",
                    value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
                        var startLoc = this.state.startLoc;
                        var isAwait = this.isContextual(96);
                        if (isAwait && this.recordAwaitIfAllowed()) {
                            this.next();
                            var _expr = this.parseAwait(startLoc);
                            if (!sawUnary) this.checkExponentialAfterUnary(_expr);
                            return _expr;
                        }
                        var update = this.match(34);
                        var node = this.startNode();
                        if (tokenIsPrefix(this.state.type)) {
                            node.operator = this.state.value;
                            node.prefix = true;
                            if (this.match(72)) {
                                this.expectPlugin("throwExpressions");
                            }
                            var isDelete = this.match(89);
                            this.next();
                            node.argument = this.parseMaybeUnary(null, true);
                            this.checkExpressionErrors(refExpressionErrors, true);
                            if (this.state.strict && isDelete) {
                                var arg = node.argument;
                                if (arg.type === "Identifier") {
                                    this.raise(Errors.StrictDelete, node);
                                } else if (this.hasPropertyAsPrivateName(arg)) {
                                    this.raise(Errors.DeletePrivateField, node);
                                }
                            }
                            if (!update) {
                                if (!sawUnary) {
                                    this.checkExponentialAfterUnary(node);
                                }
                                return this.finishNode(node, "UnaryExpression");
                            }
                        }
                        var expr = this.parseUpdate(node, update, refExpressionErrors);
                        if (isAwait) {
                            var type = this.state.type;
                            var _startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
                            if (_startsExpr && !this.isAmbiguousAwait()) {
                                this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
                                return this.parseAwait(startLoc);
                            }
                        }
                        return expr;
                    }
                },
                {
                    key: "parseUpdate",
                    value: function parseUpdate(node, update, refExpressionErrors) {
                        if (update) {
                            var updateExpressionNode = node;
                            this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
                            return node;
                        }
                        var startLoc = this.state.startLoc;
                        var expr = this.parseExprSubscripts(refExpressionErrors);
                        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
                        while(tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()){
                            var _node12 = this.startNodeAt(startLoc);
                            _node12.operator = this.state.value;
                            _node12.prefix = false;
                            _node12.argument = expr;
                            this.next();
                            this.checkLVal(expr, expr = this.finishNode(_node12, "UpdateExpression"));
                        }
                        return expr;
                    }
                },
                {
                    key: "parseExprSubscripts",
                    value: function parseExprSubscripts(refExpressionErrors) {
                        var startLoc = this.state.startLoc;
                        var potentialArrowAt = this.state.potentialArrowAt;
                        var expr = this.parseExprAtom(refExpressionErrors);
                        if (this.shouldExitDescending(expr, potentialArrowAt)) {
                            return expr;
                        }
                        return this.parseSubscripts(expr, startLoc);
                    }
                },
                {
                    key: "parseSubscripts",
                    value: function parseSubscripts(base, startLoc, noCalls) {
                        var state = {
                            optionalChainMember: false,
                            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
                            stop: false
                        };
                        do {
                            base = this.parseSubscript(base, startLoc, noCalls, state);
                            state.maybeAsyncArrow = false;
                        }while (!state.stop);
                        return base;
                    }
                },
                {
                    key: "parseSubscript",
                    value: function parseSubscript(base, startLoc, noCalls, state) {
                        var type = this.state.type;
                        if (!noCalls && type === 15) {
                            return this.parseBind(base, startLoc, noCalls, state);
                        } else if (tokenIsTemplate(type)) {
                            return this.parseTaggedTemplateExpression(base, startLoc, state);
                        }
                        var optional = false;
                        if (type === 18) {
                            if (noCalls) {
                                this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
                                if (this.lookaheadCharCode() === 40) {
                                    state.stop = true;
                                    return base;
                                }
                            }
                            state.optionalChainMember = optional = true;
                            this.next();
                        }
                        if (!noCalls && this.match(10)) {
                            return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
                        } else {
                            var computed = this.eat(0);
                            if (computed || optional || this.eat(16)) {
                                return this.parseMember(base, startLoc, state, computed, optional);
                            } else {
                                state.stop = true;
                                return base;
                            }
                        }
                    }
                },
                {
                    key: "parseMember",
                    value: function parseMember(base, startLoc, state, computed, optional) {
                        var node = this.startNodeAt(startLoc);
                        node.object = base;
                        node.computed = computed;
                        if (computed) {
                            node.property = this.parseExpression();
                            this.expect(3);
                        } else if (this.match(139)) {
                            if (base.type === "Super") {
                                this.raise(Errors.SuperPrivateField, startLoc);
                            }
                            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                            node.property = this.parsePrivateName();
                        } else {
                            node.property = this.parseIdentifier(true);
                        }
                        if (state.optionalChainMember) {
                            node.optional = optional;
                            return this.finishNode(node, "OptionalMemberExpression");
                        } else {
                            return this.finishNode(node, "MemberExpression");
                        }
                    }
                },
                {
                    key: "parseBind",
                    value: function parseBind(base, startLoc, noCalls, state) {
                        var node = this.startNodeAt(startLoc);
                        node.object = base;
                        this.next();
                        node.callee = this.parseNoCallExpr();
                        state.stop = true;
                        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
                    }
                },
                {
                    key: "parseCoverCallAndAsyncArrowHead",
                    value: function parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
                        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                        var refExpressionErrors = null;
                        this.state.maybeInArrowParameters = true;
                        this.next();
                        var node = this.startNodeAt(startLoc);
                        node.callee = base;
                        var maybeAsyncArrow = state.maybeAsyncArrow, optionalChainMember = state.optionalChainMember;
                        if (maybeAsyncArrow) {
                            this.expressionScope.enter(newAsyncArrowScope());
                            refExpressionErrors = new ExpressionErrors();
                        }
                        if (optionalChainMember) {
                            node.optional = optional;
                        }
                        if (optional) {
                            node.arguments = this.parseCallExpressionArguments(11);
                        } else {
                            node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);
                        }
                        var finishedNode = this.finishCallExpression(node, optionalChainMember);
                        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
                            state.stop = true;
                            this.checkDestructuringPrivate(refExpressionErrors);
                            this.expressionScope.validateAsPattern();
                            this.expressionScope.exit();
                            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
                        } else {
                            if (maybeAsyncArrow) {
                                this.checkExpressionErrors(refExpressionErrors, true);
                                this.expressionScope.exit();
                            }
                            this.toReferencedArguments(finishedNode);
                        }
                        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                        return finishedNode;
                    }
                },
                {
                    key: "toReferencedArguments",
                    value: function toReferencedArguments(node, isParenthesizedExpr) {
                        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
                    }
                },
                {
                    key: "parseTaggedTemplateExpression",
                    value: function parseTaggedTemplateExpression(base, startLoc, state) {
                        var node = this.startNodeAt(startLoc);
                        node.tag = base;
                        node.quasi = this.parseTemplate(true);
                        if (state.optionalChainMember) {
                            this.raise(Errors.OptionalChainingNoTemplate, startLoc);
                        }
                        return this.finishNode(node, "TaggedTemplateExpression");
                    }
                },
                {
                    key: "atPossibleAsyncArrow",
                    value: function atPossibleAsyncArrow(base) {
                        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
                    }
                },
                {
                    key: "finishCallExpression",
                    value: function finishCallExpression(node, optional) {
                        if (node.callee.type === "Import") {
                            if (node.arguments.length === 0 || node.arguments.length > 2) {
                                this.raise(Errors.ImportCallArity, node);
                            } else {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = node.arguments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var arg = _step.value;
                                        if (arg.type === "SpreadElement") {
                                            this.raise(Errors.ImportCallSpreadArgument, arg);
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }
                        }
                        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
                    }
                },
                {
                    key: "parseCallExpressionArguments",
                    value: function parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
                        var elts = [];
                        var first = true;
                        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                        this.state.inFSharpPipelineDirectBody = false;
                        while(!this.eat(close)){
                            if (first) {
                                first = false;
                            } else {
                                this.expect(12);
                                if (this.match(close)) {
                                    if (nodeForExtra) {
                                        this.addTrailingCommaExtraToNode(nodeForExtra);
                                    }
                                    this.next();
                                    break;
                                }
                            }
                            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
                        }
                        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                        return elts;
                    }
                },
                {
                    key: "shouldParseAsyncArrow",
                    value: function shouldParseAsyncArrow() {
                        return this.match(19) && !this.canInsertSemicolon();
                    }
                },
                {
                    key: "parseAsyncArrowFromCallExpression",
                    value: function parseAsyncArrowFromCallExpression(node, call) {
                        var _call$extra;
                        this.resetPreviousNodeTrailingComments(call);
                        this.expect(19);
                        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
                        if (call.innerComments) {
                            setInnerComments(node, call.innerComments);
                        }
                        if (call.callee.trailingComments) {
                            setInnerComments(node, call.callee.trailingComments);
                        }
                        return node;
                    }
                },
                {
                    key: "parseNoCallExpr",
                    value: function parseNoCallExpr() {
                        var startLoc = this.state.startLoc;
                        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
                    }
                },
                {
                    key: "parseExprAtom",
                    value: function parseExprAtom(refExpressionErrors) {
                        var node;
                        var decorators = null;
                        var type = this.state.type;
                        switch(type){
                            case 79:
                                return this.parseSuper();
                            case 83:
                                node = this.startNode();
                                this.next();
                                if (this.match(16)) {
                                    return this.parseImportMetaProperty(node);
                                }
                                if (this.match(10)) {
                                    if (this.options.createImportExpressions) {
                                        return this.parseImportCall(node);
                                    } else {
                                        return this.finishNode(node, "Import");
                                    }
                                } else {
                                    this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
                                    return this.finishNode(node, "Import");
                                }
                            case 78:
                                node = this.startNode();
                                this.next();
                                return this.finishNode(node, "ThisExpression");
                            case 90:
                                {
                                    return this.parseDo(this.startNode(), false);
                                }
                            case 56:
                            case 31:
                                {
                                    this.readRegexp();
                                    return this.parseRegExpLiteral(this.state.value);
                                }
                            case 135:
                                return this.parseNumericLiteral(this.state.value);
                            case 136:
                                return this.parseBigIntLiteral(this.state.value);
                            case 134:
                                return this.parseStringLiteral(this.state.value);
                            case 84:
                                return this.parseNullLiteral();
                            case 85:
                                return this.parseBooleanLiteral(true);
                            case 86:
                                return this.parseBooleanLiteral(false);
                            case 10:
                                {
                                    var canBeArrow = this.state.potentialArrowAt === this.state.start;
                                    return this.parseParenAndDistinguishExpression(canBeArrow);
                                }
                            case 2:
                            case 1:
                                {
                                    return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                                }
                            case 0:
                                {
                                    return this.parseArrayLike(3, true, false, refExpressionErrors);
                                }
                            case 6:
                            case 7:
                                {
                                    return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                                }
                            case 5:
                                {
                                    return this.parseObjectLike(8, false, false, refExpressionErrors);
                                }
                            case 68:
                                return this.parseFunctionOrFunctionSent();
                            case 26:
                                decorators = this.parseDecorators();
                            case 80:
                                return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
                            case 77:
                                return this.parseNewOrNewTarget();
                            case 25:
                            case 24:
                                return this.parseTemplate(false);
                            case 15:
                                {
                                    node = this.startNode();
                                    this.next();
                                    node.object = null;
                                    var callee = node.callee = this.parseNoCallExpr();
                                    if (callee.type === "MemberExpression") {
                                        return this.finishNode(node, "BindExpression");
                                    } else {
                                        throw this.raise(Errors.UnsupportedBind, callee);
                                    }
                                }
                            case 139:
                                {
                                    this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
                                        identifierName: this.state.value
                                    });
                                    return this.parsePrivateName();
                                }
                            case 33:
                                {
                                    return this.parseTopicReferenceThenEqualsSign(54, "%");
                                }
                            case 32:
                                {
                                    return this.parseTopicReferenceThenEqualsSign(44, "^");
                                }
                            case 37:
                            case 38:
                                {
                                    return this.parseTopicReference("hack");
                                }
                            case 44:
                            case 54:
                            case 27:
                                {
                                    var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                                    if (pipeProposal) {
                                        return this.parseTopicReference(pipeProposal);
                                    }
                                    this.unexpected();
                                    break;
                                }
                            case 47:
                                {
                                    var lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                                    if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                                        this.expectOnePlugin([
                                            "jsx",
                                            "flow",
                                            "typescript"
                                        ]);
                                    } else {
                                        this.unexpected();
                                    }
                                    break;
                                }
                            default:
                                if (type === 137) {
                                    return this.parseDecimalLiteral(this.state.value);
                                }
                                if (tokenIsIdentifier(type)) {
                                    if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                                        return this.parseModuleExpression();
                                    }
                                    var _canBeArrow = this.state.potentialArrowAt === this.state.start;
                                    var containsEsc = this.state.containsEsc;
                                    var id = this.parseIdentifier();
                                    if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                                        var _this_state = this.state, _type = _this_state.type;
                                        if (_type === 68) {
                                            this.resetPreviousNodeTrailingComments(id);
                                            this.next();
                                            return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                                        } else if (tokenIsIdentifier(_type)) {
                                            if (this.lookaheadCharCode() === 61) {
                                                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                                            } else {
                                                return id;
                                            }
                                        } else if (_type === 90) {
                                            this.resetPreviousNodeTrailingComments(id);
                                            return this.parseDo(this.startNodeAtNode(id), true);
                                        }
                                    }
                                    if (_canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                                        this.next();
                                        return this.parseArrowExpression(this.startNodeAtNode(id), [
                                            id
                                        ], false);
                                    }
                                    return id;
                                } else {
                                    this.unexpected();
                                }
                        }
                    }
                },
                {
                    key: "parseTopicReferenceThenEqualsSign",
                    value: function parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
                        var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                        if (pipeProposal) {
                            this.state.type = topicTokenType;
                            this.state.value = topicTokenValue;
                            this.state.pos--;
                            this.state.end--;
                            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
                            return this.parseTopicReference(pipeProposal);
                        } else {
                            this.unexpected();
                        }
                    }
                },
                {
                    key: "parseTopicReference",
                    value: function parseTopicReference(pipeProposal) {
                        var node = this.startNode();
                        var startLoc = this.state.startLoc;
                        var tokenType = this.state.type;
                        this.next();
                        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
                    }
                },
                {
                    key: "finishTopicReference",
                    value: function finishTopicReference(node, startLoc, pipeProposal, tokenType) {
                        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
                            var nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                            if (!this.topicReferenceIsAllowedInCurrentContext()) {
                                this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);
                            }
                            this.registerTopicReference();
                            return this.finishNode(node, nodeType);
                        } else {
                            throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
                                token: tokenLabelName(tokenType)
                            });
                        }
                    }
                },
                {
                    key: "testTopicReferenceConfiguration",
                    value: function testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
                        switch(pipeProposal){
                            case "hack":
                                {
                                    return this.hasPlugin([
                                        "pipelineOperator",
                                        {
                                            topicToken: tokenLabelName(tokenType)
                                        }
                                    ]);
                                }
                            case "smart":
                                return tokenType === 27;
                            default:
                                throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
                        }
                    }
                },
                {
                    key: "parseAsyncArrowUnaryFunction",
                    value: function parseAsyncArrowUnaryFunction(node) {
                        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
                        var params = [
                            this.parseIdentifier()
                        ];
                        this.prodParam.exit();
                        if (this.hasPrecedingLineBreak()) {
                            this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
                        }
                        this.expect(19);
                        return this.parseArrowExpression(node, params, true);
                    }
                },
                {
                    key: "parseDo",
                    value: function parseDo(node, isAsync) {
                        this.expectPlugin("doExpressions");
                        if (isAsync) {
                            this.expectPlugin("asyncDoExpressions");
                        }
                        node.async = isAsync;
                        this.next();
                        var oldLabels = this.state.labels;
                        this.state.labels = [];
                        if (isAsync) {
                            this.prodParam.enter(2);
                            node.body = this.parseBlock();
                            this.prodParam.exit();
                        } else {
                            node.body = this.parseBlock();
                        }
                        this.state.labels = oldLabels;
                        return this.finishNode(node, "DoExpression");
                    }
                },
                {
                    key: "parseSuper",
                    value: function parseSuper() {
                        var node = this.startNode();
                        this.next();
                        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
                            this.raise(Errors.SuperNotAllowed, node);
                        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
                            this.raise(Errors.UnexpectedSuper, node);
                        }
                        if (!this.match(10) && !this.match(0) && !this.match(16)) {
                            this.raise(Errors.UnsupportedSuper, node);
                        }
                        return this.finishNode(node, "Super");
                    }
                },
                {
                    key: "parsePrivateName",
                    value: function parsePrivateName() {
                        var node = this.startNode();
                        var id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
                        var name = this.state.value;
                        this.next();
                        node.id = this.createIdentifier(id, name);
                        return this.finishNode(node, "PrivateName");
                    }
                },
                {
                    key: "parseFunctionOrFunctionSent",
                    value: function parseFunctionOrFunctionSent() {
                        var node = this.startNode();
                        this.next();
                        if (this.prodParam.hasYield && this.match(16)) {
                            var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
                            this.next();
                            if (this.match(103)) {
                                this.expectPlugin("functionSent");
                            } else if (!this.hasPlugin("functionSent")) {
                                this.unexpected();
                            }
                            return this.parseMetaProperty(node, meta, "sent");
                        }
                        return this.parseFunction(node);
                    }
                },
                {
                    key: "parseMetaProperty",
                    value: function parseMetaProperty(node, meta, propertyName) {
                        node.meta = meta;
                        var containsEsc = this.state.containsEsc;
                        node.property = this.parseIdentifier(true);
                        if (node.property.name !== propertyName || containsEsc) {
                            this.raise(Errors.UnsupportedMetaProperty, node.property, {
                                target: meta.name,
                                onlyValidPropertyName: propertyName
                            });
                        }
                        return this.finishNode(node, "MetaProperty");
                    }
                },
                {
                    key: "parseImportMetaProperty",
                    value: function parseImportMetaProperty(node) {
                        var id = this.createIdentifier(this.startNodeAtNode(node), "import");
                        this.next();
                        if (this.isContextual(101)) {
                            if (!this.inModule) {
                                this.raise(Errors.ImportMetaOutsideModule, id);
                            }
                            this.sawUnambiguousESM = true;
                        } else if (this.isContextual(105) || this.isContextual(97)) {
                            var isSource = this.isContextual(105);
                            if (!isSource) this.unexpected();
                            this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
                            if (!this.options.createImportExpressions) {
                                throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
                                    phase: this.state.value
                                });
                            }
                            this.next();
                            node.phase = isSource ? "source" : "defer";
                            return this.parseImportCall(node);
                        }
                        return this.parseMetaProperty(node, id, "meta");
                    }
                },
                {
                    key: "parseLiteralAtNode",
                    value: function parseLiteralAtNode(value, type, node) {
                        this.addExtra(node, "rawValue", value);
                        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
                        node.value = value;
                        this.next();
                        return this.finishNode(node, type);
                    }
                },
                {
                    key: "parseLiteral",
                    value: function parseLiteral(value, type) {
                        var node = this.startNode();
                        return this.parseLiteralAtNode(value, type, node);
                    }
                },
                {
                    key: "parseStringLiteral",
                    value: function parseStringLiteral(value) {
                        return this.parseLiteral(value, "StringLiteral");
                    }
                },
                {
                    key: "parseNumericLiteral",
                    value: function parseNumericLiteral(value) {
                        return this.parseLiteral(value, "NumericLiteral");
                    }
                },
                {
                    key: "parseBigIntLiteral",
                    value: function parseBigIntLiteral(value) {
                        return this.parseLiteral(value, "BigIntLiteral");
                    }
                },
                {
                    key: "parseDecimalLiteral",
                    value: function parseDecimalLiteral(value) {
                        return this.parseLiteral(value, "DecimalLiteral");
                    }
                },
                {
                    key: "parseRegExpLiteral",
                    value: function parseRegExpLiteral(value) {
                        var node = this.startNode();
                        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
                        node.pattern = value.pattern;
                        node.flags = value.flags;
                        this.next();
                        return this.finishNode(node, "RegExpLiteral");
                    }
                },
                {
                    key: "parseBooleanLiteral",
                    value: function parseBooleanLiteral(value) {
                        var node = this.startNode();
                        node.value = value;
                        this.next();
                        return this.finishNode(node, "BooleanLiteral");
                    }
                },
                {
                    key: "parseNullLiteral",
                    value: function parseNullLiteral() {
                        var node = this.startNode();
                        this.next();
                        return this.finishNode(node, "NullLiteral");
                    }
                },
                {
                    key: "parseParenAndDistinguishExpression",
                    value: function parseParenAndDistinguishExpression(canBeArrow) {
                        var startLoc = this.state.startLoc;
                        var val;
                        this.next();
                        this.expressionScope.enter(newArrowHeadScope());
                        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                        this.state.maybeInArrowParameters = true;
                        this.state.inFSharpPipelineDirectBody = false;
                        var innerStartLoc = this.state.startLoc;
                        var exprList = [];
                        var refExpressionErrors = new ExpressionErrors();
                        var first = true;
                        var spreadStartLoc;
                        var optionalCommaStartLoc;
                        while(!this.match(11)){
                            if (first) {
                                first = false;
                            } else {
                                this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
                                if (this.match(11)) {
                                    optionalCommaStartLoc = this.state.startLoc;
                                    break;
                                }
                            }
                            if (this.match(21)) {
                                var spreadNodeStartLoc = this.state.startLoc;
                                spreadStartLoc = this.state.startLoc;
                                exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
                                if (!this.checkCommaAfterRest(41)) {
                                    break;
                                }
                            } else {
                                exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
                            }
                        }
                        var innerEndLoc = this.state.lastTokEndLoc;
                        this.expect(11);
                        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                        var arrowNode = this.startNodeAt(startLoc);
                        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
                            this.checkDestructuringPrivate(refExpressionErrors);
                            this.expressionScope.validateAsPattern();
                            this.expressionScope.exit();
                            this.parseArrowExpression(arrowNode, exprList, false);
                            return arrowNode;
                        }
                        this.expressionScope.exit();
                        if (!exprList.length) {
                            this.unexpected(this.state.lastTokStartLoc);
                        }
                        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
                        if (spreadStartLoc) this.unexpected(spreadStartLoc);
                        this.checkExpressionErrors(refExpressionErrors, true);
                        this.toReferencedListDeep(exprList, true);
                        if (exprList.length > 1) {
                            val = this.startNodeAt(innerStartLoc);
                            val.expressions = exprList;
                            this.finishNode(val, "SequenceExpression");
                            this.resetEndLocation(val, innerEndLoc);
                        } else {
                            val = exprList[0];
                        }
                        return this.wrapParenthesis(startLoc, val);
                    }
                },
                {
                    key: "wrapParenthesis",
                    value: function wrapParenthesis(startLoc, expression) {
                        if (!this.options.createParenthesizedExpressions) {
                            this.addExtra(expression, "parenthesized", true);
                            this.addExtra(expression, "parenStart", startLoc.index);
                            this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
                            return expression;
                        }
                        var parenExpression = this.startNodeAt(startLoc);
                        parenExpression.expression = expression;
                        return this.finishNode(parenExpression, "ParenthesizedExpression");
                    }
                },
                {
                    key: "shouldParseArrow",
                    value: function shouldParseArrow(params) {
                        return !this.canInsertSemicolon();
                    }
                },
                {
                    key: "parseArrow",
                    value: function parseArrow(node) {
                        if (this.eat(19)) {
                            return node;
                        }
                    }
                },
                {
                    key: "parseParenItem",
                    value: function parseParenItem(node, startLoc) {
                        return node;
                    }
                },
                {
                    key: "parseNewOrNewTarget",
                    value: function parseNewOrNewTarget() {
                        var node = this.startNode();
                        this.next();
                        if (this.match(16)) {
                            var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
                            this.next();
                            var metaProp = this.parseMetaProperty(node, meta, "target");
                            if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
                                this.raise(Errors.UnexpectedNewTarget, metaProp);
                            }
                            return metaProp;
                        }
                        return this.parseNew(node);
                    }
                },
                {
                    key: "parseNew",
                    value: function parseNew(node) {
                        this.parseNewCallee(node);
                        if (this.eat(10)) {
                            var args = this.parseExprList(11);
                            this.toReferencedList(args);
                            node.arguments = args;
                        } else {
                            node.arguments = [];
                        }
                        return this.finishNode(node, "NewExpression");
                    }
                },
                {
                    key: "parseNewCallee",
                    value: function parseNewCallee(node) {
                        var isImport = this.match(83);
                        var callee = this.parseNoCallExpr();
                        node.callee = callee;
                        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
                            this.raise(Errors.ImportCallNotNewExpression, callee);
                        }
                    }
                },
                {
                    key: "parseTemplateElement",
                    value: function parseTemplateElement(isTagged) {
                        var _this_state = this.state, start = _this_state.start, startLoc = _this_state.startLoc, end = _this_state.end, value = _this_state.value;
                        var elemStart = start + 1;
                        var elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
                        if (value === null) {
                            if (!isTagged) {
                                this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
                            }
                        }
                        var isTail = this.match(24);
                        var endOffset = isTail ? -1 : -2;
                        var elemEnd = end + endOffset;
                        elem.value = {
                            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
                            cooked: value === null ? null : value.slice(1, endOffset)
                        };
                        elem.tail = isTail;
                        this.next();
                        var finishedNode = this.finishNode(elem, "TemplateElement");
                        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
                        return finishedNode;
                    }
                },
                {
                    key: "parseTemplate",
                    value: function parseTemplate(isTagged) {
                        var node = this.startNode();
                        var curElt = this.parseTemplateElement(isTagged);
                        var quasis = [
                            curElt
                        ];
                        var substitutions = [];
                        while(!curElt.tail){
                            substitutions.push(this.parseTemplateSubstitution());
                            this.readTemplateContinuation();
                            quasis.push(curElt = this.parseTemplateElement(isTagged));
                        }
                        node.expressions = substitutions;
                        node.quasis = quasis;
                        return this.finishNode(node, "TemplateLiteral");
                    }
                },
                {
                    key: "parseTemplateSubstitution",
                    value: function parseTemplateSubstitution() {
                        return this.parseExpression();
                    }
                },
                {
                    key: "parseObjectLike",
                    value: function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
                        if (isRecord) {
                            this.expectPlugin("recordAndTuple");
                        }
                        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                        this.state.inFSharpPipelineDirectBody = false;
                        var propHash = /* @__PURE__ */ Object.create(null);
                        var first = true;
                        var node = this.startNode();
                        node.properties = [];
                        this.next();
                        while(!this.match(close)){
                            if (first) {
                                first = false;
                            } else {
                                this.expect(12);
                                if (this.match(close)) {
                                    this.addTrailingCommaExtraToNode(node);
                                    break;
                                }
                            }
                            var prop = void 0;
                            if (isPattern) {
                                prop = this.parseBindingProperty();
                            } else {
                                prop = this.parsePropertyDefinition(refExpressionErrors);
                                this.checkProto(prop, isRecord, propHash, refExpressionErrors);
                            }
                            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
                                this.raise(Errors.InvalidRecordProperty, prop);
                            }
                            {
                                if (prop.shorthand) {
                                    this.addExtra(prop, "shorthand", true);
                                }
                            }
                            node.properties.push(prop);
                        }
                        this.next();
                        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                        var type = "ObjectExpression";
                        if (isPattern) {
                            type = "ObjectPattern";
                        } else if (isRecord) {
                            type = "RecordExpression";
                        }
                        return this.finishNode(node, type);
                    }
                },
                {
                    key: "addTrailingCommaExtraToNode",
                    value: function addTrailingCommaExtraToNode(node) {
                        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
                        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
                    }
                },
                {
                    key: "maybeAsyncOrAccessorProp",
                    value: function maybeAsyncOrAccessorProp(prop) {
                        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
                    }
                },
                {
                    key: "parsePropertyDefinition",
                    value: function parsePropertyDefinition(refExpressionErrors) {
                        var decorators = [];
                        if (this.match(26)) {
                            if (this.hasPlugin("decorators")) {
                                this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
                            }
                            while(this.match(26)){
                                decorators.push(this.parseDecorator());
                            }
                        }
                        var prop = this.startNode();
                        var isAsync = false;
                        var isAccessor = false;
                        var startLoc;
                        if (this.match(21)) {
                            if (decorators.length) this.unexpected();
                            return this.parseSpread();
                        }
                        if (decorators.length) {
                            prop.decorators = decorators;
                            decorators = [];
                        }
                        prop.method = false;
                        if (refExpressionErrors) {
                            startLoc = this.state.startLoc;
                        }
                        var isGenerator = this.eat(55);
                        this.parsePropertyNamePrefixOperator(prop);
                        var containsEsc = this.state.containsEsc;
                        this.parsePropertyName(prop, refExpressionErrors);
                        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
                            var key2 = prop.key;
                            var keyName = key2.name;
                            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
                                isAsync = true;
                                this.resetPreviousNodeTrailingComments(key2);
                                isGenerator = this.eat(55);
                                this.parsePropertyName(prop);
                            }
                            if (keyName === "get" || keyName === "set") {
                                isAccessor = true;
                                this.resetPreviousNodeTrailingComments(key2);
                                prop.kind = keyName;
                                if (this.match(55)) {
                                    isGenerator = true;
                                    this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                                        kind: keyName
                                    });
                                    this.next();
                                }
                                this.parsePropertyName(prop);
                            }
                        }
                        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
                    }
                },
                {
                    key: "getGetterSetterExpectedParamCount",
                    value: function getGetterSetterExpectedParamCount(method) {
                        return method.kind === "get" ? 0 : 1;
                    }
                },
                {
                    key: "getObjectOrClassMethodParams",
                    value: function getObjectOrClassMethodParams(method) {
                        return method.params;
                    }
                },
                {
                    key: "checkGetterSetterParams",
                    value: function checkGetterSetterParams(method) {
                        var _params;
                        var paramCount = this.getGetterSetterExpectedParamCount(method);
                        var params = this.getObjectOrClassMethodParams(method);
                        if (params.length !== paramCount) {
                            this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
                        }
                        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
                            this.raise(Errors.BadSetterRestParameter, method);
                        }
                    }
                },
                {
                    key: "parseObjectMethod",
                    value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
                        if (isAccessor) {
                            var finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
                            this.checkGetterSetterParams(finishedProp);
                            return finishedProp;
                        }
                        if (isAsync || isGenerator || this.match(10)) {
                            if (isPattern) this.unexpected();
                            prop.kind = "method";
                            prop.method = true;
                            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
                        }
                    }
                },
                {
                    key: "parseObjectProperty",
                    value: function parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
                        prop.shorthand = false;
                        if (this.eat(14)) {
                            prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
                            return this.finishNode(prop, "ObjectProperty");
                        }
                        if (!prop.computed && prop.key.type === "Identifier") {
                            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
                            if (isPattern) {
                                prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
                            } else if (this.match(29)) {
                                var shorthandAssignLoc = this.state.startLoc;
                                if (refExpressionErrors != null) {
                                    if (refExpressionErrors.shorthandAssignLoc === null) {
                                        refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                                    }
                                } else {
                                    this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
                                }
                                prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
                            } else {
                                prop.value = cloneIdentifier(prop.key);
                            }
                            prop.shorthand = true;
                            return this.finishNode(prop, "ObjectProperty");
                        }
                    }
                },
                {
                    key: "parseObjPropValue",
                    value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
                        var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
                        if (!node) this.unexpected();
                        return node;
                    }
                },
                {
                    key: "parsePropertyName",
                    value: function parsePropertyName(prop, refExpressionErrors) {
                        if (this.eat(0)) {
                            prop.computed = true;
                            prop.key = this.parseMaybeAssignAllowIn();
                            this.expect(3);
                        } else {
                            var _this_state = this.state, type = _this_state.type, value = _this_state.value;
                            var key2;
                            if (tokenIsKeywordOrIdentifier(type)) {
                                key2 = this.parseIdentifier(true);
                            } else {
                                switch(type){
                                    case 135:
                                        key2 = this.parseNumericLiteral(value);
                                        break;
                                    case 134:
                                        key2 = this.parseStringLiteral(value);
                                        break;
                                    case 136:
                                        key2 = this.parseBigIntLiteral(value);
                                        break;
                                    case 139:
                                        {
                                            var privateKeyLoc = this.state.startLoc;
                                            if (refExpressionErrors != null) {
                                                if (refExpressionErrors.privateKeyLoc === null) {
                                                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                                                }
                                            } else {
                                                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                                            }
                                            key2 = this.parsePrivateName();
                                            break;
                                        }
                                    default:
                                        if (type === 137) {
                                            key2 = this.parseDecimalLiteral(value);
                                            break;
                                        }
                                        this.unexpected();
                                }
                            }
                            prop.key = key2;
                            if (type !== 139) {
                                prop.computed = false;
                            }
                        }
                    }
                },
                {
                    key: "initFunction",
                    value: function initFunction(node, isAsync) {
                        node.id = null;
                        node.generator = false;
                        node.async = isAsync;
                    }
                },
                {
                    key: "parseMethod",
                    value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
                        var inClassScope = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                        this.initFunction(node, isAsync);
                        node.generator = isGenerator;
                        this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
                        this.prodParam.enter(functionFlags(isAsync, node.generator));
                        this.parseFunctionParams(node, isConstructor);
                        var finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
                        this.prodParam.exit();
                        this.scope.exit();
                        return finishedNode;
                    }
                },
                {
                    key: "parseArrayLike",
                    value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
                        if (isTuple) {
                            this.expectPlugin("recordAndTuple");
                        }
                        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                        this.state.inFSharpPipelineDirectBody = false;
                        var node = this.startNode();
                        this.next();
                        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
                        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
                    }
                },
                {
                    key: "parseArrowExpression",
                    value: function parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
                        this.scope.enter(2 | 4);
                        var flags = functionFlags(isAsync, false);
                        if (!this.match(5) && this.prodParam.hasIn) {
                            flags |= 8;
                        }
                        this.prodParam.enter(flags);
                        this.initFunction(node, isAsync);
                        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                        if (params) {
                            this.state.maybeInArrowParameters = true;
                            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
                        }
                        this.state.maybeInArrowParameters = false;
                        this.parseFunctionBody(node, true);
                        this.prodParam.exit();
                        this.scope.exit();
                        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                        return this.finishNode(node, "ArrowFunctionExpression");
                    }
                },
                {
                    key: "setArrowFunctionParameters",
                    value: function setArrowFunctionParameters(node, params, trailingCommaLoc) {
                        this.toAssignableList(params, trailingCommaLoc, false);
                        node.params = params;
                    }
                },
                {
                    key: "parseFunctionBodyAndFinish",
                    value: function parseFunctionBodyAndFinish(node, type) {
                        var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        this.parseFunctionBody(node, false, isMethod);
                        return this.finishNode(node, type);
                    }
                },
                {
                    key: "parseFunctionBody",
                    value: function parseFunctionBody(node, allowExpression) {
                        var _this = this;
                        var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        var isExpression = allowExpression && !this.match(5);
                        this.expressionScope.enter(newExpressionScope());
                        if (isExpression) {
                            node.body = this.parseMaybeAssign();
                            this.checkParams(node, false, allowExpression, false);
                        } else {
                            var oldStrict = this.state.strict;
                            var oldLabels = this.state.labels;
                            this.state.labels = [];
                            this.prodParam.enter(this.prodParam.currentFlags() | 4);
                            node.body = this.parseBlock(true, false, function(hasStrictModeDirective) {
                                var nonSimple = !_this.isSimpleParamList(node.params);
                                if (hasStrictModeDirective && nonSimple) {
                                    _this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
                                }
                                var strictModeChanged = !oldStrict && _this.state.strict;
                                _this.checkParams(node, !_this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
                                if (_this.state.strict && node.id) {
                                    _this.checkIdentifier(node.id, 65, strictModeChanged);
                                }
                            });
                            this.prodParam.exit();
                            this.state.labels = oldLabels;
                        }
                        this.expressionScope.exit();
                    }
                },
                {
                    key: "isSimpleParameter",
                    value: function isSimpleParameter(node) {
                        return node.type === "Identifier";
                    }
                },
                {
                    key: "isSimpleParamList",
                    value: function isSimpleParamList(params) {
                        for(var i = 0, len = params.length; i < len; i++){
                            if (!this.isSimpleParameter(params[i])) return false;
                        }
                        return true;
                    }
                },
                {
                    key: "checkParams",
                    value: function checkParams(node, allowDuplicates, isArrowFunction) {
                        var strictModeChanged = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                        var checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
                        var formalParameters = {
                            type: "FormalParameters"
                        };
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = node.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var param = _step.value;
                                this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                },
                {
                    key: "parseExprList",
                    value: function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
                        var elts = [];
                        var first = true;
                        while(!this.eat(close)){
                            if (first) {
                                first = false;
                            } else {
                                this.expect(12);
                                if (this.match(close)) {
                                    if (nodeForExtra) {
                                        this.addTrailingCommaExtraToNode(nodeForExtra);
                                    }
                                    this.next();
                                    break;
                                }
                            }
                            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
                        }
                        return elts;
                    }
                },
                {
                    key: "parseExprListItem",
                    value: function parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
                        var elt;
                        if (this.match(12)) {
                            if (!allowEmpty) {
                                this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
                                    unexpected: ","
                                });
                            }
                            elt = null;
                        } else if (this.match(21)) {
                            var spreadNodeStartLoc = this.state.startLoc;
                            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
                        } else if (this.match(17)) {
                            this.expectPlugin("partialApplication");
                            if (!allowPlaceholder) {
                                this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
                            }
                            var node = this.startNode();
                            this.next();
                            elt = this.finishNode(node, "ArgumentPlaceholder");
                        } else {
                            elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
                        }
                        return elt;
                    }
                },
                {
                    key: "parseIdentifier",
                    value: function parseIdentifier(liberal) {
                        var node = this.startNode();
                        var name = this.parseIdentifierName(liberal);
                        return this.createIdentifier(node, name);
                    }
                },
                {
                    key: "createIdentifier",
                    value: function createIdentifier(node, name) {
                        node.name = name;
                        node.loc.identifierName = name;
                        return this.finishNode(node, "Identifier");
                    }
                },
                {
                    key: "parseIdentifierName",
                    value: function parseIdentifierName(liberal) {
                        var name;
                        var _this_state = this.state, startLoc = _this_state.startLoc, type = _this_state.type;
                        if (tokenIsKeywordOrIdentifier(type)) {
                            name = this.state.value;
                        } else {
                            this.unexpected();
                        }
                        var tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
                        if (liberal) {
                            if (tokenIsKeyword2) {
                                this.replaceToken(132);
                            }
                        } else {
                            this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
                        }
                        this.next();
                        return name;
                    }
                },
                {
                    key: "checkReservedWord",
                    value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
                        if (word.length > 10) {
                            return;
                        }
                        if (!canBeReservedWord(word)) {
                            return;
                        }
                        if (checkKeywords && isKeyword(word)) {
                            this.raise(Errors.UnexpectedKeyword, startLoc, {
                                keyword: word
                            });
                            return;
                        }
                        var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
                        if (reservedTest(word, this.inModule)) {
                            this.raise(Errors.UnexpectedReservedWord, startLoc, {
                                reservedWord: word
                            });
                            return;
                        } else if (word === "yield") {
                            if (this.prodParam.hasYield) {
                                this.raise(Errors.YieldBindingIdentifier, startLoc);
                                return;
                            }
                        } else if (word === "await") {
                            if (this.prodParam.hasAwait) {
                                this.raise(Errors.AwaitBindingIdentifier, startLoc);
                                return;
                            }
                            if (this.scope.inStaticBlock) {
                                this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
                                return;
                            }
                            this.expressionScope.recordAsyncArrowParametersError(startLoc);
                        } else if (word === "arguments") {
                            if (this.scope.inClassAndNotInNonArrowFunction) {
                                this.raise(Errors.ArgumentsInClass, startLoc);
                                return;
                            }
                        }
                    }
                },
                {
                    key: "recordAwaitIfAllowed",
                    value: function recordAwaitIfAllowed() {
                        var isAwaitAllowed = this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction;
                        if (isAwaitAllowed && !this.scope.inFunction) {
                            this.state.hasTopLevelAwait = true;
                        }
                        return isAwaitAllowed;
                    }
                },
                {
                    key: "parseAwait",
                    value: function parseAwait(startLoc) {
                        var node = this.startNodeAt(startLoc);
                        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
                        if (this.eat(55)) {
                            this.raise(Errors.ObsoleteAwaitStar, node);
                        }
                        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
                            if (this.isAmbiguousAwait()) {
                                this.ambiguousScriptDifferentAst = true;
                            } else {
                                this.sawUnambiguousESM = true;
                            }
                        }
                        if (!this.state.soloAwait) {
                            node.argument = this.parseMaybeUnary(null, true);
                        }
                        return this.finishNode(node, "AwaitExpression");
                    }
                },
                {
                    key: "isAmbiguousAwait",
                    value: function isAmbiguousAwait() {
                        if (this.hasPrecedingLineBreak()) return true;
                        var type = this.state.type;
                        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
                    }
                },
                {
                    key: "parseYield",
                    value: function parseYield() {
                        var node = this.startNode();
                        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
                        this.next();
                        var delegating = false;
                        var argument = null;
                        if (!this.hasPrecedingLineBreak()) {
                            delegating = this.eat(55);
                            switch(this.state.type){
                                case 13:
                                case 140:
                                case 8:
                                case 11:
                                case 3:
                                case 9:
                                case 14:
                                case 12:
                                    if (!delegating) break;
                                default:
                                    argument = this.parseMaybeAssign();
                            }
                        }
                        node.delegate = delegating;
                        node.argument = argument;
                        return this.finishNode(node, "YieldExpression");
                    }
                },
                {
                    key: "parseImportCall",
                    value: function parseImportCall(node) {
                        this.next();
                        node.source = this.parseMaybeAssignAllowIn();
                        node.options = null;
                        if (this.eat(12)) {
                            if (!this.match(11)) {
                                node.options = this.parseMaybeAssignAllowIn();
                                if (this.eat(12) && !this.match(11)) {
                                    do {
                                        this.parseMaybeAssignAllowIn();
                                    }while (this.eat(12) && !this.match(11));
                                    this.raise(Errors.ImportCallArity, node);
                                }
                            }
                        }
                        this.expect(11);
                        return this.finishNode(node, "ImportExpression");
                    }
                },
                {
                    key: "checkPipelineAtInfixOperator",
                    value: function checkPipelineAtInfixOperator(left, leftStartLoc) {
                        if (this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "smart"
                            }
                        ])) {
                            if (left.type === "SequenceExpression") {
                                this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
                            }
                        }
                    }
                },
                {
                    key: "parseSmartPipelineBodyInStyle",
                    value: function parseSmartPipelineBodyInStyle(childExpr, startLoc) {
                        if (this.isSimpleReference(childExpr)) {
                            var bodyNode = this.startNodeAt(startLoc);
                            bodyNode.callee = childExpr;
                            return this.finishNode(bodyNode, "PipelineBareFunction");
                        } else {
                            var _bodyNode2 = this.startNodeAt(startLoc);
                            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
                            _bodyNode2.expression = childExpr;
                            return this.finishNode(_bodyNode2, "PipelineTopicExpression");
                        }
                    }
                },
                {
                    key: "isSimpleReference",
                    value: function isSimpleReference(expression) {
                        switch(expression.type){
                            case "MemberExpression":
                                return !expression.computed && this.isSimpleReference(expression.object);
                            case "Identifier":
                                return true;
                            default:
                                return false;
                        }
                    }
                },
                {
                    key: "checkSmartPipeTopicBodyEarlyErrors",
                    value: function checkSmartPipeTopicBodyEarlyErrors(startLoc) {
                        if (this.match(19)) {
                            throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
                        }
                        if (!this.topicReferenceWasUsedInCurrentContext()) {
                            this.raise(Errors.PipelineTopicUnused, startLoc);
                        }
                    }
                },
                {
                    key: "withTopicBindingContext",
                    value: function withTopicBindingContext(callback) {
                        var outerContextTopicState = this.state.topicContext;
                        this.state.topicContext = {
                            maxNumOfResolvableTopics: 1,
                            maxTopicIndex: null
                        };
                        try {
                            return callback();
                        } finally{
                            this.state.topicContext = outerContextTopicState;
                        }
                    }
                },
                {
                    key: "withSmartMixTopicForbiddingContext",
                    value: function withSmartMixTopicForbiddingContext(callback) {
                        if (this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "smart"
                            }
                        ])) {
                            var outerContextTopicState = this.state.topicContext;
                            this.state.topicContext = {
                                maxNumOfResolvableTopics: 0,
                                maxTopicIndex: null
                            };
                            try {
                                return callback();
                            } finally{
                                this.state.topicContext = outerContextTopicState;
                            }
                        } else {
                            return callback();
                        }
                    }
                },
                {
                    key: "withSoloAwaitPermittingContext",
                    value: function withSoloAwaitPermittingContext(callback) {
                        var outerContextSoloAwaitState = this.state.soloAwait;
                        this.state.soloAwait = true;
                        try {
                            return callback();
                        } finally{
                            this.state.soloAwait = outerContextSoloAwaitState;
                        }
                    }
                },
                {
                    key: "allowInAnd",
                    value: function allowInAnd(callback) {
                        var flags = this.prodParam.currentFlags();
                        var prodParamToSet = 8 & ~flags;
                        if (prodParamToSet) {
                            this.prodParam.enter(flags | 8);
                            try {
                                return callback();
                            } finally{
                                this.prodParam.exit();
                            }
                        }
                        return callback();
                    }
                },
                {
                    key: "disallowInAnd",
                    value: function disallowInAnd(callback) {
                        var flags = this.prodParam.currentFlags();
                        var prodParamToClear = 8 & flags;
                        if (prodParamToClear) {
                            this.prodParam.enter(flags & ~8);
                            try {
                                return callback();
                            } finally{
                                this.prodParam.exit();
                            }
                        }
                        return callback();
                    }
                },
                {
                    key: "registerTopicReference",
                    value: function registerTopicReference() {
                        this.state.topicContext.maxTopicIndex = 0;
                    }
                },
                {
                    key: "topicReferenceIsAllowedInCurrentContext",
                    value: function topicReferenceIsAllowedInCurrentContext() {
                        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
                    }
                },
                {
                    key: "topicReferenceWasUsedInCurrentContext",
                    value: function topicReferenceWasUsedInCurrentContext() {
                        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
                    }
                },
                {
                    key: "parseFSharpPipelineBody",
                    value: function parseFSharpPipelineBody(prec) {
                        var startLoc = this.state.startLoc;
                        this.state.potentialArrowAt = this.state.start;
                        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                        this.state.inFSharpPipelineDirectBody = true;
                        var ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
                        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                        return ret;
                    }
                },
                {
                    key: "parseModuleExpression",
                    value: function parseModuleExpression() {
                        this.expectPlugin("moduleBlocks");
                        var node = this.startNode();
                        this.next();
                        if (!this.match(5)) {
                            this.unexpected(null, 5);
                        }
                        var program = this.startNodeAt(this.state.endLoc);
                        this.next();
                        var revertScopes = this.initializeScopes(true);
                        this.enterInitialScopes();
                        try {
                            node.body = this.parseProgram(program, 8, "module");
                        } finally{
                            revertScopes();
                        }
                        return this.finishNode(node, "ModuleExpression");
                    }
                },
                {
                    key: "parsePropertyNamePrefixOperator",
                    value: function parsePropertyNamePrefixOperator(prop) {}
                }
            ]);
            return ExpressionParser;
        }(LValParser);
        var loopLabel = {
            kind: 1
        };
        var switchLabel = {
            kind: 2
        };
        var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
        var keywordRelationalOperator = RegExp("in(?:stanceof)?", "y");
        function babel7CompatTokens(tokens, input2, startIndex) {
            for(var i = 0; i < tokens.length; i++){
                var token = tokens[i];
                var type = token.type;
                if (typeof type === "number") {
                    {
                        if (type === 139) {
                            var loc = token.loc, start = token.start, value = token.value, end = token.end;
                            var hashEndPos = start + 1;
                            var hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                            tokens.splice(i, 1, new Token({
                                type: getExportedToken(27),
                                value: "#",
                                start: start,
                                end: hashEndPos,
                                startLoc: loc.start,
                                endLoc: hashEndLoc
                            }), new Token({
                                type: getExportedToken(132),
                                value: value,
                                start: hashEndPos,
                                end: end,
                                startLoc: hashEndLoc,
                                endLoc: loc.end
                            }));
                            i++;
                            continue;
                        }
                        if (tokenIsTemplate(type)) {
                            var _loc = token.loc, _start = token.start, _value = token.value, _end = token.end;
                            var backquoteEnd = _start + 1;
                            var backquoteEndLoc = createPositionWithColumnOffset(_loc.start, 1);
                            var startToken = void 0;
                            if (input2.charCodeAt(_start - startIndex) === 96) {
                                startToken = new Token({
                                    type: getExportedToken(22),
                                    value: "`",
                                    start: _start,
                                    end: backquoteEnd,
                                    startLoc: _loc.start,
                                    endLoc: backquoteEndLoc
                                });
                            } else {
                                startToken = new Token({
                                    type: getExportedToken(8),
                                    value: "}",
                                    start: _start,
                                    end: backquoteEnd,
                                    startLoc: _loc.start,
                                    endLoc: backquoteEndLoc
                                });
                            }
                            var templateValue = void 0, templateElementEnd = void 0, templateElementEndLoc = void 0, endToken = void 0;
                            if (type === 24) {
                                templateElementEnd = _end - 1;
                                templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -1);
                                templateValue = _value === null ? null : _value.slice(1, -1);
                                endToken = new Token({
                                    type: getExportedToken(22),
                                    value: "`",
                                    start: templateElementEnd,
                                    end: _end,
                                    startLoc: templateElementEndLoc,
                                    endLoc: _loc.end
                                });
                            } else {
                                templateElementEnd = _end - 2;
                                templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -2);
                                templateValue = _value === null ? null : _value.slice(1, -2);
                                endToken = new Token({
                                    type: getExportedToken(23),
                                    value: "${",
                                    start: templateElementEnd,
                                    end: _end,
                                    startLoc: templateElementEndLoc,
                                    endLoc: _loc.end
                                });
                            }
                            tokens.splice(i, 1, startToken, new Token({
                                type: getExportedToken(20),
                                value: templateValue,
                                start: backquoteEnd,
                                end: templateElementEnd,
                                startLoc: backquoteEndLoc,
                                endLoc: templateElementEndLoc
                            }), endToken);
                            i += 2;
                            continue;
                        }
                    }
                    token.type = getExportedToken(type);
                }
            }
            return tokens;
        }
        var StatementParser = /*#__PURE__*/ function(ExpressionParser) {
            _inherits(StatementParser, ExpressionParser);
            function StatementParser() {
                _class_call_check(this, StatementParser);
                return _call_super(this, StatementParser, arguments);
            }
            _create_class(StatementParser, [
                {
                    key: "parseTopLevel",
                    value: function parseTopLevel(file, program) {
                        file.program = this.parseProgram(program);
                        file.comments = this.comments;
                        if (this.options.tokens) {
                            file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
                        }
                        return this.finishNode(file, "File");
                    }
                },
                {
                    key: "parseProgram",
                    value: function parseProgram(program) {
                        var end = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 140;
                        var sourceType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
                        program.sourceType = sourceType;
                        program.interpreter = this.parseInterpreterDirective();
                        this.parseBlockBody(program, true, true, end);
                        if (this.inModule) {
                            if (!this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = Array.from(this.scope.undefinedExports)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var _step_value = _sliced_to_array(_step.value, 2), localName = _step_value[0], at = _step_value[1];
                                        this.raise(Errors.ModuleExportUndefined, at, {
                                            localName: localName
                                        });
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }
                            this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
                        }
                        var finishedProgram;
                        if (end === 140) {
                            finishedProgram = this.finishNode(program, "Program");
                        } else {
                            finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
                        }
                        return finishedProgram;
                    }
                },
                {
                    key: "stmtToDirective",
                    value: function stmtToDirective(stmt) {
                        var directive = stmt;
                        directive.type = "Directive";
                        directive.value = directive.expression;
                        delete directive.expression;
                        var directiveLiteral = directive.value;
                        var expressionValue = directiveLiteral.value;
                        var raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
                        var val = directiveLiteral.value = raw.slice(1, -1);
                        this.addExtra(directiveLiteral, "raw", raw);
                        this.addExtra(directiveLiteral, "rawValue", val);
                        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
                        directiveLiteral.type = "DirectiveLiteral";
                        return directive;
                    }
                },
                {
                    key: "parseInterpreterDirective",
                    value: function parseInterpreterDirective() {
                        if (!this.match(28)) {
                            return null;
                        }
                        var node = this.startNode();
                        node.value = this.state.value;
                        this.next();
                        return this.finishNode(node, "InterpreterDirective");
                    }
                },
                {
                    key: "isLet",
                    value: function isLet() {
                        if (!this.isContextual(100)) {
                            return false;
                        }
                        return this.hasFollowingBindingAtom();
                    }
                },
                {
                    key: "chStartsBindingIdentifier",
                    value: function chStartsBindingIdentifier(ch, pos) {
                        if (isIdentifierStart(ch)) {
                            keywordRelationalOperator.lastIndex = pos;
                            if (keywordRelationalOperator.test(this.input)) {
                                var endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
                                if (!isIdentifierChar(endCh) && endCh !== 92) {
                                    return false;
                                }
                            }
                            return true;
                        } else if (ch === 92) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                },
                {
                    key: "chStartsBindingPattern",
                    value: function chStartsBindingPattern(ch) {
                        return ch === 91 || ch === 123;
                    }
                },
                {
                    key: "hasFollowingBindingAtom",
                    value: function hasFollowingBindingAtom() {
                        var next = this.nextTokenStart();
                        var nextCh = this.codePointAtPos(next);
                        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
                    }
                },
                {
                    key: "hasInLineFollowingBindingIdentifierOrBrace",
                    value: function hasInLineFollowingBindingIdentifierOrBrace() {
                        var next = this.nextTokenInLineStart();
                        var nextCh = this.codePointAtPos(next);
                        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
                    }
                },
                {
                    key: "startsUsingForOf",
                    value: function startsUsingForOf() {
                        var _this_lookahead = this.lookahead(), type = _this_lookahead.type, containsEsc = _this_lookahead.containsEsc;
                        if (type === 102 && !containsEsc) {
                            return false;
                        } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
                            this.expectPlugin("explicitResourceManagement");
                            return true;
                        }
                    }
                },
                {
                    key: "startsAwaitUsing",
                    value: function startsAwaitUsing() {
                        var next = this.nextTokenInLineStart();
                        if (this.isUnparsedContextual(next, "using")) {
                            next = this.nextTokenInLineStartSince(next + 5);
                            var nextCh = this.codePointAtPos(next);
                            if (this.chStartsBindingIdentifier(nextCh, next)) {
                                this.expectPlugin("explicitResourceManagement");
                                return true;
                            }
                        }
                        return false;
                    }
                },
                {
                    key: "parseModuleItem",
                    value: function parseModuleItem() {
                        return this.parseStatementLike(1 | 2 | 4 | 8);
                    }
                },
                {
                    key: "parseStatementListItem",
                    value: function parseStatementListItem() {
                        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
                    }
                },
                {
                    key: "parseStatementOrSloppyAnnexBFunctionDeclaration",
                    value: function parseStatementOrSloppyAnnexBFunctionDeclaration() {
                        var allowLabeledFunction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                        var flags = 0;
                        if (this.options.annexB && !this.state.strict) {
                            flags |= 4;
                            if (allowLabeledFunction) {
                                flags |= 8;
                            }
                        }
                        return this.parseStatementLike(flags);
                    }
                },
                {
                    key: "parseStatement",
                    value: function parseStatement() {
                        return this.parseStatementLike(0);
                    }
                },
                {
                    key: "parseStatementLike",
                    value: function parseStatementLike(flags) {
                        var decorators = null;
                        if (this.match(26)) {
                            decorators = this.parseDecorators(true);
                        }
                        return this.parseStatementContent(flags, decorators);
                    }
                },
                {
                    key: "parseStatementContent",
                    value: function parseStatementContent(flags, decorators) {
                        var startType = this.state.type;
                        var node = this.startNode();
                        var allowDeclaration = !!(flags & 2);
                        var allowFunctionDeclaration = !!(flags & 4);
                        var topLevel = flags & 1;
                        switch(startType){
                            case 60:
                                return this.parseBreakContinueStatement(node, true);
                            case 63:
                                return this.parseBreakContinueStatement(node, false);
                            case 64:
                                return this.parseDebuggerStatement(node);
                            case 90:
                                return this.parseDoWhileStatement(node);
                            case 91:
                                return this.parseForStatement(node);
                            case 68:
                                if (this.lookaheadCharCode() === 46) break;
                                if (!allowFunctionDeclaration) {
                                    this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
                                }
                                return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
                            case 80:
                                if (!allowDeclaration) this.unexpected();
                                return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
                            case 69:
                                return this.parseIfStatement(node);
                            case 70:
                                return this.parseReturnStatement(node);
                            case 71:
                                return this.parseSwitchStatement(node);
                            case 72:
                                return this.parseThrowStatement(node);
                            case 73:
                                return this.parseTryStatement(node);
                            case 96:
                                if (!this.state.containsEsc && this.startsAwaitUsing()) {
                                    if (!this.recordAwaitIfAllowed()) {
                                        this.raise(Errors.AwaitUsingNotInAsyncContext, node);
                                    } else if (!allowDeclaration) {
                                        this.raise(Errors.UnexpectedLexicalDeclaration, node);
                                    }
                                    this.next();
                                    return this.parseVarStatement(node, "await using");
                                }
                                break;
                            case 107:
                                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
                                    break;
                                }
                                this.expectPlugin("explicitResourceManagement");
                                if (!this.scope.inModule && this.scope.inTopLevel) {
                                    this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
                                } else if (!allowDeclaration) {
                                    this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
                                }
                                return this.parseVarStatement(node, "using");
                            case 100:
                                {
                                    if (this.state.containsEsc) {
                                        break;
                                    }
                                    var next = this.nextTokenStart();
                                    var nextCh = this.codePointAtPos(next);
                                    if (nextCh !== 91) {
                                        if (!allowDeclaration && this.hasFollowingLineBreak()) break;
                                        if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                                            break;
                                        }
                                    }
                                }
                            case 75:
                                {
                                    if (!allowDeclaration) {
                                        this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
                                    }
                                }
                            case 74:
                                {
                                    var kind = this.state.value;
                                    return this.parseVarStatement(node, kind);
                                }
                            case 92:
                                return this.parseWhileStatement(node);
                            case 76:
                                return this.parseWithStatement(node);
                            case 5:
                                return this.parseBlock();
                            case 13:
                                return this.parseEmptyStatement(node);
                            case 83:
                                {
                                    var nextTokenCharCode = this.lookaheadCharCode();
                                    if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                                        break;
                                    }
                                }
                            case 82:
                                {
                                    if (!this.options.allowImportExportEverywhere && !topLevel) {
                                        this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
                                    }
                                    this.next();
                                    var result;
                                    if (startType === 83) {
                                        result = this.parseImport(node);
                                        if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                                            this.sawUnambiguousESM = true;
                                        }
                                    } else {
                                        result = this.parseExport(node, decorators);
                                        if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                                            this.sawUnambiguousESM = true;
                                        }
                                    }
                                    this.assertModuleNodeAllowed(result);
                                    return result;
                                }
                            default:
                                {
                                    if (this.isAsyncFunction()) {
                                        if (!allowDeclaration) {
                                            this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
                                        }
                                        this.next();
                                        return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
                                    }
                                }
                        }
                        var maybeName = this.state.value;
                        var expr = this.parseExpression();
                        if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
                            return this.parseLabeledStatement(node, maybeName, expr, flags);
                        } else {
                            return this.parseExpressionStatement(node, expr, decorators);
                        }
                    }
                },
                {
                    key: "assertModuleNodeAllowed",
                    value: function assertModuleNodeAllowed(node) {
                        if (!this.options.allowImportExportEverywhere && !this.inModule) {
                            this.raise(Errors.ImportOutsideModule, node);
                        }
                    }
                },
                {
                    key: "decoratorsEnabledBeforeExport",
                    value: function decoratorsEnabledBeforeExport() {
                        if (this.hasPlugin("decorators-legacy")) return true;
                        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
                    }
                },
                {
                    key: "maybeTakeDecorators",
                    value: function maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
                        if (maybeDecorators) {
                            if (classNode.decorators && classNode.decorators.length > 0) {
                                var _classNode_decorators;
                                if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
                                    this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
                                }
                                (_classNode_decorators = classNode.decorators).unshift.apply(_classNode_decorators, _to_consumable_array(maybeDecorators));
                            } else {
                                classNode.decorators = maybeDecorators;
                            }
                            this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
                            if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
                        }
                        return classNode;
                    }
                },
                {
                    key: "canHaveLeadingDecorator",
                    value: function canHaveLeadingDecorator() {
                        return this.match(80);
                    }
                },
                {
                    key: "parseDecorators",
                    value: function parseDecorators(allowExport) {
                        var decorators = [];
                        do {
                            decorators.push(this.parseDecorator());
                        }while (this.match(26));
                        if (this.match(82)) {
                            if (!allowExport) {
                                this.unexpected();
                            }
                            if (!this.decoratorsEnabledBeforeExport()) {
                                this.raise(Errors.DecoratorExportClass, this.state.startLoc);
                            }
                        } else if (!this.canHaveLeadingDecorator()) {
                            throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
                        }
                        return decorators;
                    }
                },
                {
                    key: "parseDecorator",
                    value: function parseDecorator() {
                        this.expectOnePlugin([
                            "decorators",
                            "decorators-legacy"
                        ]);
                        var node = this.startNode();
                        this.next();
                        if (this.hasPlugin("decorators")) {
                            var startLoc = this.state.startLoc;
                            var expr;
                            if (this.match(10)) {
                                var _startLoc3 = this.state.startLoc;
                                this.next();
                                expr = this.parseExpression();
                                this.expect(11);
                                expr = this.wrapParenthesis(_startLoc3, expr);
                                var paramsStartLoc = this.state.startLoc;
                                node.expression = this.parseMaybeDecoratorArguments(expr);
                                if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
                                    this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
                                }
                            } else {
                                expr = this.parseIdentifier(false);
                                while(this.eat(16)){
                                    var _node13 = this.startNodeAt(startLoc);
                                    _node13.object = expr;
                                    if (this.match(139)) {
                                        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                                        _node13.property = this.parsePrivateName();
                                    } else {
                                        _node13.property = this.parseIdentifier(true);
                                    }
                                    _node13.computed = false;
                                    expr = this.finishNode(_node13, "MemberExpression");
                                }
                                node.expression = this.parseMaybeDecoratorArguments(expr);
                            }
                        } else {
                            node.expression = this.parseExprSubscripts();
                        }
                        return this.finishNode(node, "Decorator");
                    }
                },
                {
                    key: "parseMaybeDecoratorArguments",
                    value: function parseMaybeDecoratorArguments(expr) {
                        if (this.eat(10)) {
                            var node = this.startNodeAtNode(expr);
                            node.callee = expr;
                            node.arguments = this.parseCallExpressionArguments(11);
                            this.toReferencedList(node.arguments);
                            return this.finishNode(node, "CallExpression");
                        }
                        return expr;
                    }
                },
                {
                    key: "parseBreakContinueStatement",
                    value: function parseBreakContinueStatement(node, isBreak) {
                        this.next();
                        if (this.isLineTerminator()) {
                            node.label = null;
                        } else {
                            node.label = this.parseIdentifier();
                            this.semicolon();
                        }
                        this.verifyBreakContinue(node, isBreak);
                        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
                    }
                },
                {
                    key: "verifyBreakContinue",
                    value: function verifyBreakContinue(node, isBreak) {
                        var i;
                        for(i = 0; i < this.state.labels.length; ++i){
                            var lab = this.state.labels[i];
                            if (node.label == null || lab.name === node.label.name) {
                                if (lab.kind != null && (isBreak || lab.kind === 1)) {
                                    break;
                                }
                                if (node.label && isBreak) break;
                            }
                        }
                        if (i === this.state.labels.length) {
                            var type = isBreak ? "BreakStatement" : "ContinueStatement";
                            this.raise(Errors.IllegalBreakContinue, node, {
                                type: type
                            });
                        }
                    }
                },
                {
                    key: "parseDebuggerStatement",
                    value: function parseDebuggerStatement(node) {
                        this.next();
                        this.semicolon();
                        return this.finishNode(node, "DebuggerStatement");
                    }
                },
                {
                    key: "parseHeaderExpression",
                    value: function parseHeaderExpression() {
                        this.expect(10);
                        var val = this.parseExpression();
                        this.expect(11);
                        return val;
                    }
                },
                {
                    key: "parseDoWhileStatement",
                    value: function parseDoWhileStatement(node) {
                        var _this = this;
                        this.next();
                        this.state.labels.push(loopLabel);
                        node.body = this.withSmartMixTopicForbiddingContext(function() {
                            return _this.parseStatement();
                        });
                        this.state.labels.pop();
                        this.expect(92);
                        node.test = this.parseHeaderExpression();
                        this.eat(13);
                        return this.finishNode(node, "DoWhileStatement");
                    }
                },
                {
                    key: "parseForStatement",
                    value: function parseForStatement(node) {
                        this.next();
                        this.state.labels.push(loopLabel);
                        var awaitAt = null;
                        if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
                            awaitAt = this.state.startLoc;
                            this.next();
                        }
                        this.scope.enter(0);
                        this.expect(10);
                        if (this.match(13)) {
                            if (awaitAt !== null) {
                                this.unexpected(awaitAt);
                            }
                            return this.parseFor(node, null);
                        }
                        var startsWithLet = this.isContextual(100);
                        {
                            var startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
                            var starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
                            var isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
                            if (this.match(74) || this.match(75) || isLetOrUsing) {
                                var initNode = this.startNode();
                                var kind;
                                if (startsWithAwaitUsing) {
                                    kind = "await using";
                                    if (!this.recordAwaitIfAllowed()) {
                                        this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
                                    }
                                    this.next();
                                } else {
                                    kind = this.state.value;
                                }
                                this.next();
                                this.parseVar(initNode, true, kind);
                                var _init = this.finishNode(initNode, "VariableDeclaration");
                                var isForIn = this.match(58);
                                if (isForIn && starsWithUsingDeclaration) {
                                    this.raise(Errors.ForInUsing, _init);
                                }
                                if ((isForIn || this.isContextual(102)) && _init.declarations.length === 1) {
                                    return this.parseForIn(node, _init, awaitAt);
                                }
                                if (awaitAt !== null) {
                                    this.unexpected(awaitAt);
                                }
                                return this.parseFor(node, _init);
                            }
                        }
                        var startsWithAsync = this.isContextual(95);
                        var refExpressionErrors = new ExpressionErrors();
                        var init = this.parseExpression(true, refExpressionErrors);
                        var isForOf = this.isContextual(102);
                        if (isForOf) {
                            if (startsWithLet) {
                                this.raise(Errors.ForOfLet, init);
                            }
                            if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
                                this.raise(Errors.ForOfAsync, init);
                            }
                        }
                        if (isForOf || this.match(58)) {
                            this.checkDestructuringPrivate(refExpressionErrors);
                            this.toAssignable(init, true);
                            var type = isForOf ? "ForOfStatement" : "ForInStatement";
                            this.checkLVal(init, {
                                type: type
                            });
                            return this.parseForIn(node, init, awaitAt);
                        } else {
                            this.checkExpressionErrors(refExpressionErrors, true);
                        }
                        if (awaitAt !== null) {
                            this.unexpected(awaitAt);
                        }
                        return this.parseFor(node, init);
                    }
                },
                {
                    key: "parseFunctionStatement",
                    value: function parseFunctionStatement(node, isAsync, isHangingDeclaration) {
                        this.next();
                        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
                    }
                },
                {
                    key: "parseIfStatement",
                    value: function parseIfStatement(node) {
                        this.next();
                        node.test = this.parseHeaderExpression();
                        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
                        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
                        return this.finishNode(node, "IfStatement");
                    }
                },
                {
                    key: "parseReturnStatement",
                    value: function parseReturnStatement(node) {
                        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
                            this.raise(Errors.IllegalReturn, this.state.startLoc);
                        }
                        this.next();
                        if (this.isLineTerminator()) {
                            node.argument = null;
                        } else {
                            node.argument = this.parseExpression();
                            this.semicolon();
                        }
                        return this.finishNode(node, "ReturnStatement");
                    }
                },
                {
                    key: "parseSwitchStatement",
                    value: function parseSwitchStatement(node) {
                        this.next();
                        node.discriminant = this.parseHeaderExpression();
                        var cases = node.cases = [];
                        this.expect(5);
                        this.state.labels.push(switchLabel);
                        this.scope.enter(0);
                        var cur;
                        for(var sawDefault; !this.match(8);){
                            if (this.match(61) || this.match(65)) {
                                var isCase = this.match(61);
                                if (cur) this.finishNode(cur, "SwitchCase");
                                cases.push(cur = this.startNode());
                                cur.consequent = [];
                                this.next();
                                if (isCase) {
                                    cur.test = this.parseExpression();
                                } else {
                                    if (sawDefault) {
                                        this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
                                    }
                                    sawDefault = true;
                                    cur.test = null;
                                }
                                this.expect(14);
                            } else {
                                if (cur) {
                                    cur.consequent.push(this.parseStatementListItem());
                                } else {
                                    this.unexpected();
                                }
                            }
                        }
                        this.scope.exit();
                        if (cur) this.finishNode(cur, "SwitchCase");
                        this.next();
                        this.state.labels.pop();
                        return this.finishNode(node, "SwitchStatement");
                    }
                },
                {
                    key: "parseThrowStatement",
                    value: function parseThrowStatement(node) {
                        this.next();
                        if (this.hasPrecedingLineBreak()) {
                            this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
                        }
                        node.argument = this.parseExpression();
                        this.semicolon();
                        return this.finishNode(node, "ThrowStatement");
                    }
                },
                {
                    key: "parseCatchClauseParam",
                    value: function parseCatchClauseParam() {
                        var param = this.parseBindingAtom();
                        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
                        this.checkLVal(param, {
                            type: "CatchClause"
                        }, 9);
                        return param;
                    }
                },
                {
                    key: "parseTryStatement",
                    value: function parseTryStatement(node) {
                        var _this = this;
                        this.next();
                        node.block = this.parseBlock();
                        node.handler = null;
                        if (this.match(62)) {
                            var clause = this.startNode();
                            this.next();
                            if (this.match(10)) {
                                this.expect(10);
                                clause.param = this.parseCatchClauseParam();
                                this.expect(11);
                            } else {
                                clause.param = null;
                                this.scope.enter(0);
                            }
                            clause.body = this.withSmartMixTopicForbiddingContext(function() {
                                return _this.parseBlock(false, false);
                            });
                            this.scope.exit();
                            node.handler = this.finishNode(clause, "CatchClause");
                        }
                        node.finalizer = this.eat(67) ? this.parseBlock() : null;
                        if (!node.handler && !node.finalizer) {
                            this.raise(Errors.NoCatchOrFinally, node);
                        }
                        return this.finishNode(node, "TryStatement");
                    }
                },
                {
                    key: "parseVarStatement",
                    value: function parseVarStatement(node, kind) {
                        var allowMissingInitializer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        this.next();
                        this.parseVar(node, false, kind, allowMissingInitializer);
                        this.semicolon();
                        return this.finishNode(node, "VariableDeclaration");
                    }
                },
                {
                    key: "parseWhileStatement",
                    value: function parseWhileStatement(node) {
                        var _this = this;
                        this.next();
                        node.test = this.parseHeaderExpression();
                        this.state.labels.push(loopLabel);
                        node.body = this.withSmartMixTopicForbiddingContext(function() {
                            return _this.parseStatement();
                        });
                        this.state.labels.pop();
                        return this.finishNode(node, "WhileStatement");
                    }
                },
                {
                    key: "parseWithStatement",
                    value: function parseWithStatement(node) {
                        var _this = this;
                        if (this.state.strict) {
                            this.raise(Errors.StrictWith, this.state.startLoc);
                        }
                        this.next();
                        node.object = this.parseHeaderExpression();
                        node.body = this.withSmartMixTopicForbiddingContext(function() {
                            return _this.parseStatement();
                        });
                        return this.finishNode(node, "WithStatement");
                    }
                },
                {
                    key: "parseEmptyStatement",
                    value: function parseEmptyStatement(node) {
                        this.next();
                        return this.finishNode(node, "EmptyStatement");
                    }
                },
                {
                    key: "parseLabeledStatement",
                    value: function parseLabeledStatement(node, maybeName, expr, flags) {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = this.state.labels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var label = _step.value;
                                if (label.name === maybeName) {
                                    this.raise(Errors.LabelRedeclaration, expr, {
                                        labelName: maybeName
                                    });
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        var kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
                        for(var i = this.state.labels.length - 1; i >= 0; i--){
                            var _label = this.state.labels[i];
                            if (_label.statementStart === node.start) {
                                _label.statementStart = this.sourceToOffsetPos(this.state.start);
                                _label.kind = kind;
                            } else {
                                break;
                            }
                        }
                        this.state.labels.push({
                            name: maybeName,
                            kind: kind,
                            statementStart: this.sourceToOffsetPos(this.state.start)
                        });
                        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
                        this.state.labels.pop();
                        node.label = expr;
                        return this.finishNode(node, "LabeledStatement");
                    }
                },
                {
                    key: "parseExpressionStatement",
                    value: function parseExpressionStatement(node, expr, decorators) {
                        node.expression = expr;
                        this.semicolon();
                        return this.finishNode(node, "ExpressionStatement");
                    }
                },
                {
                    key: "parseBlock",
                    value: function parseBlock() {
                        var allowDirectives = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                        var createNewLexicalScope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                        var afterBlockParse = arguments.length > 2 ? arguments[2] : void 0;
                        var node = this.startNode();
                        if (allowDirectives) {
                            this.state.strictErrors.clear();
                        }
                        this.expect(5);
                        if (createNewLexicalScope) {
                            this.scope.enter(0);
                        }
                        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
                        if (createNewLexicalScope) {
                            this.scope.exit();
                        }
                        return this.finishNode(node, "BlockStatement");
                    }
                },
                {
                    key: "isValidDirective",
                    value: function isValidDirective(stmt) {
                        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
                    }
                },
                {
                    key: "parseBlockBody",
                    value: function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
                        var body3 = node.body = [];
                        var directives = node.directives = [];
                        this.parseBlockOrModuleBlockBody(body3, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
                    }
                },
                {
                    key: "parseBlockOrModuleBlockBody",
                    value: function parseBlockOrModuleBlockBody(body3, directives, topLevel, end, afterBlockParse) {
                        var oldStrict = this.state.strict;
                        var hasStrictModeDirective = false;
                        var parsedNonDirective = false;
                        while(!this.match(end)){
                            var stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
                            if (directives && !parsedNonDirective) {
                                if (this.isValidDirective(stmt)) {
                                    var directive = this.stmtToDirective(stmt);
                                    directives.push(directive);
                                    if (!hasStrictModeDirective && directive.value.value === "use strict") {
                                        hasStrictModeDirective = true;
                                        this.setStrict(true);
                                    }
                                    continue;
                                }
                                parsedNonDirective = true;
                                this.state.strictErrors.clear();
                            }
                            body3.push(stmt);
                        }
                        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
                        if (!oldStrict) {
                            this.setStrict(false);
                        }
                        this.next();
                    }
                },
                {
                    key: "parseFor",
                    value: function parseFor(node, init) {
                        var _this = this;
                        node.init = init;
                        this.semicolon(false);
                        node.test = this.match(13) ? null : this.parseExpression();
                        this.semicolon(false);
                        node.update = this.match(11) ? null : this.parseExpression();
                        this.expect(11);
                        node.body = this.withSmartMixTopicForbiddingContext(function() {
                            return _this.parseStatement();
                        });
                        this.scope.exit();
                        this.state.labels.pop();
                        return this.finishNode(node, "ForStatement");
                    }
                },
                {
                    key: "parseForIn",
                    value: function parseForIn(node, init, awaitAt) {
                        var _this = this;
                        var isForIn = this.match(58);
                        this.next();
                        if (isForIn) {
                            if (awaitAt !== null) this.unexpected(awaitAt);
                        } else {
                            node.await = awaitAt !== null;
                        }
                        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
                            this.raise(Errors.ForInOfLoopInitializer, init, {
                                type: isForIn ? "ForInStatement" : "ForOfStatement"
                            });
                        }
                        if (init.type === "AssignmentPattern") {
                            this.raise(Errors.InvalidLhs, init, {
                                ancestor: {
                                    type: "ForStatement"
                                }
                            });
                        }
                        node.left = init;
                        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
                        this.expect(11);
                        node.body = this.withSmartMixTopicForbiddingContext(function() {
                            return _this.parseStatement();
                        });
                        this.scope.exit();
                        this.state.labels.pop();
                        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
                    }
                },
                {
                    key: "parseVar",
                    value: function parseVar(node, isFor, kind) {
                        var allowMissingInitializer = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                        var declarations = node.declarations = [];
                        node.kind = kind;
                        for(;;){
                            var decl = this.startNode();
                            this.parseVarId(decl, kind);
                            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
                            if (decl.init === null && !allowMissingInitializer) {
                                if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
                                    this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                                        kind: "destructuring"
                                    });
                                } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
                                    this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                                        kind: kind
                                    });
                                }
                            }
                            declarations.push(this.finishNode(decl, "VariableDeclarator"));
                            if (!this.eat(12)) break;
                        }
                        return node;
                    }
                },
                {
                    key: "parseVarId",
                    value: function parseVarId(decl, kind) {
                        var id = this.parseBindingAtom();
                        if (kind === "using" || kind === "await using") {
                            if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
                                this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
                            }
                        }
                        this.checkLVal(id, {
                            type: "VariableDeclarator"
                        }, kind === "var" ? 5 : 8201);
                        decl.id = id;
                    }
                },
                {
                    key: "parseAsyncFunctionExpression",
                    value: function parseAsyncFunctionExpression(node) {
                        return this.parseFunction(node, 8);
                    }
                },
                {
                    key: "parseFunction",
                    value: function parseFunction(node) {
                        var _this = this;
                        var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                        var hangingDeclaration = flags & 2;
                        var isDeclaration = !!(flags & 1);
                        var requireId = isDeclaration && !(flags & 4);
                        var isAsync = !!(flags & 8);
                        this.initFunction(node, isAsync);
                        if (this.match(55)) {
                            if (hangingDeclaration) {
                                this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
                            }
                            this.next();
                            node.generator = true;
                        }
                        if (isDeclaration) {
                            node.id = this.parseFunctionId(requireId);
                        }
                        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                        this.state.maybeInArrowParameters = false;
                        this.scope.enter(2);
                        this.prodParam.enter(functionFlags(isAsync, node.generator));
                        if (!isDeclaration) {
                            node.id = this.parseFunctionId();
                        }
                        this.parseFunctionParams(node, false);
                        this.withSmartMixTopicForbiddingContext(function() {
                            _this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
                        });
                        this.prodParam.exit();
                        this.scope.exit();
                        if (isDeclaration && !hangingDeclaration) {
                            this.registerFunctionStatementId(node);
                        }
                        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                        return node;
                    }
                },
                {
                    key: "parseFunctionId",
                    value: function parseFunctionId(requireId) {
                        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
                    }
                },
                {
                    key: "parseFunctionParams",
                    value: function parseFunctionParams(node, isConstructor) {
                        this.expect(10);
                        this.expressionScope.enter(newParameterDeclarationScope());
                        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
                        this.expressionScope.exit();
                    }
                },
                {
                    key: "registerFunctionStatementId",
                    value: function registerFunctionStatementId(node) {
                        if (!node.id) return;
                        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
                    }
                },
                {
                    key: "parseClass",
                    value: function parseClass(node, isStatement, optionalId) {
                        this.next();
                        var oldStrict = this.state.strict;
                        this.state.strict = true;
                        this.parseClassId(node, isStatement, optionalId);
                        this.parseClassSuper(node);
                        node.body = this.parseClassBody(!!node.superClass, oldStrict);
                        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
                    }
                },
                {
                    key: "isClassProperty",
                    value: function isClassProperty() {
                        return this.match(29) || this.match(13) || this.match(8);
                    }
                },
                {
                    key: "isClassMethod",
                    value: function isClassMethod() {
                        return this.match(10);
                    }
                },
                {
                    key: "nameIsConstructor",
                    value: function nameIsConstructor(key2) {
                        return key2.type === "Identifier" && key2.name === "constructor" || key2.type === "StringLiteral" && key2.value === "constructor";
                    }
                },
                {
                    key: "isNonstaticConstructor",
                    value: function isNonstaticConstructor(method) {
                        return !method.computed && !method.static && this.nameIsConstructor(method.key);
                    }
                },
                {
                    key: "parseClassBody",
                    value: function parseClassBody(hadSuperClass, oldStrict) {
                        var _this = this;
                        this.classScope.enter();
                        var state = {
                            hadConstructor: false,
                            hadSuperClass: hadSuperClass
                        };
                        var decorators = [];
                        var classBody = this.startNode();
                        classBody.body = [];
                        this.expect(5);
                        this.withSmartMixTopicForbiddingContext(function() {
                            while(!_this.match(8)){
                                if (_this.eat(13)) {
                                    if (decorators.length > 0) {
                                        throw _this.raise(Errors.DecoratorSemicolon, _this.state.lastTokEndLoc);
                                    }
                                    continue;
                                }
                                if (_this.match(26)) {
                                    decorators.push(_this.parseDecorator());
                                    continue;
                                }
                                var member = _this.startNode();
                                if (decorators.length) {
                                    member.decorators = decorators;
                                    _this.resetStartLocationFromNode(member, decorators[0]);
                                    decorators = [];
                                }
                                _this.parseClassMember(classBody, member, state);
                                if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                                    _this.raise(Errors.DecoratorConstructor, member);
                                }
                            }
                        });
                        this.state.strict = oldStrict;
                        this.next();
                        if (decorators.length) {
                            throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
                        }
                        this.classScope.exit();
                        return this.finishNode(classBody, "ClassBody");
                    }
                },
                {
                    key: "parseClassMemberFromModifier",
                    value: function parseClassMemberFromModifier(classBody, member) {
                        var key2 = this.parseIdentifier(true);
                        if (this.isClassMethod()) {
                            var method = member;
                            method.kind = "method";
                            method.computed = false;
                            method.key = key2;
                            method.static = false;
                            this.pushClassMethod(classBody, method, false, false, false, false);
                            return true;
                        } else if (this.isClassProperty()) {
                            var prop = member;
                            prop.computed = false;
                            prop.key = key2;
                            prop.static = false;
                            classBody.body.push(this.parseClassProperty(prop));
                            return true;
                        }
                        this.resetPreviousNodeTrailingComments(key2);
                        return false;
                    }
                },
                {
                    key: "parseClassMember",
                    value: function parseClassMember(classBody, member, state) {
                        var isStatic = this.isContextual(106);
                        if (isStatic) {
                            if (this.parseClassMemberFromModifier(classBody, member)) {
                                return;
                            }
                            if (this.eat(5)) {
                                this.parseClassStaticBlock(classBody, member);
                                return;
                            }
                        }
                        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
                    }
                },
                {
                    key: "parseClassMemberWithIsStatic",
                    value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
                        var publicMethod = member;
                        var privateMethod = member;
                        var publicProp = member;
                        var privateProp = member;
                        var accessorProp = member;
                        var method = publicMethod;
                        var publicMember = publicMethod;
                        member.static = isStatic;
                        this.parsePropertyNamePrefixOperator(member);
                        if (this.eat(55)) {
                            method.kind = "method";
                            var isPrivateName = this.match(139);
                            this.parseClassElementName(method);
                            if (isPrivateName) {
                                this.pushClassPrivateMethod(classBody, privateMethod, true, false);
                                return;
                            }
                            if (this.isNonstaticConstructor(publicMethod)) {
                                this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
                            }
                            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
                            return;
                        }
                        var isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
                        var key2 = this.parseClassElementName(member);
                        var maybeContextualKw = isContextual ? key2.name : null;
                        var isPrivate = this.isPrivateName(key2);
                        var maybeQuestionTokenStartLoc = this.state.startLoc;
                        this.parsePostMemberNameModifiers(publicMember);
                        if (this.isClassMethod()) {
                            method.kind = "method";
                            if (isPrivate) {
                                this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                                return;
                            }
                            var isConstructor = this.isNonstaticConstructor(publicMethod);
                            var allowsDirectSuper = false;
                            if (isConstructor) {
                                publicMethod.kind = "constructor";
                                if (state.hadConstructor && !this.hasPlugin("typescript")) {
                                    this.raise(Errors.DuplicateConstructor, key2);
                                }
                                if (isConstructor && this.hasPlugin("typescript") && member.override) {
                                    this.raise(Errors.OverrideOnConstructor, key2);
                                }
                                state.hadConstructor = true;
                                allowsDirectSuper = state.hadSuperClass;
                            }
                            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
                        } else if (this.isClassProperty()) {
                            if (isPrivate) {
                                this.pushClassPrivateProperty(classBody, privateProp);
                            } else {
                                this.pushClassProperty(classBody, publicProp);
                            }
                        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
                            this.resetPreviousNodeTrailingComments(key2);
                            var isGenerator = this.eat(55);
                            if (publicMember.optional) {
                                this.unexpected(maybeQuestionTokenStartLoc);
                            }
                            method.kind = "method";
                            var _isPrivate = this.match(139);
                            this.parseClassElementName(method);
                            this.parsePostMemberNameModifiers(publicMember);
                            if (_isPrivate) {
                                this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
                            } else {
                                if (this.isNonstaticConstructor(publicMethod)) {
                                    this.raise(Errors.ConstructorIsAsync, publicMethod.key);
                                }
                                this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
                            }
                        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
                            this.resetPreviousNodeTrailingComments(key2);
                            method.kind = maybeContextualKw;
                            var _isPrivate2 = this.match(139);
                            this.parseClassElementName(publicMethod);
                            if (_isPrivate2) {
                                this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                            } else {
                                if (this.isNonstaticConstructor(publicMethod)) {
                                    this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
                                }
                                this.pushClassMethod(classBody, publicMethod, false, false, false, false);
                            }
                            this.checkGetterSetterParams(publicMethod);
                        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
                            this.expectPlugin("decoratorAutoAccessors");
                            this.resetPreviousNodeTrailingComments(key2);
                            var _isPrivate3 = this.match(139);
                            this.parseClassElementName(publicProp);
                            this.pushClassAccessorProperty(classBody, accessorProp, _isPrivate3);
                        } else if (this.isLineTerminator()) {
                            if (isPrivate) {
                                this.pushClassPrivateProperty(classBody, privateProp);
                            } else {
                                this.pushClassProperty(classBody, publicProp);
                            }
                        } else {
                            this.unexpected();
                        }
                    }
                },
                {
                    key: "parseClassElementName",
                    value: function parseClassElementName(member) {
                        var _this_state = this.state, type = _this_state.type, value = _this_state.value;
                        if ((type === 132 || type === 134) && member.static && value === "prototype") {
                            this.raise(Errors.StaticPrototype, this.state.startLoc);
                        }
                        if (type === 139) {
                            if (value === "constructor") {
                                this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
                            }
                            var key2 = this.parsePrivateName();
                            member.key = key2;
                            return key2;
                        }
                        this.parsePropertyName(member);
                        return member.key;
                    }
                },
                {
                    key: "parseClassStaticBlock",
                    value: function parseClassStaticBlock(classBody, member) {
                        var _member$decorators;
                        this.scope.enter(64 | 128 | 16);
                        var oldLabels = this.state.labels;
                        this.state.labels = [];
                        this.prodParam.enter(0);
                        var body3 = member.body = [];
                        this.parseBlockOrModuleBlockBody(body3, void 0, false, 8);
                        this.prodParam.exit();
                        this.scope.exit();
                        this.state.labels = oldLabels;
                        classBody.body.push(this.finishNode(member, "StaticBlock"));
                        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
                            this.raise(Errors.DecoratorStaticBlock, member);
                        }
                    }
                },
                {
                    key: "pushClassProperty",
                    value: function pushClassProperty(classBody, prop) {
                        if (!prop.computed && this.nameIsConstructor(prop.key)) {
                            this.raise(Errors.ConstructorClassField, prop.key);
                        }
                        classBody.body.push(this.parseClassProperty(prop));
                    }
                },
                {
                    key: "pushClassPrivateProperty",
                    value: function pushClassPrivateProperty(classBody, prop) {
                        var node = this.parseClassPrivateProperty(prop);
                        classBody.body.push(node);
                        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
                    }
                },
                {
                    key: "pushClassAccessorProperty",
                    value: function pushClassAccessorProperty(classBody, prop, isPrivate) {
                        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
                            this.raise(Errors.ConstructorClassField, prop.key);
                        }
                        var node = this.parseClassAccessorProperty(prop);
                        classBody.body.push(node);
                        if (isPrivate) {
                            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
                        }
                    }
                },
                {
                    key: "pushClassMethod",
                    value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
                    }
                },
                {
                    key: "pushClassPrivateMethod",
                    value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
                        var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
                        classBody.body.push(node);
                        var kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
                        this.declareClassPrivateMethodInScope(node, kind);
                    }
                },
                {
                    key: "declareClassPrivateMethodInScope",
                    value: function declareClassPrivateMethodInScope(node, kind) {
                        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
                    }
                },
                {
                    key: "parsePostMemberNameModifiers",
                    value: function parsePostMemberNameModifiers(methodOrProp) {}
                },
                {
                    key: "parseClassPrivateProperty",
                    value: function parseClassPrivateProperty(node) {
                        this.parseInitializer(node);
                        this.semicolon();
                        return this.finishNode(node, "ClassPrivateProperty");
                    }
                },
                {
                    key: "parseClassProperty",
                    value: function parseClassProperty(node) {
                        this.parseInitializer(node);
                        this.semicolon();
                        return this.finishNode(node, "ClassProperty");
                    }
                },
                {
                    key: "parseClassAccessorProperty",
                    value: function parseClassAccessorProperty(node) {
                        this.parseInitializer(node);
                        this.semicolon();
                        return this.finishNode(node, "ClassAccessorProperty");
                    }
                },
                {
                    key: "parseInitializer",
                    value: function parseInitializer(node) {
                        this.scope.enter(64 | 16);
                        this.expressionScope.enter(newExpressionScope());
                        this.prodParam.enter(0);
                        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
                        this.expressionScope.exit();
                        this.prodParam.exit();
                        this.scope.exit();
                    }
                },
                {
                    key: "parseClassId",
                    value: function parseClassId(node, isStatement, optionalId) {
                        var bindingType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 8331;
                        if (tokenIsIdentifier(this.state.type)) {
                            node.id = this.parseIdentifier();
                            if (isStatement) {
                                this.declareNameFromIdentifier(node.id, bindingType);
                            }
                        } else {
                            if (optionalId || !isStatement) {
                                node.id = null;
                            } else {
                                throw this.raise(Errors.MissingClassName, this.state.startLoc);
                            }
                        }
                    }
                },
                {
                    key: "parseClassSuper",
                    value: function parseClassSuper(node) {
                        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
                    }
                },
                {
                    key: "parseExport",
                    value: function parseExport(node, decorators) {
                        var maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
                        var hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
                        var parseAfterDefault = !hasDefault || this.eat(12);
                        var hasStar = parseAfterDefault && this.eatExportStar(node);
                        var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
                        var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
                        var isFromRequired = hasDefault || hasStar;
                        if (hasStar && !hasNamespace) {
                            if (hasDefault) this.unexpected();
                            if (decorators) {
                                throw this.raise(Errors.UnsupportedDecoratorExport, node);
                            }
                            this.parseExportFrom(node, true);
                            return this.finishNode(node, "ExportAllDeclaration");
                        }
                        var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
                        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
                            this.unexpected(null, 5);
                        }
                        if (hasNamespace && parseAfterNamespace) {
                            this.unexpected(null, 98);
                        }
                        var hasDeclaration;
                        if (isFromRequired || hasSpecifiers) {
                            hasDeclaration = false;
                            if (decorators) {
                                throw this.raise(Errors.UnsupportedDecoratorExport, node);
                            }
                            this.parseExportFrom(node, isFromRequired);
                        } else {
                            hasDeclaration = this.maybeParseExportDeclaration(node);
                        }
                        if (isFromRequired || hasSpecifiers || hasDeclaration) {
                            var _node2$declaration;
                            var node2 = node;
                            this.checkExport(node2, true, false, !!node2.source);
                            if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
                                this.maybeTakeDecorators(decorators, node2.declaration, node2);
                            } else if (decorators) {
                                throw this.raise(Errors.UnsupportedDecoratorExport, node);
                            }
                            return this.finishNode(node2, "ExportNamedDeclaration");
                        }
                        if (this.eat(65)) {
                            var _node14 = node;
                            var decl = this.parseExportDefaultExpression();
                            _node14.declaration = decl;
                            if (decl.type === "ClassDeclaration") {
                                this.maybeTakeDecorators(decorators, decl, _node14);
                            } else if (decorators) {
                                throw this.raise(Errors.UnsupportedDecoratorExport, node);
                            }
                            this.checkExport(_node14, true, true);
                            return this.finishNode(_node14, "ExportDefaultDeclaration");
                        }
                        this.unexpected(null, 5);
                    }
                },
                {
                    key: "eatExportStar",
                    value: function eatExportStar(node) {
                        return this.eat(55);
                    }
                },
                {
                    key: "maybeParseExportDefaultSpecifier",
                    value: function maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
                        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
                            this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
                            var id = maybeDefaultIdentifier || this.parseIdentifier(true);
                            var specifier = this.startNodeAtNode(id);
                            specifier.exported = id;
                            node.specifiers = [
                                this.finishNode(specifier, "ExportDefaultSpecifier")
                            ];
                            return true;
                        }
                        return false;
                    }
                },
                {
                    key: "maybeParseExportNamespaceSpecifier",
                    value: function maybeParseExportNamespaceSpecifier(node) {
                        if (this.isContextual(93)) {
                            var _ref, _ref$specifiers;
                            (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
                            var specifier = this.startNodeAt(this.state.lastTokStartLoc);
                            this.next();
                            specifier.exported = this.parseModuleExportName();
                            node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
                            return true;
                        }
                        return false;
                    }
                },
                {
                    key: "maybeParseExportNamedSpecifiers",
                    value: function maybeParseExportNamedSpecifiers(node) {
                        if (this.match(5)) {
                            var _node2_specifiers;
                            var node2 = node;
                            if (!node2.specifiers) node2.specifiers = [];
                            var isTypeExport = node2.exportKind === "type";
                            (_node2_specifiers = node2.specifiers).push.apply(_node2_specifiers, _to_consumable_array(this.parseExportSpecifiers(isTypeExport)));
                            node2.source = null;
                            node2.declaration = null;
                            if (this.hasPlugin("importAssertions")) {
                                node2.assertions = [];
                            }
                            return true;
                        }
                        return false;
                    }
                },
                {
                    key: "maybeParseExportDeclaration",
                    value: function maybeParseExportDeclaration(node) {
                        if (this.shouldParseExportDeclaration()) {
                            node.specifiers = [];
                            node.source = null;
                            if (this.hasPlugin("importAssertions")) {
                                node.assertions = [];
                            }
                            node.declaration = this.parseExportDeclaration(node);
                            return true;
                        }
                        return false;
                    }
                },
                {
                    key: "isAsyncFunction",
                    value: function isAsyncFunction() {
                        if (!this.isContextual(95)) return false;
                        var next = this.nextTokenInLineStart();
                        return this.isUnparsedContextual(next, "function");
                    }
                },
                {
                    key: "parseExportDefaultExpression",
                    value: function parseExportDefaultExpression() {
                        var expr = this.startNode();
                        if (this.match(68)) {
                            this.next();
                            return this.parseFunction(expr, 1 | 4);
                        } else if (this.isAsyncFunction()) {
                            this.next();
                            this.next();
                            return this.parseFunction(expr, 1 | 4 | 8);
                        }
                        if (this.match(80)) {
                            return this.parseClass(expr, true, true);
                        }
                        if (this.match(26)) {
                            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                                this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
                            }
                            return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
                        }
                        if (this.match(75) || this.match(74) || this.isLet()) {
                            throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
                        }
                        var res = this.parseMaybeAssignAllowIn();
                        this.semicolon();
                        return res;
                    }
                },
                {
                    key: "parseExportDeclaration",
                    value: function parseExportDeclaration(node) {
                        if (this.match(80)) {
                            var _node15 = this.parseClass(this.startNode(), true, false);
                            return _node15;
                        }
                        return this.parseStatementListItem();
                    }
                },
                {
                    key: "isExportDefaultSpecifier",
                    value: function isExportDefaultSpecifier() {
                        var type = this.state.type;
                        if (tokenIsIdentifier(type)) {
                            if (type === 95 && !this.state.containsEsc || type === 100) {
                                return false;
                            }
                            if ((type === 130 || type === 129) && !this.state.containsEsc) {
                                var _this_lookahead = this.lookahead(), nextType = _this_lookahead.type;
                                if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
                                    this.expectOnePlugin([
                                        "flow",
                                        "typescript"
                                    ]);
                                    return false;
                                }
                            }
                        } else if (!this.match(65)) {
                            return false;
                        }
                        var next = this.nextTokenStart();
                        var hasFrom = this.isUnparsedContextual(next, "from");
                        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
                            return true;
                        }
                        if (this.match(65) && hasFrom) {
                            var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
                            return nextAfterFrom === 34 || nextAfterFrom === 39;
                        }
                        return false;
                    }
                },
                {
                    key: "parseExportFrom",
                    value: function parseExportFrom(node, expect) {
                        if (this.eatContextual(98)) {
                            node.source = this.parseImportSource();
                            this.checkExport(node);
                            this.maybeParseImportAttributes(node);
                            this.checkJSONModuleImport(node);
                        } else if (expect) {
                            this.unexpected();
                        }
                        this.semicolon();
                    }
                },
                {
                    key: "shouldParseExportDeclaration",
                    value: function shouldParseExportDeclaration() {
                        var type = this.state.type;
                        if (type === 26) {
                            this.expectOnePlugin([
                                "decorators",
                                "decorators-legacy"
                            ]);
                            if (this.hasPlugin("decorators")) {
                                if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                                    this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
                                }
                                return true;
                            }
                        }
                        if (this.isContextual(107)) {
                            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
                            return true;
                        }
                        if (this.isContextual(96) && this.startsAwaitUsing()) {
                            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
                            return true;
                        }
                        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
                    }
                },
                {
                    key: "checkExport",
                    value: function checkExport(node, checkNames, isDefault, isFrom) {
                        if (checkNames) {
                            var _node$specifiers;
                            if (isDefault) {
                                this.checkDuplicateExports(node, "default");
                                if (this.hasPlugin("exportDefaultFrom")) {
                                    var _declaration$extra;
                                    var declaration = node.declaration;
                                    if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                                        this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
                                    }
                                }
                            } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = node.specifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var specifier = _step.value;
                                        var exported = specifier.exported;
                                        var exportName = exported.type === "Identifier" ? exported.name : exported.value;
                                        this.checkDuplicateExports(specifier, exportName);
                                        if (!isFrom && specifier.local) {
                                            var local = specifier.local;
                                            if (local.type !== "Identifier") {
                                                this.raise(Errors.ExportBindingIsString, specifier, {
                                                    localName: local.value,
                                                    exportName: exportName
                                                });
                                            } else {
                                                this.checkReservedWord(local.name, local.loc.start, true, false);
                                                this.scope.checkLocalExport(local);
                                            }
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            } else if (node.declaration) {
                                var decl = node.declaration;
                                if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
                                    var id = decl.id;
                                    if (!id) throw new Error("Assertion failure");
                                    this.checkDuplicateExports(node, id.name);
                                } else if (decl.type === "VariableDeclaration") {
                                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                    try {
                                        for(var _iterator1 = decl.declarations[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                            var _declaration = _step1.value;
                                            this.checkDeclaration(_declaration.id);
                                        }
                                    } catch (err) {
                                        _didIteratorError1 = true;
                                        _iteratorError1 = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                                _iterator1.return();
                                            }
                                        } finally{
                                            if (_didIteratorError1) {
                                                throw _iteratorError1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                {
                    key: "checkDeclaration",
                    value: function checkDeclaration(node) {
                        if (node.type === "Identifier") {
                            this.checkDuplicateExports(node, node.name);
                        } else if (node.type === "ObjectPattern") {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var prop = _step.value;
                                    this.checkDeclaration(prop);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        } else if (node.type === "ArrayPattern") {
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = node.elements[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var elem = _step1.value;
                                    if (elem) {
                                        this.checkDeclaration(elem);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        } else if (node.type === "ObjectProperty") {
                            this.checkDeclaration(node.value);
                        } else if (node.type === "RestElement") {
                            this.checkDeclaration(node.argument);
                        } else if (node.type === "AssignmentPattern") {
                            this.checkDeclaration(node.left);
                        }
                    }
                },
                {
                    key: "checkDuplicateExports",
                    value: function checkDuplicateExports(node, exportName) {
                        if (this.exportedIdentifiers.has(exportName)) {
                            if (exportName === "default") {
                                this.raise(Errors.DuplicateDefaultExport, node);
                            } else {
                                this.raise(Errors.DuplicateExport, node, {
                                    exportName: exportName
                                });
                            }
                        }
                        this.exportedIdentifiers.add(exportName);
                    }
                },
                {
                    key: "parseExportSpecifiers",
                    value: function parseExportSpecifiers(isInTypeExport) {
                        var nodes = [];
                        var first = true;
                        this.expect(5);
                        while(!this.eat(8)){
                            if (first) {
                                first = false;
                            } else {
                                this.expect(12);
                                if (this.eat(8)) break;
                            }
                            var isMaybeTypeOnly = this.isContextual(130);
                            var isString = this.match(134);
                            var node = this.startNode();
                            node.local = this.parseModuleExportName();
                            nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
                        }
                        return nodes;
                    }
                },
                {
                    key: "parseExportSpecifier",
                    value: function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
                        if (this.eatContextual(93)) {
                            node.exported = this.parseModuleExportName();
                        } else if (isString) {
                            node.exported = cloneStringLiteral(node.local);
                        } else if (!node.exported) {
                            node.exported = cloneIdentifier(node.local);
                        }
                        return this.finishNode(node, "ExportSpecifier");
                    }
                },
                {
                    key: "parseModuleExportName",
                    value: function parseModuleExportName() {
                        if (this.match(134)) {
                            var result = this.parseStringLiteral(this.state.value);
                            var surrogate = loneSurrogate.exec(result.value);
                            if (surrogate) {
                                this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
                                    surrogateCharCode: surrogate[0].charCodeAt(0)
                                });
                            }
                            return result;
                        }
                        return this.parseIdentifier(true);
                    }
                },
                {
                    key: "isJSONModuleImport",
                    value: function isJSONModuleImport(node) {
                        if (node.assertions != null) {
                            return node.assertions.some(function(_ref78) {
                                var key2 = _ref78.key, value = _ref78.value;
                                return value.value === "json" && (key2.type === "Identifier" ? key2.name === "type" : key2.value === "type");
                            });
                        }
                        return false;
                    }
                },
                {
                    key: "checkImportReflection",
                    value: function checkImportReflection(node) {
                        var specifiers = node.specifiers;
                        var singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
                        if (node.phase === "source") {
                            if (singleBindingType !== "ImportDefaultSpecifier") {
                                this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
                            }
                        } else if (node.phase === "defer") {
                            if (singleBindingType !== "ImportNamespaceSpecifier") {
                                this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
                            }
                        } else if (node.module) {
                            var _node$assertions;
                            if (singleBindingType !== "ImportDefaultSpecifier") {
                                this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
                            }
                            if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
                                this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
                            }
                        }
                    }
                },
                {
                    key: "checkJSONModuleImport",
                    value: function checkJSONModuleImport(node) {
                        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
                            var specifiers = node.specifiers;
                            if (specifiers != null) {
                                var nonDefaultNamedSpecifier = specifiers.find(function(specifier) {
                                    var imported;
                                    if (specifier.type === "ExportSpecifier") {
                                        imported = specifier.local;
                                    } else if (specifier.type === "ImportSpecifier") {
                                        imported = specifier.imported;
                                    }
                                    if (imported !== void 0) {
                                        return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                                    }
                                });
                                if (nonDefaultNamedSpecifier !== void 0) {
                                    this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
                                }
                            }
                        }
                    }
                },
                {
                    key: "isPotentialImportPhase",
                    value: function isPotentialImportPhase(isExport) {
                        if (isExport) return false;
                        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
                    }
                },
                {
                    key: "applyImportPhase",
                    value: function applyImportPhase(node, isExport, phase, loc) {
                        if (isExport) {
                            return;
                        }
                        if (phase === "module") {
                            this.expectPlugin("importReflection", loc);
                            node.module = true;
                        } else if (this.hasPlugin("importReflection")) {
                            node.module = false;
                        }
                        if (phase === "source") {
                            this.expectPlugin("sourcePhaseImports", loc);
                            node.phase = "source";
                        } else if (phase === "defer") {
                            this.expectPlugin("deferredImportEvaluation", loc);
                            node.phase = "defer";
                        } else if (this.hasPlugin("sourcePhaseImports")) {
                            node.phase = null;
                        }
                    }
                },
                {
                    key: "parseMaybeImportPhase",
                    value: function parseMaybeImportPhase(node, isExport) {
                        if (!this.isPotentialImportPhase(isExport)) {
                            this.applyImportPhase(node, isExport, null);
                            return null;
                        }
                        var phaseIdentifier = this.parseIdentifier(true);
                        var type = this.state.type;
                        var isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
                        if (isImportPhase) {
                            this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
                            this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
                            return null;
                        } else {
                            this.applyImportPhase(node, isExport, null);
                            return phaseIdentifier;
                        }
                    }
                },
                {
                    key: "isPrecedingIdImportPhase",
                    value: function isPrecedingIdImportPhase(phase) {
                        var type = this.state.type;
                        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
                    }
                },
                {
                    key: "parseImport",
                    value: function parseImport(node) {
                        if (this.match(134)) {
                            return this.parseImportSourceAndAttributes(node);
                        }
                        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
                    }
                },
                {
                    key: "parseImportSpecifiersAndAfter",
                    value: function parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
                        node.specifiers = [];
                        var hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
                        var parseNext = !hasDefault || this.eat(12);
                        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
                        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
                        this.expectContextual(98);
                        return this.parseImportSourceAndAttributes(node);
                    }
                },
                {
                    key: "parseImportSourceAndAttributes",
                    value: function parseImportSourceAndAttributes(node) {
                        var _node$specifiers2;
                        (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
                        node.source = this.parseImportSource();
                        this.maybeParseImportAttributes(node);
                        this.checkImportReflection(node);
                        this.checkJSONModuleImport(node);
                        this.semicolon();
                        return this.finishNode(node, "ImportDeclaration");
                    }
                },
                {
                    key: "parseImportSource",
                    value: function parseImportSource() {
                        if (!this.match(134)) this.unexpected();
                        return this.parseExprAtom();
                    }
                },
                {
                    key: "parseImportSpecifierLocal",
                    value: function parseImportSpecifierLocal(node, specifier, type) {
                        specifier.local = this.parseIdentifier();
                        node.specifiers.push(this.finishImportSpecifier(specifier, type));
                    }
                },
                {
                    key: "finishImportSpecifier",
                    value: function finishImportSpecifier(specifier, type) {
                        var bindingType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 8201;
                        this.checkLVal(specifier.local, {
                            type: type
                        }, bindingType);
                        return this.finishNode(specifier, type);
                    }
                },
                {
                    key: "parseImportAttributes",
                    value: function parseImportAttributes() {
                        this.expect(5);
                        var attrs = [];
                        var attrNames = /* @__PURE__ */ new Set();
                        do {
                            if (this.match(8)) {
                                break;
                            }
                            var node = this.startNode();
                            var keyName = this.state.value;
                            if (attrNames.has(keyName)) {
                                this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
                                    key: keyName
                                });
                            }
                            attrNames.add(keyName);
                            if (this.match(134)) {
                                node.key = this.parseStringLiteral(keyName);
                            } else {
                                node.key = this.parseIdentifier(true);
                            }
                            this.expect(14);
                            if (!this.match(134)) {
                                throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
                            }
                            node.value = this.parseStringLiteral(this.state.value);
                            attrs.push(this.finishNode(node, "ImportAttribute"));
                        }while (this.eat(12));
                        this.expect(8);
                        return attrs;
                    }
                },
                {
                    key: "parseModuleAttributes",
                    value: function parseModuleAttributes() {
                        var attrs = [];
                        var attributes = /* @__PURE__ */ new Set();
                        do {
                            var node = this.startNode();
                            node.key = this.parseIdentifier(true);
                            if (node.key.name !== "type") {
                                this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
                            }
                            if (attributes.has(node.key.name)) {
                                this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
                                    key: node.key.name
                                });
                            }
                            attributes.add(node.key.name);
                            this.expect(14);
                            if (!this.match(134)) {
                                throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
                            }
                            node.value = this.parseStringLiteral(this.state.value);
                            attrs.push(this.finishNode(node, "ImportAttribute"));
                        }while (this.eat(12));
                        return attrs;
                    }
                },
                {
                    key: "maybeParseImportAttributes",
                    value: function maybeParseImportAttributes(node) {
                        var attributes;
                        {
                            var useWith = false;
                        }
                        if (this.match(76)) {
                            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
                                return;
                            }
                            this.next();
                            if (this.hasPlugin("moduleAttributes")) {
                                attributes = this.parseModuleAttributes();
                            } else {
                                attributes = this.parseImportAttributes();
                            }
                            {
                                useWith = true;
                            }
                        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
                            if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
                                this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
                            }
                            if (!this.hasPlugin("importAssertions")) {
                                this.addExtra(node, "deprecatedAssertSyntax", true);
                            }
                            this.next();
                            attributes = this.parseImportAttributes();
                        } else {
                            attributes = [];
                        }
                        if (!useWith && this.hasPlugin("importAssertions")) {
                            node.assertions = attributes;
                        } else {
                            node.attributes = attributes;
                        }
                    }
                },
                {
                    key: "maybeParseDefaultImportSpecifier",
                    value: function maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
                        if (maybeDefaultIdentifier) {
                            var specifier = this.startNodeAtNode(maybeDefaultIdentifier);
                            specifier.local = maybeDefaultIdentifier;
                            node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
                            return true;
                        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                            this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
                            return true;
                        }
                        return false;
                    }
                },
                {
                    key: "maybeParseStarImportSpecifier",
                    value: function maybeParseStarImportSpecifier(node) {
                        if (this.match(55)) {
                            var specifier = this.startNode();
                            this.next();
                            this.expectContextual(93);
                            this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
                            return true;
                        }
                        return false;
                    }
                },
                {
                    key: "parseNamedImportSpecifiers",
                    value: function parseNamedImportSpecifiers(node) {
                        var first = true;
                        this.expect(5);
                        while(!this.eat(8)){
                            if (first) {
                                first = false;
                            } else {
                                if (this.eat(14)) {
                                    throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
                                }
                                this.expect(12);
                                if (this.eat(8)) break;
                            }
                            var specifier = this.startNode();
                            var importedIsString = this.match(134);
                            var isMaybeTypeOnly = this.isContextual(130);
                            specifier.imported = this.parseModuleExportName();
                            var importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
                            node.specifiers.push(importSpecifier);
                        }
                    }
                },
                {
                    key: "parseImportSpecifier",
                    value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
                        if (this.eatContextual(93)) {
                            specifier.local = this.parseIdentifier();
                        } else {
                            var imported = specifier.imported;
                            if (importedIsString) {
                                throw this.raise(Errors.ImportBindingIsString, specifier, {
                                    importName: imported.value
                                });
                            }
                            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
                            if (!specifier.local) {
                                specifier.local = cloneIdentifier(imported);
                            }
                        }
                        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
                    }
                },
                {
                    key: "isThisParam",
                    value: function isThisParam(param) {
                        return param.type === "Identifier" && param.name === "this";
                    }
                }
            ]);
            return StatementParser;
        }(ExpressionParser);
        var Parser = /*#__PURE__*/ function(StatementParser) {
            _inherits(Parser, StatementParser);
            function Parser(options, input2, pluginsMap) {
                _class_call_check(this, Parser);
                var _this;
                options = getOptions(options);
                _this = _call_super(this, Parser, [
                    options,
                    input2
                ]);
                _this.options = options;
                _this.initializeScopes();
                _this.plugins = pluginsMap;
                _this.filename = options.sourceFilename;
                _this.startIndex = options.startIndex;
                return _this;
            }
            _create_class(Parser, [
                {
                    key: "getScopeHandler",
                    value: function getScopeHandler() {
                        return ScopeHandler;
                    }
                },
                {
                    key: "parse",
                    value: function parse() {
                        this.enterInitialScopes();
                        var file = this.startNode();
                        var program = this.startNode();
                        this.nextToken();
                        file.errors = null;
                        this.parseTopLevel(file, program);
                        file.errors = this.state.errors;
                        file.comments.length = this.state.commentsLen;
                        return file;
                    }
                }
            ]);
            return Parser;
        }(StatementParser);
        function parse2(input2, options) {
            var _options;
            if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
                options = Object.assign({}, options);
                try {
                    options.sourceType = "module";
                    var parser = getParser(options, input2);
                    var ast = parser.parse();
                    if (parser.sawUnambiguousESM) {
                        return ast;
                    }
                    if (parser.ambiguousScriptDifferentAst) {
                        try {
                            options.sourceType = "script";
                            return getParser(options, input2).parse();
                        } catch (_unused) {}
                    } else {
                        ast.program.sourceType = "script";
                    }
                    return ast;
                } catch (moduleError) {
                    try {
                        options.sourceType = "script";
                        return getParser(options, input2).parse();
                    } catch (_unused2) {}
                    throw moduleError;
                }
            } else {
                return getParser(options, input2).parse();
            }
        }
        function parseExpression(input2, options) {
            var parser = getParser(options, input2);
            if (parser.options.strictMode) {
                parser.state.strict = true;
            }
            return parser.getExpression();
        }
        function generateExportedTokenTypes(internalTokenTypes) {
            var tokenTypes2 = {};
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.keys(internalTokenTypes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var typeName = _step.value;
                    tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return tokenTypes2;
        }
        var tokTypes = generateExportedTokenTypes(tt);
        function getParser(options, input2) {
            var cls = Parser;
            var pluginsMap = /* @__PURE__ */ new Map();
            if (options != null && options.plugins) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var plugin = _step.value;
                        var name = void 0, opts = void 0;
                        if (typeof plugin === "string") {
                            name = plugin;
                        } else {
                            var ref;
                            ref = _sliced_to_array(plugin, 2), name = ref[0], opts = ref[1], ref;
                        }
                        if (!pluginsMap.has(name)) {
                            pluginsMap.set(name, opts || {});
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                validatePlugins(pluginsMap);
                cls = getParserClass(pluginsMap);
            }
            return new cls(options, input2, pluginsMap);
        }
        var parserClassCache = /* @__PURE__ */ new Map();
        function getParserClass(pluginsMap) {
            var pluginList = [];
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = mixinPluginNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var name = _step.value;
                    if (pluginsMap.has(name)) {
                        pluginList.push(name);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            var key2 = pluginList.join("|");
            var cls = parserClassCache.get(key2);
            if (!cls) {
                cls = Parser;
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = pluginList[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var plugin = _step1.value;
                        cls = mixinPlugins[plugin](cls);
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                parserClassCache.set(key2, cls);
            }
            return cls;
        }
        exports.parse = parse2;
        exports.parseExpression = parseExpression;
        exports.tokTypes = tokTypes;
    }
});
// ../../node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
    "../../node_modules/@babel/types/lib/utils/shallowEqual.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = shallowEqual;
        function shallowEqual(actual, expected) {
            var keys = Object.keys(expected);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key2 = _step.value;
                    if (actual[key2] !== expected[key2]) {
                        return false;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return true;
        }
    }
});
// ../../node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
    "../../node_modules/@babel/types/lib/utils/deprecationWarning.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = deprecationWarning;
        var warnings = /* @__PURE__ */ new Set();
        function deprecationWarning(oldName, newName) {
            var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
            if (warnings.has(oldName)) return;
            warnings.add(oldName);
            var _captureShortStackTrace = captureShortStackTrace(1, 2), internal = _captureShortStackTrace.internal, trace = _captureShortStackTrace.trace;
            if (internal) {
                return;
            }
            console.warn("".concat(prefix, "`").concat(oldName, "` has been deprecated, please migrate to `").concat(newName, "`\n").concat(trace));
        }
        function captureShortStackTrace(skip, length) {
            var stackTraceLimit = Error.stackTraceLimit, prepareStackTrace = Error.prepareStackTrace;
            var stackTrace;
            Error.stackTraceLimit = 1 + skip + length;
            Error.prepareStackTrace = function(err, stack) {
                stackTrace = stack;
            };
            new Error().stack;
            Error.stackTraceLimit = stackTraceLimit;
            Error.prepareStackTrace = prepareStackTrace;
            if (!stackTrace) return {
                internal: false,
                trace: ""
            };
            var shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
            return {
                internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
                trace: shortStackTrace.map(function(frame) {
                    return "    at ".concat(frame);
                }).join("\n")
            };
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
    "../../node_modules/@babel/types/lib/validators/generated/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.isAccessor = isAccessor;
        exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
        exports.isArgumentPlaceholder = isArgumentPlaceholder;
        exports.isArrayExpression = isArrayExpression2;
        exports.isArrayPattern = isArrayPattern;
        exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
        exports.isArrowFunctionExpression = isArrowFunctionExpression;
        exports.isAssignmentExpression = isAssignmentExpression;
        exports.isAssignmentPattern = isAssignmentPattern;
        exports.isAwaitExpression = isAwaitExpression;
        exports.isBigIntLiteral = isBigIntLiteral;
        exports.isBinary = isBinary;
        exports.isBinaryExpression = isBinaryExpression;
        exports.isBindExpression = isBindExpression;
        exports.isBlock = isBlock;
        exports.isBlockParent = isBlockParent;
        exports.isBlockStatement = isBlockStatement;
        exports.isBooleanLiteral = isBooleanLiteral2;
        exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
        exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
        exports.isBreakStatement = isBreakStatement;
        exports.isCallExpression = isCallExpression;
        exports.isCatchClause = isCatchClause;
        exports.isClass = isClass;
        exports.isClassAccessorProperty = isClassAccessorProperty;
        exports.isClassBody = isClassBody;
        exports.isClassDeclaration = isClassDeclaration;
        exports.isClassExpression = isClassExpression;
        exports.isClassImplements = isClassImplements;
        exports.isClassMethod = isClassMethod;
        exports.isClassPrivateMethod = isClassPrivateMethod;
        exports.isClassPrivateProperty = isClassPrivateProperty;
        exports.isClassProperty = isClassProperty;
        exports.isCompletionStatement = isCompletionStatement;
        exports.isConditional = isConditional;
        exports.isConditionalExpression = isConditionalExpression;
        exports.isContinueStatement = isContinueStatement;
        exports.isDebuggerStatement = isDebuggerStatement;
        exports.isDecimalLiteral = isDecimalLiteral;
        exports.isDeclaration = isDeclaration;
        exports.isDeclareClass = isDeclareClass;
        exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
        exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
        exports.isDeclareFunction = isDeclareFunction;
        exports.isDeclareInterface = isDeclareInterface;
        exports.isDeclareModule = isDeclareModule;
        exports.isDeclareModuleExports = isDeclareModuleExports;
        exports.isDeclareOpaqueType = isDeclareOpaqueType;
        exports.isDeclareTypeAlias = isDeclareTypeAlias;
        exports.isDeclareVariable = isDeclareVariable;
        exports.isDeclaredPredicate = isDeclaredPredicate;
        exports.isDecorator = isDecorator;
        exports.isDirective = isDirective;
        exports.isDirectiveLiteral = isDirectiveLiteral;
        exports.isDoExpression = isDoExpression;
        exports.isDoWhileStatement = isDoWhileStatement;
        exports.isEmptyStatement = isEmptyStatement;
        exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
        exports.isEnumBody = isEnumBody;
        exports.isEnumBooleanBody = isEnumBooleanBody;
        exports.isEnumBooleanMember = isEnumBooleanMember;
        exports.isEnumDeclaration = isEnumDeclaration;
        exports.isEnumDefaultedMember = isEnumDefaultedMember;
        exports.isEnumMember = isEnumMember;
        exports.isEnumNumberBody = isEnumNumberBody;
        exports.isEnumNumberMember = isEnumNumberMember;
        exports.isEnumStringBody = isEnumStringBody;
        exports.isEnumStringMember = isEnumStringMember;
        exports.isEnumSymbolBody = isEnumSymbolBody;
        exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
        exports.isExportAllDeclaration = isExportAllDeclaration;
        exports.isExportDeclaration = isExportDeclaration;
        exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
        exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
        exports.isExportNamedDeclaration = isExportNamedDeclaration;
        exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
        exports.isExportSpecifier = isExportSpecifier;
        exports.isExpression = isExpression;
        exports.isExpressionStatement = isExpressionStatement2;
        exports.isExpressionWrapper = isExpressionWrapper;
        exports.isFile = isFile;
        exports.isFlow = isFlow;
        exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
        exports.isFlowDeclaration = isFlowDeclaration;
        exports.isFlowPredicate = isFlowPredicate;
        exports.isFlowType = isFlowType;
        exports.isFor = isFor;
        exports.isForInStatement = isForInStatement;
        exports.isForOfStatement = isForOfStatement;
        exports.isForStatement = isForStatement;
        exports.isForXStatement = isForXStatement;
        exports.isFunction = isFunction;
        exports.isFunctionDeclaration = isFunctionDeclaration;
        exports.isFunctionExpression = isFunctionExpression;
        exports.isFunctionParent = isFunctionParent;
        exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
        exports.isFunctionTypeParam = isFunctionTypeParam;
        exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
        exports.isIdentifier = isIdentifier2;
        exports.isIfStatement = isIfStatement;
        exports.isImmutable = isImmutable;
        exports.isImport = isImport;
        exports.isImportAttribute = isImportAttribute;
        exports.isImportDeclaration = isImportDeclaration;
        exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
        exports.isImportExpression = isImportExpression;
        exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
        exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
        exports.isImportSpecifier = isImportSpecifier;
        exports.isIndexedAccessType = isIndexedAccessType;
        exports.isInferredPredicate = isInferredPredicate;
        exports.isInterfaceDeclaration = isInterfaceDeclaration;
        exports.isInterfaceExtends = isInterfaceExtends;
        exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
        exports.isInterpreterDirective = isInterpreterDirective;
        exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
        exports.isJSX = isJSX;
        exports.isJSXAttribute = isJSXAttribute;
        exports.isJSXClosingElement = isJSXClosingElement;
        exports.isJSXClosingFragment = isJSXClosingFragment;
        exports.isJSXElement = isJSXElement;
        exports.isJSXEmptyExpression = isJSXEmptyExpression;
        exports.isJSXExpressionContainer = isJSXExpressionContainer;
        exports.isJSXFragment = isJSXFragment;
        exports.isJSXIdentifier = isJSXIdentifier;
        exports.isJSXMemberExpression = isJSXMemberExpression;
        exports.isJSXNamespacedName = isJSXNamespacedName;
        exports.isJSXOpeningElement = isJSXOpeningElement;
        exports.isJSXOpeningFragment = isJSXOpeningFragment;
        exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
        exports.isJSXSpreadChild = isJSXSpreadChild;
        exports.isJSXText = isJSXText;
        exports.isLVal = isLVal;
        exports.isLabeledStatement = isLabeledStatement;
        exports.isLiteral = isLiteral;
        exports.isLogicalExpression = isLogicalExpression;
        exports.isLoop = isLoop;
        exports.isMemberExpression = isMemberExpression;
        exports.isMetaProperty = isMetaProperty;
        exports.isMethod = isMethod;
        exports.isMiscellaneous = isMiscellaneous;
        exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
        exports.isModuleDeclaration = isModuleDeclaration;
        exports.isModuleExpression = isModuleExpression;
        exports.isModuleSpecifier = isModuleSpecifier;
        exports.isNewExpression = isNewExpression;
        exports.isNoop = isNoop;
        exports.isNullLiteral = isNullLiteral2;
        exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
        exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
        exports.isNumberLiteral = isNumberLiteral;
        exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
        exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
        exports.isNumericLiteral = isNumericLiteral2;
        exports.isObjectExpression = isObjectExpression2;
        exports.isObjectMember = isObjectMember;
        exports.isObjectMethod = isObjectMethod;
        exports.isObjectPattern = isObjectPattern;
        exports.isObjectProperty = isObjectProperty2;
        exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
        exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
        exports.isObjectTypeIndexer = isObjectTypeIndexer;
        exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
        exports.isObjectTypeProperty = isObjectTypeProperty;
        exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
        exports.isOpaqueType = isOpaqueType;
        exports.isOptionalCallExpression = isOptionalCallExpression;
        exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
        exports.isOptionalMemberExpression = isOptionalMemberExpression;
        exports.isParenthesizedExpression = isParenthesizedExpression;
        exports.isPattern = isPattern;
        exports.isPatternLike = isPatternLike;
        exports.isPipelineBareFunction = isPipelineBareFunction;
        exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
        exports.isPipelineTopicExpression = isPipelineTopicExpression;
        exports.isPlaceholder = isPlaceholder;
        exports.isPrivate = isPrivate;
        exports.isPrivateName = isPrivateName;
        exports.isProgram = isProgram;
        exports.isProperty = isProperty;
        exports.isPureish = isPureish;
        exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
        exports.isRecordExpression = isRecordExpression;
        exports.isRegExpLiteral = isRegExpLiteral;
        exports.isRegexLiteral = isRegexLiteral;
        exports.isRestElement = isRestElement;
        exports.isRestProperty = isRestProperty;
        exports.isReturnStatement = isReturnStatement;
        exports.isScopable = isScopable;
        exports.isSequenceExpression = isSequenceExpression;
        exports.isSpreadElement = isSpreadElement;
        exports.isSpreadProperty = isSpreadProperty;
        exports.isStandardized = isStandardized;
        exports.isStatement = isStatement;
        exports.isStaticBlock = isStaticBlock;
        exports.isStringLiteral = isStringLiteral2;
        exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
        exports.isStringTypeAnnotation = isStringTypeAnnotation;
        exports.isSuper = isSuper;
        exports.isSwitchCase = isSwitchCase;
        exports.isSwitchStatement = isSwitchStatement;
        exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
        exports.isTSAnyKeyword = isTSAnyKeyword;
        exports.isTSArrayType = isTSArrayType;
        exports.isTSAsExpression = isTSAsExpression;
        exports.isTSBaseType = isTSBaseType;
        exports.isTSBigIntKeyword = isTSBigIntKeyword;
        exports.isTSBooleanKeyword = isTSBooleanKeyword;
        exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
        exports.isTSConditionalType = isTSConditionalType;
        exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
        exports.isTSConstructorType = isTSConstructorType;
        exports.isTSDeclareFunction = isTSDeclareFunction;
        exports.isTSDeclareMethod = isTSDeclareMethod;
        exports.isTSEntityName = isTSEntityName;
        exports.isTSEnumDeclaration = isTSEnumDeclaration;
        exports.isTSEnumMember = isTSEnumMember;
        exports.isTSExportAssignment = isTSExportAssignment;
        exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
        exports.isTSExternalModuleReference = isTSExternalModuleReference;
        exports.isTSFunctionType = isTSFunctionType;
        exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
        exports.isTSImportType = isTSImportType;
        exports.isTSIndexSignature = isTSIndexSignature;
        exports.isTSIndexedAccessType = isTSIndexedAccessType;
        exports.isTSInferType = isTSInferType;
        exports.isTSInstantiationExpression = isTSInstantiationExpression;
        exports.isTSInterfaceBody = isTSInterfaceBody;
        exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
        exports.isTSIntersectionType = isTSIntersectionType;
        exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
        exports.isTSLiteralType = isTSLiteralType;
        exports.isTSMappedType = isTSMappedType;
        exports.isTSMethodSignature = isTSMethodSignature;
        exports.isTSModuleBlock = isTSModuleBlock;
        exports.isTSModuleDeclaration = isTSModuleDeclaration;
        exports.isTSNamedTupleMember = isTSNamedTupleMember;
        exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
        exports.isTSNeverKeyword = isTSNeverKeyword;
        exports.isTSNonNullExpression = isTSNonNullExpression;
        exports.isTSNullKeyword = isTSNullKeyword;
        exports.isTSNumberKeyword = isTSNumberKeyword;
        exports.isTSObjectKeyword = isTSObjectKeyword;
        exports.isTSOptionalType = isTSOptionalType;
        exports.isTSParameterProperty = isTSParameterProperty;
        exports.isTSParenthesizedType = isTSParenthesizedType;
        exports.isTSPropertySignature = isTSPropertySignature;
        exports.isTSQualifiedName = isTSQualifiedName;
        exports.isTSRestType = isTSRestType;
        exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
        exports.isTSStringKeyword = isTSStringKeyword;
        exports.isTSSymbolKeyword = isTSSymbolKeyword;
        exports.isTSThisType = isTSThisType;
        exports.isTSTupleType = isTSTupleType;
        exports.isTSType = isTSType;
        exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
        exports.isTSTypeAnnotation = isTSTypeAnnotation;
        exports.isTSTypeAssertion = isTSTypeAssertion;
        exports.isTSTypeElement = isTSTypeElement;
        exports.isTSTypeLiteral = isTSTypeLiteral;
        exports.isTSTypeOperator = isTSTypeOperator;
        exports.isTSTypeParameter = isTSTypeParameter;
        exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
        exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
        exports.isTSTypePredicate = isTSTypePredicate;
        exports.isTSTypeQuery = isTSTypeQuery;
        exports.isTSTypeReference = isTSTypeReference;
        exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
        exports.isTSUnionType = isTSUnionType;
        exports.isTSUnknownKeyword = isTSUnknownKeyword;
        exports.isTSVoidKeyword = isTSVoidKeyword;
        exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
        exports.isTemplateElement = isTemplateElement;
        exports.isTemplateLiteral = isTemplateLiteral2;
        exports.isTerminatorless = isTerminatorless;
        exports.isThisExpression = isThisExpression;
        exports.isThisTypeAnnotation = isThisTypeAnnotation;
        exports.isThrowStatement = isThrowStatement;
        exports.isTopicReference = isTopicReference;
        exports.isTryStatement = isTryStatement;
        exports.isTupleExpression = isTupleExpression;
        exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
        exports.isTypeAlias = isTypeAlias;
        exports.isTypeAnnotation = isTypeAnnotation;
        exports.isTypeCastExpression = isTypeCastExpression;
        exports.isTypeParameter = isTypeParameter;
        exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
        exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
        exports.isTypeScript = isTypeScript;
        exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
        exports.isUnaryExpression = isUnaryExpression;
        exports.isUnaryLike = isUnaryLike;
        exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
        exports.isUpdateExpression = isUpdateExpression;
        exports.isUserWhitespacable = isUserWhitespacable;
        exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
        exports.isVariableDeclaration = isVariableDeclaration;
        exports.isVariableDeclarator = isVariableDeclarator;
        exports.isVariance = isVariance;
        exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
        exports.isWhile = isWhile;
        exports.isWhileStatement = isWhileStatement;
        exports.isWithStatement = isWithStatement;
        exports.isYieldExpression = isYieldExpression;
        var _shallowEqual = require_shallowEqual();
        var _deprecationWarning = require_deprecationWarning();
        function isArrayExpression2(node, opts) {
            if (!node) return false;
            if (node.type !== "ArrayExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isAssignmentExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "AssignmentExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBinaryExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "BinaryExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isInterpreterDirective(node, opts) {
            if (!node) return false;
            if (node.type !== "InterpreterDirective") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDirective(node, opts) {
            if (!node) return false;
            if (node.type !== "Directive") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDirectiveLiteral(node, opts) {
            if (!node) return false;
            if (node.type !== "DirectiveLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBlockStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "BlockStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBreakStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "BreakStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isCallExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "CallExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isCatchClause(node, opts) {
            if (!node) return false;
            if (node.type !== "CatchClause") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isConditionalExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "ConditionalExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isContinueStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "ContinueStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDebuggerStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "DebuggerStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDoWhileStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "DoWhileStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEmptyStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "EmptyStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExpressionStatement2(node, opts) {
            if (!node) return false;
            if (node.type !== "ExpressionStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFile(node, opts) {
            if (!node) return false;
            if (node.type !== "File") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isForInStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "ForInStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isForStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "ForStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFunctionDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "FunctionDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFunctionExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "FunctionExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isIdentifier2(node, opts) {
            if (!node) return false;
            if (node.type !== "Identifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isIfStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "IfStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isLabeledStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "LabeledStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isStringLiteral2(node, opts) {
            if (!node) return false;
            if (node.type !== "StringLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNumericLiteral2(node, opts) {
            if (!node) return false;
            if (node.type !== "NumericLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNullLiteral2(node, opts) {
            if (!node) return false;
            if (node.type !== "NullLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBooleanLiteral2(node, opts) {
            if (!node) return false;
            if (node.type !== "BooleanLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isRegExpLiteral(node, opts) {
            if (!node) return false;
            if (node.type !== "RegExpLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isLogicalExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "LogicalExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isMemberExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "MemberExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNewExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "NewExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isProgram(node, opts) {
            if (!node) return false;
            if (node.type !== "Program") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectExpression2(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectMethod(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectMethod") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectProperty2(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isRestElement(node, opts) {
            if (!node) return false;
            if (node.type !== "RestElement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isReturnStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "ReturnStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isSequenceExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "SequenceExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isParenthesizedExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "ParenthesizedExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isSwitchCase(node, opts) {
            if (!node) return false;
            if (node.type !== "SwitchCase") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isSwitchStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "SwitchStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isThisExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "ThisExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isThrowStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "ThrowStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTryStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "TryStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isUnaryExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "UnaryExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isUpdateExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "UpdateExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isVariableDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "VariableDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isVariableDeclarator(node, opts) {
            if (!node) return false;
            if (node.type !== "VariableDeclarator") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isWhileStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "WhileStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isWithStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "WithStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isAssignmentPattern(node, opts) {
            if (!node) return false;
            if (node.type !== "AssignmentPattern") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isArrayPattern(node, opts) {
            if (!node) return false;
            if (node.type !== "ArrayPattern") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isArrowFunctionExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "ArrowFunctionExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassBody(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassBody") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExportAllDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "ExportAllDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExportDefaultDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "ExportDefaultDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExportNamedDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "ExportNamedDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExportSpecifier(node, opts) {
            if (!node) return false;
            if (node.type !== "ExportSpecifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isForOfStatement(node, opts) {
            if (!node) return false;
            if (node.type !== "ForOfStatement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImportDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "ImportDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImportDefaultSpecifier(node, opts) {
            if (!node) return false;
            if (node.type !== "ImportDefaultSpecifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImportNamespaceSpecifier(node, opts) {
            if (!node) return false;
            if (node.type !== "ImportNamespaceSpecifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImportSpecifier(node, opts) {
            if (!node) return false;
            if (node.type !== "ImportSpecifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImportExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "ImportExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isMetaProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "MetaProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassMethod(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassMethod") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectPattern(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectPattern") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isSpreadElement(node, opts) {
            if (!node) return false;
            if (node.type !== "SpreadElement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isSuper(node, opts) {
            if (!node) return false;
            if (node.type !== "Super") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTaggedTemplateExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "TaggedTemplateExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTemplateElement(node, opts) {
            if (!node) return false;
            if (node.type !== "TemplateElement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTemplateLiteral2(node, opts) {
            if (!node) return false;
            if (node.type !== "TemplateLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isYieldExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "YieldExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isAwaitExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "AwaitExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImport(node, opts) {
            if (!node) return false;
            if (node.type !== "Import") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBigIntLiteral(node, opts) {
            if (!node) return false;
            if (node.type !== "BigIntLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExportNamespaceSpecifier(node, opts) {
            if (!node) return false;
            if (node.type !== "ExportNamespaceSpecifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isOptionalMemberExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "OptionalMemberExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isOptionalCallExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "OptionalCallExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassAccessorProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassAccessorProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassPrivateProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassPrivateProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassPrivateMethod(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassPrivateMethod") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPrivateName(node, opts) {
            if (!node) return false;
            if (node.type !== "PrivateName") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isStaticBlock(node, opts) {
            if (!node) return false;
            if (node.type !== "StaticBlock") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isAnyTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "AnyTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isArrayTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "ArrayTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBooleanTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "BooleanTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBooleanLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "BooleanLiteralTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNullLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "NullLiteralTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClassImplements(node, opts) {
            if (!node) return false;
            if (node.type !== "ClassImplements") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareClass(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareClass") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareFunction(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareFunction") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareInterface(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareInterface") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareModule(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareModule") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareModuleExports(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareModuleExports") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareTypeAlias(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareTypeAlias") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareOpaqueType(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareOpaqueType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareVariable(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareVariable") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareExportDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareExportDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclareExportAllDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclareExportAllDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclaredPredicate(node, opts) {
            if (!node) return false;
            if (node.type !== "DeclaredPredicate") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExistsTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "ExistsTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFunctionTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "FunctionTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFunctionTypeParam(node, opts) {
            if (!node) return false;
            if (node.type !== "FunctionTypeParam") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isGenericTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "GenericTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isInferredPredicate(node, opts) {
            if (!node) return false;
            if (node.type !== "InferredPredicate") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isInterfaceExtends(node, opts) {
            if (!node) return false;
            if (node.type !== "InterfaceExtends") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isInterfaceDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "InterfaceDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isInterfaceTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "InterfaceTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isIntersectionTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "IntersectionTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isMixedTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "MixedTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEmptyTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "EmptyTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNullableTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "NullableTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNumberLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "NumberLiteralTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNumberTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "NumberTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectTypeInternalSlot(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectTypeInternalSlot") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectTypeCallProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectTypeCallProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectTypeIndexer(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectTypeIndexer") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectTypeProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectTypeProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectTypeSpreadProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "ObjectTypeSpreadProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isOpaqueType(node, opts) {
            if (!node) return false;
            if (node.type !== "OpaqueType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isQualifiedTypeIdentifier(node, opts) {
            if (!node) return false;
            if (node.type !== "QualifiedTypeIdentifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isStringLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "StringLiteralTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isStringTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "StringTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isSymbolTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "SymbolTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isThisTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "ThisTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTupleTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "TupleTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeofTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "TypeofTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeAlias(node, opts) {
            if (!node) return false;
            if (node.type !== "TypeAlias") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "TypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeCastExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "TypeCastExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeParameter(node, opts) {
            if (!node) return false;
            if (node.type !== "TypeParameter") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeParameterDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TypeParameterDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeParameterInstantiation(node, opts) {
            if (!node) return false;
            if (node.type !== "TypeParameterInstantiation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isUnionTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "UnionTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isVariance(node, opts) {
            if (!node) return false;
            if (node.type !== "Variance") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isVoidTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "VoidTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumBooleanBody(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumBooleanBody") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumNumberBody(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumNumberBody") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumStringBody(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumStringBody") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumSymbolBody(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumSymbolBody") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumBooleanMember(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumBooleanMember") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumNumberMember(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumNumberMember") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumStringMember(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumStringMember") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumDefaultedMember(node, opts) {
            if (!node) return false;
            if (node.type !== "EnumDefaultedMember") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isIndexedAccessType(node, opts) {
            if (!node) return false;
            if (node.type !== "IndexedAccessType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isOptionalIndexedAccessType(node, opts) {
            if (!node) return false;
            if (node.type !== "OptionalIndexedAccessType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXAttribute(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXAttribute") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXClosingElement(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXClosingElement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXElement(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXElement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXEmptyExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXEmptyExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXExpressionContainer(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXExpressionContainer") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXSpreadChild(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXSpreadChild") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXIdentifier(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXIdentifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXMemberExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXMemberExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXNamespacedName(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXNamespacedName") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXOpeningElement(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXOpeningElement") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXSpreadAttribute(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXSpreadAttribute") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXText(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXText") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXFragment(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXFragment") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXOpeningFragment(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXOpeningFragment") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSXClosingFragment(node, opts) {
            if (!node) return false;
            if (node.type !== "JSXClosingFragment") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNoop(node, opts) {
            if (!node) return false;
            if (node.type !== "Noop") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPlaceholder(node, opts) {
            if (!node) return false;
            if (node.type !== "Placeholder") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isV8IntrinsicIdentifier(node, opts) {
            if (!node) return false;
            if (node.type !== "V8IntrinsicIdentifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isArgumentPlaceholder(node, opts) {
            if (!node) return false;
            if (node.type !== "ArgumentPlaceholder") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBindExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "BindExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImportAttribute(node, opts) {
            if (!node) return false;
            if (node.type !== "ImportAttribute") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDecorator(node, opts) {
            if (!node) return false;
            if (node.type !== "Decorator") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDoExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "DoExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExportDefaultSpecifier(node, opts) {
            if (!node) return false;
            if (node.type !== "ExportDefaultSpecifier") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isRecordExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "RecordExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTupleExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "TupleExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDecimalLiteral(node, opts) {
            if (!node) return false;
            if (node.type !== "DecimalLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isModuleExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "ModuleExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTopicReference(node, opts) {
            if (!node) return false;
            if (node.type !== "TopicReference") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPipelineTopicExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "PipelineTopicExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPipelineBareFunction(node, opts) {
            if (!node) return false;
            if (node.type !== "PipelineBareFunction") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPipelinePrimaryTopicReference(node, opts) {
            if (!node) return false;
            if (node.type !== "PipelinePrimaryTopicReference") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSParameterProperty(node, opts) {
            if (!node) return false;
            if (node.type !== "TSParameterProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSDeclareFunction(node, opts) {
            if (!node) return false;
            if (node.type !== "TSDeclareFunction") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSDeclareMethod(node, opts) {
            if (!node) return false;
            if (node.type !== "TSDeclareMethod") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSQualifiedName(node, opts) {
            if (!node) return false;
            if (node.type !== "TSQualifiedName") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSCallSignatureDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSCallSignatureDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSConstructSignatureDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSConstructSignatureDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSPropertySignature(node, opts) {
            if (!node) return false;
            if (node.type !== "TSPropertySignature") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSMethodSignature(node, opts) {
            if (!node) return false;
            if (node.type !== "TSMethodSignature") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSIndexSignature(node, opts) {
            if (!node) return false;
            if (node.type !== "TSIndexSignature") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSAnyKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSAnyKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSBooleanKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSBooleanKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSBigIntKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSBigIntKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSIntrinsicKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSIntrinsicKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSNeverKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSNeverKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSNullKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSNullKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSNumberKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSNumberKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSObjectKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSObjectKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSStringKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSStringKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSSymbolKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSSymbolKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSUndefinedKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSUndefinedKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSUnknownKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSUnknownKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSVoidKeyword(node, opts) {
            if (!node) return false;
            if (node.type !== "TSVoidKeyword") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSThisType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSThisType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSFunctionType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSFunctionType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSConstructorType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSConstructorType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeReference(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeReference") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypePredicate(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypePredicate") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeQuery(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeQuery") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeLiteral(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSArrayType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSArrayType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTupleType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTupleType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSOptionalType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSOptionalType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSRestType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSRestType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSNamedTupleMember(node, opts) {
            if (!node) return false;
            if (node.type !== "TSNamedTupleMember") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSUnionType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSUnionType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSIntersectionType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSIntersectionType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSConditionalType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSConditionalType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSInferType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSInferType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSParenthesizedType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSParenthesizedType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeOperator(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeOperator") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSIndexedAccessType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSIndexedAccessType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSMappedType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSMappedType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSLiteralType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSLiteralType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSExpressionWithTypeArguments(node, opts) {
            if (!node) return false;
            if (node.type !== "TSExpressionWithTypeArguments") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSInterfaceDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSInterfaceDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSInterfaceBody(node, opts) {
            if (!node) return false;
            if (node.type !== "TSInterfaceBody") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeAliasDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeAliasDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSInstantiationExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "TSInstantiationExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSAsExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "TSAsExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSSatisfiesExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "TSSatisfiesExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeAssertion(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeAssertion") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSEnumDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSEnumDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSEnumMember(node, opts) {
            if (!node) return false;
            if (node.type !== "TSEnumMember") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSModuleDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSModuleDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSModuleBlock(node, opts) {
            if (!node) return false;
            if (node.type !== "TSModuleBlock") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSImportType(node, opts) {
            if (!node) return false;
            if (node.type !== "TSImportType") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSImportEqualsDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSImportEqualsDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSExternalModuleReference(node, opts) {
            if (!node) return false;
            if (node.type !== "TSExternalModuleReference") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSNonNullExpression(node, opts) {
            if (!node) return false;
            if (node.type !== "TSNonNullExpression") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSExportAssignment(node, opts) {
            if (!node) return false;
            if (node.type !== "TSExportAssignment") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSNamespaceExportDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSNamespaceExportDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeAnnotation(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeAnnotation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeParameterInstantiation(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeParameterInstantiation") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeParameterDeclaration(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeParameterDeclaration") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeParameter(node, opts) {
            if (!node) return false;
            if (node.type !== "TSTypeParameter") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isStandardized(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "InterpreterDirective":
                case "Directive":
                case "DirectiveLiteral":
                case "BlockStatement":
                case "BreakStatement":
                case "CallExpression":
                case "CatchClause":
                case "ConditionalExpression":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "File":
                case "ForInStatement":
                case "ForStatement":
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "Identifier":
                case "IfStatement":
                case "LabeledStatement":
                case "StringLiteral":
                case "NumericLiteral":
                case "NullLiteral":
                case "BooleanLiteral":
                case "RegExpLiteral":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "Program":
                case "ObjectExpression":
                case "ObjectMethod":
                case "ObjectProperty":
                case "RestElement":
                case "ReturnStatement":
                case "SequenceExpression":
                case "ParenthesizedExpression":
                case "SwitchCase":
                case "SwitchStatement":
                case "ThisExpression":
                case "ThrowStatement":
                case "TryStatement":
                case "UnaryExpression":
                case "UpdateExpression":
                case "VariableDeclaration":
                case "VariableDeclarator":
                case "WhileStatement":
                case "WithStatement":
                case "AssignmentPattern":
                case "ArrayPattern":
                case "ArrowFunctionExpression":
                case "ClassBody":
                case "ClassExpression":
                case "ClassDeclaration":
                case "ExportAllDeclaration":
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                case "ExportSpecifier":
                case "ForOfStatement":
                case "ImportDeclaration":
                case "ImportDefaultSpecifier":
                case "ImportNamespaceSpecifier":
                case "ImportSpecifier":
                case "ImportExpression":
                case "MetaProperty":
                case "ClassMethod":
                case "ObjectPattern":
                case "SpreadElement":
                case "Super":
                case "TaggedTemplateExpression":
                case "TemplateElement":
                case "TemplateLiteral":
                case "YieldExpression":
                case "AwaitExpression":
                case "Import":
                case "BigIntLiteral":
                case "ExportNamespaceSpecifier":
                case "OptionalMemberExpression":
                case "OptionalCallExpression":
                case "ClassProperty":
                case "ClassAccessorProperty":
                case "ClassPrivateProperty":
                case "ClassPrivateMethod":
                case "PrivateName":
                case "StaticBlock":
                    break;
                case "Placeholder":
                    switch(node.expectedNode){
                        case "Identifier":
                        case "StringLiteral":
                        case "BlockStatement":
                        case "ClassBody":
                            break;
                        default:
                            return false;
                    }
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExpression(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "StringLiteral":
                case "NumericLiteral":
                case "NullLiteral":
                case "BooleanLiteral":
                case "RegExpLiteral":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ParenthesizedExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                case "ArrowFunctionExpression":
                case "ClassExpression":
                case "ImportExpression":
                case "MetaProperty":
                case "Super":
                case "TaggedTemplateExpression":
                case "TemplateLiteral":
                case "YieldExpression":
                case "AwaitExpression":
                case "Import":
                case "BigIntLiteral":
                case "OptionalMemberExpression":
                case "OptionalCallExpression":
                case "TypeCastExpression":
                case "JSXElement":
                case "JSXFragment":
                case "BindExpression":
                case "DoExpression":
                case "RecordExpression":
                case "TupleExpression":
                case "DecimalLiteral":
                case "ModuleExpression":
                case "TopicReference":
                case "PipelineTopicExpression":
                case "PipelineBareFunction":
                case "PipelinePrimaryTopicReference":
                case "TSInstantiationExpression":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                    break;
                case "Placeholder":
                    switch(node.expectedNode){
                        case "Expression":
                        case "Identifier":
                        case "StringLiteral":
                            break;
                        default:
                            return false;
                    }
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBinary(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "BinaryExpression":
                case "LogicalExpression":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isScopable(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "BlockStatement":
                case "CatchClause":
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "Program":
                case "ObjectMethod":
                case "SwitchStatement":
                case "WhileStatement":
                case "ArrowFunctionExpression":
                case "ClassExpression":
                case "ClassDeclaration":
                case "ForOfStatement":
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "StaticBlock":
                case "TSModuleBlock":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "BlockStatement") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBlockParent(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "BlockStatement":
                case "CatchClause":
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "Program":
                case "ObjectMethod":
                case "SwitchStatement":
                case "WhileStatement":
                case "ArrowFunctionExpression":
                case "ForOfStatement":
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "StaticBlock":
                case "TSModuleBlock":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "BlockStatement") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isBlock(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "BlockStatement":
                case "Program":
                case "TSModuleBlock":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "BlockStatement") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isStatement(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "FunctionDeclaration":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                case "ClassDeclaration":
                case "ExportAllDeclaration":
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                case "ForOfStatement":
                case "ImportDeclaration":
                case "DeclareClass":
                case "DeclareFunction":
                case "DeclareInterface":
                case "DeclareModule":
                case "DeclareModuleExports":
                case "DeclareTypeAlias":
                case "DeclareOpaqueType":
                case "DeclareVariable":
                case "DeclareExportDeclaration":
                case "DeclareExportAllDeclaration":
                case "InterfaceDeclaration":
                case "OpaqueType":
                case "TypeAlias":
                case "EnumDeclaration":
                case "TSDeclareFunction":
                case "TSInterfaceDeclaration":
                case "TSTypeAliasDeclaration":
                case "TSEnumDeclaration":
                case "TSModuleDeclaration":
                case "TSImportEqualsDeclaration":
                case "TSExportAssignment":
                case "TSNamespaceExportDeclaration":
                    break;
                case "Placeholder":
                    switch(node.expectedNode){
                        case "Statement":
                        case "Declaration":
                        case "BlockStatement":
                            break;
                        default:
                            return false;
                    }
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTerminatorless(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "BreakStatement":
                case "ContinueStatement":
                case "ReturnStatement":
                case "ThrowStatement":
                case "YieldExpression":
                case "AwaitExpression":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isCompletionStatement(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "BreakStatement":
                case "ContinueStatement":
                case "ReturnStatement":
                case "ThrowStatement":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isConditional(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ConditionalExpression":
                case "IfStatement":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isLoop(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                case "ForOfStatement":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isWhile(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "DoWhileStatement":
                case "WhileStatement":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExpressionWrapper(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ExpressionStatement":
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFor(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ForInStatement":
                case "ForStatement":
                case "ForOfStatement":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isForXStatement(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ForInStatement":
                case "ForOfStatement":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFunction(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ObjectMethod":
                case "ArrowFunctionExpression":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFunctionParent(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ObjectMethod":
                case "ArrowFunctionExpression":
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "StaticBlock":
                case "TSModuleBlock":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPureish(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "StringLiteral":
                case "NumericLiteral":
                case "NullLiteral":
                case "BooleanLiteral":
                case "RegExpLiteral":
                case "ArrowFunctionExpression":
                case "BigIntLiteral":
                case "DecimalLiteral":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "StringLiteral") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isDeclaration(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "FunctionDeclaration":
                case "VariableDeclaration":
                case "ClassDeclaration":
                case "ExportAllDeclaration":
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                case "DeclareClass":
                case "DeclareFunction":
                case "DeclareInterface":
                case "DeclareModule":
                case "DeclareModuleExports":
                case "DeclareTypeAlias":
                case "DeclareOpaqueType":
                case "DeclareVariable":
                case "DeclareExportDeclaration":
                case "DeclareExportAllDeclaration":
                case "InterfaceDeclaration":
                case "OpaqueType":
                case "TypeAlias":
                case "EnumDeclaration":
                case "TSDeclareFunction":
                case "TSInterfaceDeclaration":
                case "TSTypeAliasDeclaration":
                case "TSEnumDeclaration":
                case "TSModuleDeclaration":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "Declaration") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPatternLike(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "Identifier":
                case "RestElement":
                case "AssignmentPattern":
                case "ArrayPattern":
                case "ObjectPattern":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                    break;
                case "Placeholder":
                    switch(node.expectedNode){
                        case "Pattern":
                        case "Identifier":
                            break;
                        default:
                            return false;
                    }
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isLVal(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "Identifier":
                case "MemberExpression":
                case "RestElement":
                case "AssignmentPattern":
                case "ArrayPattern":
                case "ObjectPattern":
                case "TSParameterProperty":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                    break;
                case "Placeholder":
                    switch(node.expectedNode){
                        case "Pattern":
                        case "Identifier":
                            break;
                        default:
                            return false;
                    }
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSEntityName(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "Identifier":
                case "TSQualifiedName":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "Identifier") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isLiteral(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "StringLiteral":
                case "NumericLiteral":
                case "NullLiteral":
                case "BooleanLiteral":
                case "RegExpLiteral":
                case "TemplateLiteral":
                case "BigIntLiteral":
                case "DecimalLiteral":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "StringLiteral") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImmutable(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "StringLiteral":
                case "NumericLiteral":
                case "NullLiteral":
                case "BooleanLiteral":
                case "BigIntLiteral":
                case "JSXAttribute":
                case "JSXClosingElement":
                case "JSXElement":
                case "JSXExpressionContainer":
                case "JSXSpreadChild":
                case "JSXOpeningElement":
                case "JSXText":
                case "JSXFragment":
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                case "DecimalLiteral":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "StringLiteral") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isUserWhitespacable(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ObjectMethod":
                case "ObjectProperty":
                case "ObjectTypeInternalSlot":
                case "ObjectTypeCallProperty":
                case "ObjectTypeIndexer":
                case "ObjectTypeProperty":
                case "ObjectTypeSpreadProperty":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isMethod(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isObjectMember(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ObjectMethod":
                case "ObjectProperty":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isProperty(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ObjectProperty":
                case "ClassProperty":
                case "ClassAccessorProperty":
                case "ClassPrivateProperty":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isUnaryLike(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "UnaryExpression":
                case "SpreadElement":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPattern(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "AssignmentPattern":
                case "ArrayPattern":
                case "ObjectPattern":
                    break;
                case "Placeholder":
                    if (node.expectedNode === "Pattern") break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isClass(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ClassExpression":
                case "ClassDeclaration":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isImportOrExportDeclaration(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ExportAllDeclaration":
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isExportDeclaration(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ExportAllDeclaration":
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isModuleSpecifier(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ExportSpecifier":
                case "ImportDefaultSpecifier":
                case "ImportNamespaceSpecifier":
                case "ImportSpecifier":
                case "ExportNamespaceSpecifier":
                case "ExportDefaultSpecifier":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isAccessor(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ClassAccessorProperty":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isPrivate(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "ClassPrivateProperty":
                case "ClassPrivateMethod":
                case "PrivateName":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFlow(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "AnyTypeAnnotation":
                case "ArrayTypeAnnotation":
                case "BooleanTypeAnnotation":
                case "BooleanLiteralTypeAnnotation":
                case "NullLiteralTypeAnnotation":
                case "ClassImplements":
                case "DeclareClass":
                case "DeclareFunction":
                case "DeclareInterface":
                case "DeclareModule":
                case "DeclareModuleExports":
                case "DeclareTypeAlias":
                case "DeclareOpaqueType":
                case "DeclareVariable":
                case "DeclareExportDeclaration":
                case "DeclareExportAllDeclaration":
                case "DeclaredPredicate":
                case "ExistsTypeAnnotation":
                case "FunctionTypeAnnotation":
                case "FunctionTypeParam":
                case "GenericTypeAnnotation":
                case "InferredPredicate":
                case "InterfaceExtends":
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                case "IntersectionTypeAnnotation":
                case "MixedTypeAnnotation":
                case "EmptyTypeAnnotation":
                case "NullableTypeAnnotation":
                case "NumberLiteralTypeAnnotation":
                case "NumberTypeAnnotation":
                case "ObjectTypeAnnotation":
                case "ObjectTypeInternalSlot":
                case "ObjectTypeCallProperty":
                case "ObjectTypeIndexer":
                case "ObjectTypeProperty":
                case "ObjectTypeSpreadProperty":
                case "OpaqueType":
                case "QualifiedTypeIdentifier":
                case "StringLiteralTypeAnnotation":
                case "StringTypeAnnotation":
                case "SymbolTypeAnnotation":
                case "ThisTypeAnnotation":
                case "TupleTypeAnnotation":
                case "TypeofTypeAnnotation":
                case "TypeAlias":
                case "TypeAnnotation":
                case "TypeCastExpression":
                case "TypeParameter":
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation":
                case "UnionTypeAnnotation":
                case "Variance":
                case "VoidTypeAnnotation":
                case "EnumDeclaration":
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody":
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                case "EnumDefaultedMember":
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFlowType(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "AnyTypeAnnotation":
                case "ArrayTypeAnnotation":
                case "BooleanTypeAnnotation":
                case "BooleanLiteralTypeAnnotation":
                case "NullLiteralTypeAnnotation":
                case "ExistsTypeAnnotation":
                case "FunctionTypeAnnotation":
                case "GenericTypeAnnotation":
                case "InterfaceTypeAnnotation":
                case "IntersectionTypeAnnotation":
                case "MixedTypeAnnotation":
                case "EmptyTypeAnnotation":
                case "NullableTypeAnnotation":
                case "NumberLiteralTypeAnnotation":
                case "NumberTypeAnnotation":
                case "ObjectTypeAnnotation":
                case "StringLiteralTypeAnnotation":
                case "StringTypeAnnotation":
                case "SymbolTypeAnnotation":
                case "ThisTypeAnnotation":
                case "TupleTypeAnnotation":
                case "TypeofTypeAnnotation":
                case "UnionTypeAnnotation":
                case "VoidTypeAnnotation":
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFlowBaseAnnotation(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "AnyTypeAnnotation":
                case "BooleanTypeAnnotation":
                case "NullLiteralTypeAnnotation":
                case "MixedTypeAnnotation":
                case "EmptyTypeAnnotation":
                case "NumberTypeAnnotation":
                case "StringTypeAnnotation":
                case "SymbolTypeAnnotation":
                case "ThisTypeAnnotation":
                case "VoidTypeAnnotation":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFlowDeclaration(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "DeclareClass":
                case "DeclareFunction":
                case "DeclareInterface":
                case "DeclareModule":
                case "DeclareModuleExports":
                case "DeclareTypeAlias":
                case "DeclareOpaqueType":
                case "DeclareVariable":
                case "DeclareExportDeclaration":
                case "DeclareExportAllDeclaration":
                case "InterfaceDeclaration":
                case "OpaqueType":
                case "TypeAlias":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isFlowPredicate(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "DeclaredPredicate":
                case "InferredPredicate":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumBody(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isEnumMember(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                case "EnumDefaultedMember":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isJSX(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "JSXAttribute":
                case "JSXClosingElement":
                case "JSXElement":
                case "JSXEmptyExpression":
                case "JSXExpressionContainer":
                case "JSXSpreadChild":
                case "JSXIdentifier":
                case "JSXMemberExpression":
                case "JSXNamespacedName":
                case "JSXOpeningElement":
                case "JSXSpreadAttribute":
                case "JSXText":
                case "JSXFragment":
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isMiscellaneous(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "Noop":
                case "Placeholder":
                case "V8IntrinsicIdentifier":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTypeScript(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "TSParameterProperty":
                case "TSDeclareFunction":
                case "TSDeclareMethod":
                case "TSQualifiedName":
                case "TSCallSignatureDeclaration":
                case "TSConstructSignatureDeclaration":
                case "TSPropertySignature":
                case "TSMethodSignature":
                case "TSIndexSignature":
                case "TSAnyKeyword":
                case "TSBooleanKeyword":
                case "TSBigIntKeyword":
                case "TSIntrinsicKeyword":
                case "TSNeverKeyword":
                case "TSNullKeyword":
                case "TSNumberKeyword":
                case "TSObjectKeyword":
                case "TSStringKeyword":
                case "TSSymbolKeyword":
                case "TSUndefinedKeyword":
                case "TSUnknownKeyword":
                case "TSVoidKeyword":
                case "TSThisType":
                case "TSFunctionType":
                case "TSConstructorType":
                case "TSTypeReference":
                case "TSTypePredicate":
                case "TSTypeQuery":
                case "TSTypeLiteral":
                case "TSArrayType":
                case "TSTupleType":
                case "TSOptionalType":
                case "TSRestType":
                case "TSNamedTupleMember":
                case "TSUnionType":
                case "TSIntersectionType":
                case "TSConditionalType":
                case "TSInferType":
                case "TSParenthesizedType":
                case "TSTypeOperator":
                case "TSIndexedAccessType":
                case "TSMappedType":
                case "TSLiteralType":
                case "TSExpressionWithTypeArguments":
                case "TSInterfaceDeclaration":
                case "TSInterfaceBody":
                case "TSTypeAliasDeclaration":
                case "TSInstantiationExpression":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSEnumDeclaration":
                case "TSEnumMember":
                case "TSModuleDeclaration":
                case "TSModuleBlock":
                case "TSImportType":
                case "TSImportEqualsDeclaration":
                case "TSExternalModuleReference":
                case "TSNonNullExpression":
                case "TSExportAssignment":
                case "TSNamespaceExportDeclaration":
                case "TSTypeAnnotation":
                case "TSTypeParameterInstantiation":
                case "TSTypeParameterDeclaration":
                case "TSTypeParameter":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSTypeElement(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "TSCallSignatureDeclaration":
                case "TSConstructSignatureDeclaration":
                case "TSPropertySignature":
                case "TSMethodSignature":
                case "TSIndexSignature":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSType(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "TSAnyKeyword":
                case "TSBooleanKeyword":
                case "TSBigIntKeyword":
                case "TSIntrinsicKeyword":
                case "TSNeverKeyword":
                case "TSNullKeyword":
                case "TSNumberKeyword":
                case "TSObjectKeyword":
                case "TSStringKeyword":
                case "TSSymbolKeyword":
                case "TSUndefinedKeyword":
                case "TSUnknownKeyword":
                case "TSVoidKeyword":
                case "TSThisType":
                case "TSFunctionType":
                case "TSConstructorType":
                case "TSTypeReference":
                case "TSTypePredicate":
                case "TSTypeQuery":
                case "TSTypeLiteral":
                case "TSArrayType":
                case "TSTupleType":
                case "TSOptionalType":
                case "TSRestType":
                case "TSUnionType":
                case "TSIntersectionType":
                case "TSConditionalType":
                case "TSInferType":
                case "TSParenthesizedType":
                case "TSTypeOperator":
                case "TSIndexedAccessType":
                case "TSMappedType":
                case "TSLiteralType":
                case "TSExpressionWithTypeArguments":
                case "TSImportType":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isTSBaseType(node, opts) {
            if (!node) return false;
            switch(node.type){
                case "TSAnyKeyword":
                case "TSBooleanKeyword":
                case "TSBigIntKeyword":
                case "TSIntrinsicKeyword":
                case "TSNeverKeyword":
                case "TSNullKeyword":
                case "TSNumberKeyword":
                case "TSObjectKeyword":
                case "TSStringKeyword":
                case "TSSymbolKeyword":
                case "TSUndefinedKeyword":
                case "TSUnknownKeyword":
                case "TSVoidKeyword":
                case "TSThisType":
                case "TSLiteralType":
                    break;
                default:
                    return false;
            }
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isNumberLiteral(node, opts) {
            (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
            if (!node) return false;
            if (node.type !== "NumberLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isRegexLiteral(node, opts) {
            (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
            if (!node) return false;
            if (node.type !== "RegexLiteral") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isRestProperty(node, opts) {
            (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
            if (!node) return false;
            if (node.type !== "RestProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isSpreadProperty(node, opts) {
            (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
            if (!node) return false;
            if (node.type !== "SpreadProperty") return false;
            return opts == null || (0, _shallowEqual.default)(node, opts);
        }
        function isModuleDeclaration(node, opts) {
            (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
            return isImportOrExportDeclaration(node, opts);
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
    "../../node_modules/@babel/types/lib/validators/matchesPattern.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = matchesPattern;
        var _index = require_generated();
        function matchesPattern(member, match, allowPartial) {
            if (!(0, _index.isMemberExpression)(member)) return false;
            var parts = Array.isArray(match) ? match : match.split(".");
            var nodes = [];
            var node;
            for(node = member; (0, _index.isMemberExpression)(node); node = node.object){
                nodes.push(node.property);
            }
            nodes.push(node);
            if (nodes.length < parts.length) return false;
            if (!allowPartial && nodes.length > parts.length) return false;
            for(var i = 0, j = nodes.length - 1; i < parts.length; i++, j--){
                var _node = nodes[j];
                var value = void 0;
                if ((0, _index.isIdentifier)(_node)) {
                    value = _node.name;
                } else if ((0, _index.isStringLiteral)(_node)) {
                    value = _node.value;
                } else if ((0, _index.isThisExpression)(_node)) {
                    value = "this";
                } else {
                    return false;
                }
                if (parts[i] !== value) return false;
            }
            return true;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
    "../../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = buildMatchMemberExpression;
        var _matchesPattern = require_matchesPattern();
        function buildMatchMemberExpression(match, allowPartial) {
            var parts = match.split(".");
            return function(member) {
                return (0, _matchesPattern.default)(member, parts, allowPartial);
            };
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
    "../../node_modules/@babel/types/lib/validators/react/isReactComponent.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _buildMatchMemberExpression = require_buildMatchMemberExpression();
        var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
        var _default = exports.default = isReactComponent;
    }
});
// ../../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
    "../../node_modules/@babel/types/lib/validators/react/isCompatTag.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isCompatTag;
        function isCompatTag(tagName) {
            return !!tagName && /^[a-z]/.test(tagName);
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isType.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isType;
        var _index = require_definitions();
        function isType(nodeType, targetType) {
            if (nodeType === targetType) return true;
            if (nodeType == null) return false;
            if (_index.ALIAS_KEYS[targetType]) return false;
            var aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
            if (aliases) {
                if (aliases[0] === nodeType) return true;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var alias = _step.value;
                        if (nodeType === alias) return true;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return false;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isPlaceholderType.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isPlaceholderType;
        var _index = require_definitions();
        function isPlaceholderType(placeholderType, targetType) {
            if (placeholderType === targetType) return true;
            var aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
            if (aliases) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var alias = _step.value;
                        if (targetType === alias) return true;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return false;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
    "../../node_modules/@babel/types/lib/validators/is.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = is;
        var _shallowEqual = require_shallowEqual();
        var _isType = require_isType();
        var _isPlaceholderType = require_isPlaceholderType();
        var _index = require_definitions();
        function is(type, node, opts) {
            if (!node) return false;
            var matches = (0, _isType.default)(node.type, type);
            if (!matches) {
                if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
                    return (0, _isPlaceholderType.default)(node.expectedNode, type);
                }
                return false;
            }
            if (opts === void 0) {
                return true;
            } else {
                return (0, _shallowEqual.default)(node, opts);
            }
        }
    }
});
// ../../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
    "../../node_modules/@babel/helper-validator-identifier/lib/identifier.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.isIdentifierChar = isIdentifierChar;
        exports.isIdentifierName = isIdentifierName;
        exports.isIdentifierStart = isIdentifierStart;
        var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
        var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
        var astralIdentifierStartCodes = [
            0,
            11,
            2,
            25,
            2,
            18,
            2,
            1,
            2,
            14,
            3,
            13,
            35,
            122,
            70,
            52,
            268,
            28,
            4,
            48,
            48,
            31,
            14,
            29,
            6,
            37,
            11,
            29,
            3,
            35,
            5,
            7,
            2,
            4,
            43,
            157,
            19,
            35,
            5,
            35,
            5,
            39,
            9,
            51,
            13,
            10,
            2,
            14,
            2,
            6,
            2,
            1,
            2,
            10,
            2,
            14,
            2,
            6,
            2,
            1,
            4,
            51,
            13,
            310,
            10,
            21,
            11,
            7,
            25,
            5,
            2,
            41,
            2,
            8,
            70,
            5,
            3,
            0,
            2,
            43,
            2,
            1,
            4,
            0,
            3,
            22,
            11,
            22,
            10,
            30,
            66,
            18,
            2,
            1,
            11,
            21,
            11,
            25,
            71,
            55,
            7,
            1,
            65,
            0,
            16,
            3,
            2,
            2,
            2,
            28,
            43,
            28,
            4,
            28,
            36,
            7,
            2,
            27,
            28,
            53,
            11,
            21,
            11,
            18,
            14,
            17,
            111,
            72,
            56,
            50,
            14,
            50,
            14,
            35,
            39,
            27,
            10,
            22,
            251,
            41,
            7,
            1,
            17,
            2,
            60,
            28,
            11,
            0,
            9,
            21,
            43,
            17,
            47,
            20,
            28,
            22,
            13,
            52,
            58,
            1,
            3,
            0,
            14,
            44,
            33,
            24,
            27,
            35,
            30,
            0,
            3,
            0,
            9,
            34,
            4,
            0,
            13,
            47,
            15,
            3,
            22,
            0,
            2,
            0,
            36,
            17,
            2,
            24,
            20,
            1,
            64,
            6,
            2,
            0,
            2,
            3,
            2,
            14,
            2,
            9,
            8,
            46,
            39,
            7,
            3,
            1,
            3,
            21,
            2,
            6,
            2,
            1,
            2,
            4,
            4,
            0,
            19,
            0,
            13,
            4,
            31,
            9,
            2,
            0,
            3,
            0,
            2,
            37,
            2,
            0,
            26,
            0,
            2,
            0,
            45,
            52,
            19,
            3,
            21,
            2,
            31,
            47,
            21,
            1,
            2,
            0,
            185,
            46,
            42,
            3,
            37,
            47,
            21,
            0,
            60,
            42,
            14,
            0,
            72,
            26,
            38,
            6,
            186,
            43,
            117,
            63,
            32,
            7,
            3,
            0,
            3,
            7,
            2,
            1,
            2,
            23,
            16,
            0,
            2,
            0,
            95,
            7,
            3,
            38,
            17,
            0,
            2,
            0,
            29,
            0,
            11,
            39,
            8,
            0,
            22,
            0,
            12,
            45,
            20,
            0,
            19,
            72,
            200,
            32,
            32,
            8,
            2,
            36,
            18,
            0,
            50,
            29,
            113,
            6,
            2,
            1,
            2,
            37,
            22,
            0,
            26,
            5,
            2,
            1,
            2,
            31,
            15,
            0,
            328,
            18,
            16,
            0,
            2,
            12,
            2,
            33,
            125,
            0,
            80,
            921,
            103,
            110,
            18,
            195,
            2637,
            96,
            16,
            1071,
            18,
            5,
            26,
            3994,
            6,
            582,
            6842,
            29,
            1763,
            568,
            8,
            30,
            18,
            78,
            18,
            29,
            19,
            47,
            17,
            3,
            32,
            20,
            6,
            18,
            433,
            44,
            212,
            63,
            129,
            74,
            6,
            0,
            67,
            12,
            65,
            1,
            2,
            0,
            29,
            6135,
            9,
            1237,
            42,
            9,
            8936,
            3,
            2,
            6,
            2,
            1,
            2,
            290,
            16,
            0,
            30,
            2,
            3,
            0,
            15,
            3,
            9,
            395,
            2309,
            106,
            6,
            12,
            4,
            8,
            8,
            9,
            5991,
            84,
            2,
            70,
            2,
            1,
            3,
            0,
            3,
            1,
            3,
            3,
            2,
            11,
            2,
            0,
            2,
            6,
            2,
            64,
            2,
            3,
            3,
            7,
            2,
            6,
            2,
            27,
            2,
            3,
            2,
            4,
            2,
            0,
            4,
            6,
            2,
            339,
            3,
            24,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            7,
            1845,
            30,
            7,
            5,
            262,
            61,
            147,
            44,
            11,
            6,
            17,
            0,
            322,
            29,
            19,
            43,
            485,
            27,
            229,
            29,
            3,
            0,
            496,
            6,
            2,
            3,
            2,
            1,
            2,
            14,
            2,
            196,
            60,
            67,
            8,
            0,
            1205,
            3,
            2,
            26,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            9,
            2,
            3,
            2,
            0,
            2,
            0,
            7,
            0,
            5,
            0,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            1,
            2,
            0,
            3,
            3,
            2,
            6,
            2,
            3,
            2,
            3,
            2,
            0,
            2,
            9,
            2,
            16,
            6,
            2,
            2,
            4,
            2,
            16,
            4421,
            42719,
            33,
            4153,
            7,
            221,
            3,
            5761,
            15,
            7472,
            16,
            621,
            2467,
            541,
            1507,
            4938,
            6,
            4191
        ];
        var astralIdentifierCodes = [
            509,
            0,
            227,
            0,
            150,
            4,
            294,
            9,
            1368,
            2,
            2,
            1,
            6,
            3,
            41,
            2,
            5,
            0,
            166,
            1,
            574,
            3,
            9,
            9,
            7,
            9,
            32,
            4,
            318,
            1,
            80,
            3,
            71,
            10,
            50,
            3,
            123,
            2,
            54,
            14,
            32,
            10,
            3,
            1,
            11,
            3,
            46,
            10,
            8,
            0,
            46,
            9,
            7,
            2,
            37,
            13,
            2,
            9,
            6,
            1,
            45,
            0,
            13,
            2,
            49,
            13,
            9,
            3,
            2,
            11,
            83,
            11,
            7,
            0,
            3,
            0,
            158,
            11,
            6,
            9,
            7,
            3,
            56,
            1,
            2,
            6,
            3,
            1,
            3,
            2,
            10,
            0,
            11,
            1,
            3,
            6,
            4,
            4,
            68,
            8,
            2,
            0,
            3,
            0,
            2,
            3,
            2,
            4,
            2,
            0,
            15,
            1,
            83,
            17,
            10,
            9,
            5,
            0,
            82,
            19,
            13,
            9,
            214,
            6,
            3,
            8,
            28,
            1,
            83,
            16,
            16,
            9,
            82,
            12,
            9,
            9,
            7,
            19,
            58,
            14,
            5,
            9,
            243,
            14,
            166,
            9,
            71,
            5,
            2,
            1,
            3,
            3,
            2,
            0,
            2,
            1,
            13,
            9,
            120,
            6,
            3,
            6,
            4,
            0,
            29,
            9,
            41,
            6,
            2,
            3,
            9,
            0,
            10,
            10,
            47,
            15,
            343,
            9,
            54,
            7,
            2,
            7,
            17,
            9,
            57,
            21,
            2,
            13,
            123,
            5,
            4,
            0,
            2,
            1,
            2,
            6,
            2,
            0,
            9,
            9,
            49,
            4,
            2,
            1,
            2,
            4,
            9,
            9,
            330,
            3,
            10,
            1,
            2,
            0,
            49,
            6,
            4,
            4,
            14,
            10,
            5350,
            0,
            7,
            14,
            11465,
            27,
            2343,
            9,
            87,
            9,
            39,
            4,
            60,
            6,
            26,
            9,
            535,
            9,
            470,
            0,
            2,
            54,
            8,
            3,
            82,
            0,
            12,
            1,
            19628,
            1,
            4178,
            9,
            519,
            45,
            3,
            22,
            543,
            4,
            4,
            5,
            9,
            7,
            3,
            6,
            31,
            3,
            149,
            2,
            1418,
            49,
            513,
            54,
            5,
            49,
            9,
            0,
            15,
            0,
            23,
            4,
            2,
            14,
            1361,
            6,
            2,
            16,
            3,
            6,
            2,
            1,
            2,
            4,
            101,
            0,
            161,
            6,
            10,
            9,
            357,
            0,
            62,
            13,
            499,
            13,
            245,
            1,
            2,
            9,
            726,
            6,
            110,
            6,
            6,
            9,
            4759,
            9,
            787719,
            239
        ];
        function isInAstralSet(code, set3) {
            var pos = 65536;
            for(var i = 0, length = set3.length; i < length; i += 2){
                pos += set3[i];
                if (pos > code) return false;
                pos += set3[i + 1];
                if (pos >= code) return true;
            }
            return false;
        }
        function isIdentifierStart(code) {
            if (code < 65) return code === 36;
            if (code <= 90) return true;
            if (code < 97) return code === 95;
            if (code <= 122) return true;
            if (code <= 65535) {
                return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
            }
            return isInAstralSet(code, astralIdentifierStartCodes);
        }
        function isIdentifierChar(code) {
            if (code < 48) return code === 36;
            if (code < 58) return true;
            if (code < 65) return false;
            if (code <= 90) return true;
            if (code < 97) return code === 95;
            if (code <= 122) return true;
            if (code <= 65535) {
                return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
            }
            return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
        }
        function isIdentifierName(name) {
            var isFirst = true;
            for(var i = 0; i < name.length; i++){
                var cp = name.charCodeAt(i);
                if ((cp & 64512) === 55296 && i + 1 < name.length) {
                    var trail = name.charCodeAt(++i);
                    if ((trail & 64512) === 56320) {
                        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
                    }
                }
                if (isFirst) {
                    isFirst = false;
                    if (!isIdentifierStart(cp)) {
                        return false;
                    }
                } else if (!isIdentifierChar(cp)) {
                    return false;
                }
            }
            return !isFirst;
        }
    }
});
// ../../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
    "../../node_modules/@babel/helper-validator-identifier/lib/keyword.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.isKeyword = isKeyword;
        exports.isReservedWord = isReservedWord;
        exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
        exports.isStrictBindReservedWord = isStrictBindReservedWord;
        exports.isStrictReservedWord = isStrictReservedWord;
        var reservedWords = {
            keyword: [
                "break",
                "case",
                "catch",
                "continue",
                "debugger",
                "default",
                "do",
                "else",
                "finally",
                "for",
                "function",
                "if",
                "return",
                "switch",
                "throw",
                "try",
                "var",
                "const",
                "while",
                "with",
                "new",
                "this",
                "super",
                "class",
                "extends",
                "export",
                "import",
                "null",
                "true",
                "false",
                "in",
                "instanceof",
                "typeof",
                "void",
                "delete"
            ],
            strict: [
                "implements",
                "interface",
                "let",
                "package",
                "private",
                "protected",
                "public",
                "static",
                "yield"
            ],
            strictBind: [
                "eval",
                "arguments"
            ]
        };
        var keywords = new Set(reservedWords.keyword);
        var reservedWordsStrictSet = new Set(reservedWords.strict);
        var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
        function isReservedWord(word, inModule) {
            return inModule && word === "await" || word === "enum";
        }
        function isStrictReservedWord(word, inModule) {
            return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
        }
        function isStrictBindOnlyReservedWord(word) {
            return reservedWordsStrictBindSet.has(word);
        }
        function isStrictBindReservedWord(word, inModule) {
            return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
        }
        function isKeyword(word) {
            return keywords.has(word);
        }
    }
});
// ../../node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS({
    "../../node_modules/@babel/helper-validator-identifier/lib/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        Object.defineProperty(exports, "isIdentifierChar", {
            enumerable: true,
            get: function get3() {
                return _identifier.isIdentifierChar;
            }
        });
        Object.defineProperty(exports, "isIdentifierName", {
            enumerable: true,
            get: function get3() {
                return _identifier.isIdentifierName;
            }
        });
        Object.defineProperty(exports, "isIdentifierStart", {
            enumerable: true,
            get: function get3() {
                return _identifier.isIdentifierStart;
            }
        });
        Object.defineProperty(exports, "isKeyword", {
            enumerable: true,
            get: function get3() {
                return _keyword.isKeyword;
            }
        });
        Object.defineProperty(exports, "isReservedWord", {
            enumerable: true,
            get: function get3() {
                return _keyword.isReservedWord;
            }
        });
        Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
            enumerable: true,
            get: function get3() {
                return _keyword.isStrictBindOnlyReservedWord;
            }
        });
        Object.defineProperty(exports, "isStrictBindReservedWord", {
            enumerable: true,
            get: function get3() {
                return _keyword.isStrictBindReservedWord;
            }
        });
        Object.defineProperty(exports, "isStrictReservedWord", {
            enumerable: true,
            get: function get3() {
                return _keyword.isStrictReservedWord;
            }
        });
        var _identifier = require_identifier();
        var _keyword = require_keyword();
    }
});
// ../../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isValidIdentifier.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isValidIdentifier;
        var _helperValidatorIdentifier = require_lib2();
        function isValidIdentifier(name) {
            var reserved = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            if (typeof name !== "string") return false;
            if (reserved) {
                if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
                    return false;
                }
            }
            return (0, _helperValidatorIdentifier.isIdentifierName)(name);
        }
    }
});
// ../../node_modules/@babel/helper-string-parser/lib/index.js
var require_lib3 = __commonJS({
    "../../node_modules/@babel/helper-string-parser/lib/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.readCodePoint = readCodePoint;
        exports.readInt = readInt;
        exports.readStringContents = readStringContents;
        var _isDigit = function isDigit(code) {
            return code >= 48 && code <= 57;
        };
        var forbiddenNumericSeparatorSiblings = {
            decBinOct: /* @__PURE__ */ new Set([
                46,
                66,
                69,
                79,
                95,
                98,
                101,
                111
            ]),
            hex: /* @__PURE__ */ new Set([
                46,
                88,
                95,
                120
            ])
        };
        var isAllowedNumericSeparatorSibling = {
            bin: function(ch) {
                return ch === 48 || ch === 49;
            },
            oct: function(ch) {
                return ch >= 48 && ch <= 55;
            },
            dec: function(ch) {
                return ch >= 48 && ch <= 57;
            },
            hex: function(ch) {
                return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
            }
        };
        function readStringContents(type, input2, pos, lineStart, curLine, errors) {
            var initialPos = pos;
            var initialLineStart = lineStart;
            var initialCurLine = curLine;
            var out = "";
            var firstInvalidLoc = null;
            var chunkStart = pos;
            var length = input2.length;
            for(;;){
                if (pos >= length) {
                    errors.unterminated(initialPos, initialLineStart, initialCurLine);
                    out += input2.slice(chunkStart, pos);
                    break;
                }
                var ch = input2.charCodeAt(pos);
                if (isStringEnd(type, ch, input2, pos)) {
                    out += input2.slice(chunkStart, pos);
                    break;
                }
                if (ch === 92) {
                    out += input2.slice(chunkStart, pos);
                    var res = readEscapedChar(input2, pos, lineStart, curLine, type === "template", errors);
                    if (res.ch === null && !firstInvalidLoc) {
                        firstInvalidLoc = {
                            pos: pos,
                            lineStart: lineStart,
                            curLine: curLine
                        };
                    } else {
                        out += res.ch;
                    }
                    var ref;
                    ref = res, pos = ref.pos, lineStart = ref.lineStart, curLine = ref.curLine, ref;
                    chunkStart = pos;
                } else if (ch === 8232 || ch === 8233) {
                    ++pos;
                    ++curLine;
                    lineStart = pos;
                } else if (ch === 10 || ch === 13) {
                    if (type === "template") {
                        out += input2.slice(chunkStart, pos) + "\n";
                        ++pos;
                        if (ch === 13 && input2.charCodeAt(pos) === 10) {
                            ++pos;
                        }
                        ++curLine;
                        chunkStart = lineStart = pos;
                    } else {
                        errors.unterminated(initialPos, initialLineStart, initialCurLine);
                    }
                } else {
                    ++pos;
                }
            }
            return {
                pos: pos,
                str: out,
                firstInvalidLoc: firstInvalidLoc,
                lineStart: lineStart,
                curLine: curLine,
                containsInvalid: !!firstInvalidLoc
            };
        }
        function isStringEnd(type, ch, input2, pos) {
            if (type === "template") {
                return ch === 96 || ch === 36 && input2.charCodeAt(pos + 1) === 123;
            }
            return ch === (type === "double" ? 34 : 39);
        }
        function readEscapedChar(input2, pos, lineStart, curLine, inTemplate, errors) {
            var throwOnInvalid = !inTemplate;
            pos++;
            var res = function(ch2) {
                return {
                    pos: pos,
                    ch: ch2,
                    lineStart: lineStart,
                    curLine: curLine
                };
            };
            var ch = input2.charCodeAt(pos++);
            switch(ch){
                case 110:
                    return res("\n");
                case 114:
                    return res("\r");
                case 120:
                    {
                        var code;
                        var ref;
                        ref = readHexChar(input2, pos, lineStart, curLine, 2, false, throwOnInvalid, errors), code = ref.code, pos = ref.pos, ref;
                        return res(code === null ? null : String.fromCharCode(code));
                    }
                case 117:
                    {
                        var _code;
                        var ref1;
                        ref1 = readCodePoint(input2, pos, lineStart, curLine, throwOnInvalid, errors), _code = ref1.code, pos = ref1.pos, ref1;
                        return res(_code === null ? null : String.fromCodePoint(_code));
                    }
                case 116:
                    return res("	");
                case 98:
                    return res("\b");
                case 118:
                    return res("\v");
                case 102:
                    return res("\f");
                case 13:
                    if (input2.charCodeAt(pos) === 10) {
                        ++pos;
                    }
                case 10:
                    lineStart = pos;
                    ++curLine;
                case 8232:
                case 8233:
                    return res("");
                case 56:
                case 57:
                    if (inTemplate) {
                        return res(null);
                    } else {
                        errors.strictNumericEscape(pos - 1, lineStart, curLine);
                    }
                default:
                    if (ch >= 48 && ch <= 55) {
                        var startPos = pos - 1;
                        var match = /^[0-7]+/.exec(input2.slice(startPos, pos + 2));
                        var octalStr = match[0];
                        var octal = parseInt(octalStr, 8);
                        if (octal > 255) {
                            octalStr = octalStr.slice(0, -1);
                            octal = parseInt(octalStr, 8);
                        }
                        pos += octalStr.length - 1;
                        var next = input2.charCodeAt(pos);
                        if (octalStr !== "0" || next === 56 || next === 57) {
                            if (inTemplate) {
                                return res(null);
                            } else {
                                errors.strictNumericEscape(startPos, lineStart, curLine);
                            }
                        }
                        return res(String.fromCharCode(octal));
                    }
                    return res(String.fromCharCode(ch));
            }
        }
        function readHexChar(input2, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
            var initialPos = pos;
            var n;
            var ref;
            ref = readInt(input2, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid), n = ref.n, pos = ref.pos, ref;
            if (n === null) {
                if (throwOnInvalid) {
                    errors.invalidEscapeSequence(initialPos, lineStart, curLine);
                } else {
                    pos = initialPos - 1;
                }
            }
            return {
                code: n,
                pos: pos
            };
        }
        function readInt(input2, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
            var start = pos;
            var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
            var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
            var invalid = false;
            var total = 0;
            for(var i = 0, e = len == null ? Infinity : len; i < e; ++i){
                var code = input2.charCodeAt(pos);
                var val = void 0;
                if (code === 95 && allowNumSeparator !== "bail") {
                    var prev = input2.charCodeAt(pos - 1);
                    var next = input2.charCodeAt(pos + 1);
                    if (!allowNumSeparator) {
                        if (bailOnError) return {
                            n: null,
                            pos: pos
                        };
                        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
                    } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                        if (bailOnError) return {
                            n: null,
                            pos: pos
                        };
                        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
                    }
                    ++pos;
                    continue;
                }
                if (code >= 97) {
                    val = code - 97 + 10;
                } else if (code >= 65) {
                    val = code - 65 + 10;
                } else if (_isDigit(code)) {
                    val = code - 48;
                } else {
                    val = Infinity;
                }
                if (val >= radix) {
                    if (val <= 9 && bailOnError) {
                        return {
                            n: null,
                            pos: pos
                        };
                    } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                        val = 0;
                    } else if (forceLen) {
                        val = 0;
                        invalid = true;
                    } else {
                        break;
                    }
                }
                ++pos;
                total = total * radix + val;
            }
            if (pos === start || len != null && pos - start !== len || invalid) {
                return {
                    n: null,
                    pos: pos
                };
            }
            return {
                n: total,
                pos: pos
            };
        }
        function readCodePoint(input2, pos, lineStart, curLine, throwOnInvalid, errors) {
            var ch = input2.charCodeAt(pos);
            var code;
            if (ch === 123) {
                ++pos;
                var ref;
                ref = readHexChar(input2, pos, lineStart, curLine, input2.indexOf("}", pos) - pos, true, throwOnInvalid, errors), code = ref.code, pos = ref.pos, ref;
                ++pos;
                if (code !== null && code > 1114111) {
                    if (throwOnInvalid) {
                        errors.invalidCodePoint(pos, lineStart, curLine);
                    } else {
                        return {
                            code: null,
                            pos: pos
                        };
                    }
                }
            } else {
                var ref1;
                ref1 = readHexChar(input2, pos, lineStart, curLine, 4, false, throwOnInvalid, errors), code = ref1.code, pos = ref1.pos, ref1;
            }
            return {
                code: code,
                pos: pos
            };
        }
    }
});
// ../../node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
    "../../node_modules/@babel/types/lib/constants/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
        var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = [
            "consequent",
            "body",
            "alternate"
        ];
        var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = [
            "body",
            "expressions"
        ];
        var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = [
            "left",
            "init"
        ];
        var COMMENT_KEYS = exports.COMMENT_KEYS = [
            "leadingComments",
            "trailingComments",
            "innerComments"
        ];
        var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = [
            "||",
            "&&",
            "??"
        ];
        var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = [
            "++",
            "--"
        ];
        var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [
            ">",
            "<",
            ">=",
            "<="
        ];
        var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = [
            "==",
            "===",
            "!=",
            "!=="
        ];
        var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = _to_consumable_array(EQUALITY_BINARY_OPERATORS).concat([
            "in",
            "instanceof"
        ]);
        var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = _to_consumable_array(COMPARISON_BINARY_OPERATORS).concat(_to_consumable_array(BOOLEAN_NUMBER_BINARY_OPERATORS));
        var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = [
            "-",
            "/",
            "%",
            "*",
            "**",
            "&",
            "|",
            ">>",
            ">>>",
            "<<",
            "^"
        ];
        var BINARY_OPERATORS = exports.BINARY_OPERATORS = [
            "+"
        ].concat(_to_consumable_array(NUMBER_BINARY_OPERATORS), _to_consumable_array(BOOLEAN_BINARY_OPERATORS), [
            "|>"
        ]);
        var ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = [
            "=",
            "+="
        ].concat(_to_consumable_array(NUMBER_BINARY_OPERATORS.map(function(op) {
            return op + "=";
        })), _to_consumable_array(LOGICAL_OPERATORS.map(function(op) {
            return op + "=";
        })));
        var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = [
            "delete",
            "!"
        ];
        var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = [
            "+",
            "-",
            "~"
        ];
        var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = [
            "typeof"
        ];
        var UNARY_OPERATORS = exports.UNARY_OPERATORS = [
            "void",
            "throw"
        ].concat(_to_consumable_array(BOOLEAN_UNARY_OPERATORS), _to_consumable_array(NUMBER_UNARY_OPERATORS), _to_consumable_array(STRING_UNARY_OPERATORS));
        var INHERIT_KEYS = exports.INHERIT_KEYS = {
            optional: [
                "typeAnnotation",
                "typeParameters",
                "returnType"
            ],
            force: [
                "start",
                "loc",
                "end"
            ]
        };
        var BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
        var NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    }
});
// ../../node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/utils.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
        exports.arrayOf = arrayOf;
        exports.arrayOfType = arrayOfType;
        exports.assertEach = assertEach;
        exports.assertNodeOrValueType = assertNodeOrValueType;
        exports.assertNodeType = assertNodeType;
        exports.assertOneOf = assertOneOf;
        exports.assertOptionalChainStart = assertOptionalChainStart;
        exports.assertShape = assertShape;
        exports.assertValueType = assertValueType;
        exports.chain = chain;
        exports.default = defineType;
        exports.defineAliasedType = defineAliasedType;
        exports.validate = validate;
        exports.validateArrayOfType = validateArrayOfType;
        exports.validateOptional = validateOptional;
        exports.validateOptionalType = validateOptionalType;
        exports.validateType = validateType;
        var _is = require_is();
        var _validate = require_validate();
        var VISITOR_KEYS = exports.VISITOR_KEYS = {};
        var ALIAS_KEYS = exports.ALIAS_KEYS = {};
        var FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};
        var NODE_FIELDS = exports.NODE_FIELDS = {};
        var BUILDER_KEYS = exports.BUILDER_KEYS = {};
        var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};
        var NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};
        function getType(val) {
            if (Array.isArray(val)) {
                return "array";
            } else if (val === null) {
                return "null";
            } else {
                return typeof val === "undefined" ? "undefined" : _type_of(val);
            }
        }
        function validate(validate2) {
            return {
                validate: validate2
            };
        }
        function validateType() {
            return validate(assertNodeType.apply(void 0, arguments));
        }
        function validateOptional(validate2) {
            return {
                validate: validate2,
                optional: true
            };
        }
        function validateOptionalType() {
            return {
                validate: assertNodeType.apply(void 0, arguments),
                optional: true
            };
        }
        function arrayOf(elementType) {
            return chain(assertValueType("array"), assertEach(elementType));
        }
        function arrayOfType() {
            return arrayOf(assertNodeType.apply(void 0, arguments));
        }
        function validateArrayOfType() {
            return validate(arrayOfType.apply(void 0, arguments));
        }
        function assertEach(callback) {
            var childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : function() {};
            function validator(node, key2, val) {
                if (!Array.isArray(val)) return;
                for(var i = 0; i < val.length; i++){
                    var subkey = "".concat(key2, "[").concat(i, "]");
                    var v = val[i];
                    callback(node, subkey, v);
                    childValidator(node, subkey, v);
                }
            }
            validator.each = callback;
            return validator;
        }
        function assertOneOf() {
            for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){
                values[_key] = arguments[_key];
            }
            function validate2(node, key2, val) {
                if (!values.includes(val)) {
                    throw new TypeError("Property ".concat(key2, " expected value to be one of ").concat(JSON.stringify(values), " but got ").concat(JSON.stringify(val)));
                }
            }
            validate2.oneOf = values;
            return validate2;
        }
        function assertNodeType() {
            for(var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
                types[_key2] = arguments[_key2];
            }
            function validate2(node, key2, val) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var type = _step.value;
                        if ((0, _is.default)(type, val)) {
                            (0, _validate.validateChild)(node, key2, val);
                            return;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                throw new TypeError("Property ".concat(key2, " of ").concat(node.type, " expected node to be of a type ").concat(JSON.stringify(types), " but instead got ").concat(JSON.stringify(val == null ? void 0 : val.type)));
            }
            validate2.oneOfNodeTypes = types;
            return validate2;
        }
        function assertNodeOrValueType() {
            for(var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
                types[_key3] = arguments[_key3];
            }
            function validate2(node, key2, val) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var type = _step.value;
                        if (getType(val) === type || (0, _is.default)(type, val)) {
                            (0, _validate.validateChild)(node, key2, val);
                            return;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                throw new TypeError("Property ".concat(key2, " of ").concat(node.type, " expected node to be of a type ").concat(JSON.stringify(types), " but instead got ").concat(JSON.stringify(val == null ? void 0 : val.type)));
            }
            validate2.oneOfNodeOrValueTypes = types;
            return validate2;
        }
        function assertValueType(type) {
            function validate2(node, key2, val) {
                var valid = getType(val) === type;
                if (!valid) {
                    throw new TypeError("Property ".concat(key2, " expected type of ").concat(type, " but got ").concat(getType(val)));
                }
            }
            validate2.type = type;
            return validate2;
        }
        function assertShape(shape) {
            function validate2(node, key2, val) {
                var errors = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = Object.keys(shape)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var property = _step.value;
                        try {
                            (0, _validate.validateField)(node, property, val[property], shape[property]);
                        } catch (error) {
                            if (_instanceof(error, TypeError)) {
                                errors.push(error.message);
                                continue;
                            }
                            throw error;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (errors.length) {
                    throw new TypeError("Property ".concat(key2, " of ").concat(node.type, " expected to have the following:\n").concat(errors.join("\n")));
                }
            }
            validate2.shapeOf = shape;
            return validate2;
        }
        function assertOptionalChainStart() {
            function validate2(node) {
                var _current;
                var current = node;
                while(node){
                    var type = current.type;
                    if (type === "OptionalCallExpression") {
                        if (current.optional) return;
                        current = current.callee;
                        continue;
                    }
                    if (type === "OptionalMemberExpression") {
                        if (current.optional) return;
                        current = current.object;
                        continue;
                    }
                    break;
                }
                throw new TypeError("Non-optional ".concat(node.type, " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ").concat((_current = current) == null ? void 0 : _current.type));
            }
            return validate2;
        }
        function chain() {
            for(var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
                fns[_key4] = arguments[_key4];
            }
            function validate2() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = fns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var fn = _step.value;
                        fn.apply(void 0, arguments);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            validate2.chainOf = fns;
            if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
                throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
            }
            return validate2;
        }
        var validTypeOpts = /* @__PURE__ */ new Set([
            "aliases",
            "builder",
            "deprecatedAlias",
            "fields",
            "inherits",
            "visitor",
            "validate"
        ]);
        var validFieldKeys = /* @__PURE__ */ new Set([
            "default",
            "optional",
            "deprecated",
            "validate"
        ]);
        var store = {};
        function defineAliasedType() {
            for(var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
                aliases[_key5] = arguments[_key5];
            }
            return function(type) {
                var _defined;
                var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var defined = opts.aliases;
                if (!defined) {
                    var _store$opts$inherits$, _defined1;
                    if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
                    (_defined1 = defined) != null ? _defined1 : defined = [];
                    opts.aliases = defined;
                }
                var additional = aliases.filter(function(a) {
                    return !defined.includes(a);
                });
                (_defined = defined).unshift.apply(_defined, _to_consumable_array(additional));
                defineType(type, opts);
            };
        }
        function defineType(type) {
            var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var inherits = opts.inherits && store[opts.inherits] || {};
            var fields = opts.fields;
            if (!fields) {
                fields = {};
                if (inherits.fields) {
                    var keys = Object.getOwnPropertyNames(inherits.fields);
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var key2 = _step.value;
                            var field = inherits.fields[key2];
                            var def = field.default;
                            if (Array.isArray(def) ? def.length > 0 : def && (typeof def === "undefined" ? "undefined" : _type_of(def)) === "object") {
                                throw new Error("field defaults can only be primitives or empty arrays currently");
                            }
                            fields[key2] = {
                                default: Array.isArray(def) ? [] : def,
                                optional: field.optional,
                                deprecated: field.deprecated,
                                validate: field.validate
                            };
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            }
            var visitor = opts.visitor || inherits.visitor || [];
            var aliases = opts.aliases || inherits.aliases || [];
            var builder = opts.builder || inherits.builder || opts.visitor || [];
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = Object.keys(opts)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var k = _step1.value;
                    if (!validTypeOpts.has(k)) {
                        throw new Error('Unknown type option "'.concat(k, '" on ').concat(type));
                    }
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
            if (opts.deprecatedAlias) {
                DEPRECATED_KEYS[opts.deprecatedAlias] = type;
            }
            var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
            try {
                for(var _iterator2 = visitor.concat(builder)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var _key6 = _step2.value;
                    fields[_key6] = fields[_key6] || {};
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                        _iterator2.return();
                    }
                } finally{
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
            var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
            try {
                for(var _iterator3 = Object.keys(fields)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                    var _key7 = _step3.value;
                    var _field = fields[_key7];
                    if (_field.default !== void 0 && !builder.includes(_key7)) {
                        _field.optional = true;
                    }
                    if (_field.default === void 0) {
                        _field.default = null;
                    } else if (!_field.validate && _field.default != null) {
                        _field.validate = assertValueType(getType(_field.default));
                    }
                    var _iteratorNormalCompletion4 = true, _didIteratorError4 = false, _iteratorError4 = undefined;
                    try {
                        for(var _iterator4 = Object.keys(_field)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){
                            var _k = _step4.value;
                            if (!validFieldKeys.has(_k)) {
                                throw new Error('Unknown field key "'.concat(_k, '" on ').concat(type, ".").concat(_key7));
                            }
                        }
                    } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                                _iterator4.return();
                            }
                        } finally{
                            if (_didIteratorError4) {
                                throw _iteratorError4;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                        _iterator3.return();
                    }
                } finally{
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
            VISITOR_KEYS[type] = opts.visitor = visitor;
            BUILDER_KEYS[type] = opts.builder = builder;
            NODE_FIELDS[type] = opts.fields = fields;
            ALIAS_KEYS[type] = opts.aliases = aliases;
            aliases.forEach(function(alias) {
                FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
                FLIPPED_ALIAS_KEYS[alias].push(type);
            });
            if (opts.validate) {
                NODE_PARENT_VALIDATIONS[type] = opts.validate;
            }
            store[type] = opts;
        }
    }
});
// ../../node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/core.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
        var _is = require_is();
        var _isValidIdentifier = require_isValidIdentifier();
        var _helperValidatorIdentifier = require_lib2();
        var _helperStringParser = require_lib3();
        var _index = require_constants();
        var _utils = require_utils();
        var defineType = (0, _utils.defineAliasedType)("Standardized");
        defineType("ArrayExpression", {
            fields: {
                elements: {
                    validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
                    default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
                }
            },
            visitor: [
                "elements"
            ],
            aliases: [
                "Expression"
            ]
        });
        defineType("AssignmentExpression", {
            fields: {
                operator: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function() {
                        var identifier = (0, _utils.assertOneOf).apply(this, _to_consumable_array(_index.ASSIGNMENT_OPERATORS));
                        var pattern = (0, _utils.assertOneOf)("=");
                        return function(node, key2, val) {
                            var validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
                            validator(node, key2, val);
                        };
                    }(), {
                        type: "string"
                    })
                },
                left: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                },
                right: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            },
            builder: [
                "operator",
                "left",
                "right"
            ],
            visitor: [
                "left",
                "right"
            ],
            aliases: [
                "Expression"
            ]
        });
        defineType("BinaryExpression", {
            builder: [
                "operator",
                "left",
                "right"
            ],
            fields: {
                operator: {
                    validate: (0, _utils.assertOneOf).apply(this, _to_consumable_array(_index.BINARY_OPERATORS))
                },
                left: {
                    validate: function() {
                        var expression = (0, _utils.assertNodeType)("Expression");
                        var inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
                        var validator = Object.assign(function(node, key2, val) {
                            var validator2 = node.operator === "in" ? inOp : expression;
                            validator2(node, key2, val);
                        }, {
                            oneOfNodeTypes: [
                                "Expression",
                                "PrivateName"
                            ]
                        });
                        return validator;
                    }()
                },
                right: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            },
            visitor: [
                "left",
                "right"
            ],
            aliases: [
                "Binary",
                "Expression"
            ]
        });
        defineType("InterpreterDirective", {
            builder: [
                "value"
            ],
            fields: {
                value: {
                    validate: (0, _utils.assertValueType)("string")
                }
            }
        });
        defineType("Directive", {
            visitor: [
                "value"
            ],
            fields: {
                value: {
                    validate: (0, _utils.assertNodeType)("DirectiveLiteral")
                }
            }
        });
        defineType("DirectiveLiteral", {
            builder: [
                "value"
            ],
            fields: {
                value: {
                    validate: (0, _utils.assertValueType)("string")
                }
            }
        });
        defineType("BlockStatement", {
            builder: [
                "body",
                "directives"
            ],
            visitor: [
                "directives",
                "body"
            ],
            fields: {
                directives: {
                    validate: (0, _utils.arrayOfType)("Directive"),
                    default: []
                },
                body: (0, _utils.validateArrayOfType)("Statement")
            },
            aliases: [
                "Scopable",
                "BlockParent",
                "Block",
                "Statement"
            ]
        });
        defineType("BreakStatement", {
            visitor: [
                "label"
            ],
            fields: {
                label: {
                    validate: (0, _utils.assertNodeType)("Identifier"),
                    optional: true
                }
            },
            aliases: [
                "Statement",
                "Terminatorless",
                "CompletionStatement"
            ]
        });
        defineType("CallExpression", {
            visitor: [
                "callee",
                "arguments",
                "typeParameters",
                "typeArguments"
            ],
            builder: [
                "callee",
                "arguments"
            ],
            aliases: [
                "Expression"
            ],
            fields: Object.assign({
                callee: {
                    validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
                },
                arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder")
            }, !process.env.BABEL_TYPES_8_BREAKING ? {
                optional: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                }
            } : {}, {
                typeArguments: {
                    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
                    optional: true
                },
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
                    optional: true
                }
            })
        });
        defineType("CatchClause", {
            visitor: [
                "param",
                "body"
            ],
            fields: {
                param: {
                    validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
                    optional: true
                },
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                }
            },
            aliases: [
                "Scopable",
                "BlockParent"
            ]
        });
        defineType("ConditionalExpression", {
            visitor: [
                "test",
                "consequent",
                "alternate"
            ],
            fields: {
                test: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                consequent: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                alternate: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            },
            aliases: [
                "Expression",
                "Conditional"
            ]
        });
        defineType("ContinueStatement", {
            visitor: [
                "label"
            ],
            fields: {
                label: {
                    validate: (0, _utils.assertNodeType)("Identifier"),
                    optional: true
                }
            },
            aliases: [
                "Statement",
                "Terminatorless",
                "CompletionStatement"
            ]
        });
        defineType("DebuggerStatement", {
            aliases: [
                "Statement"
            ]
        });
        defineType("DoWhileStatement", {
            builder: [
                "test",
                "body"
            ],
            visitor: [
                "body",
                "test"
            ],
            fields: {
                test: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("Statement")
                }
            },
            aliases: [
                "Statement",
                "BlockParent",
                "Loop",
                "While",
                "Scopable"
            ]
        });
        defineType("EmptyStatement", {
            aliases: [
                "Statement"
            ]
        });
        defineType("ExpressionStatement", {
            visitor: [
                "expression"
            ],
            fields: {
                expression: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            },
            aliases: [
                "Statement",
                "ExpressionWrapper"
            ]
        });
        defineType("File", {
            builder: [
                "program",
                "comments",
                "tokens"
            ],
            visitor: [
                "program"
            ],
            fields: {
                program: {
                    validate: (0, _utils.assertNodeType)("Program")
                },
                comments: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {}, {
                        each: {
                            oneOfNodeTypes: [
                                "CommentBlock",
                                "CommentLine"
                            ]
                        }
                    }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
                    optional: true
                },
                tokens: {
                    validate: (0, _utils.assertEach)(Object.assign(function() {}, {
                        type: "any"
                    })),
                    optional: true
                }
            }
        });
        defineType("ForInStatement", {
            visitor: [
                "left",
                "right",
                "body"
            ],
            aliases: [
                "Scopable",
                "Statement",
                "For",
                "BlockParent",
                "Loop",
                "ForXStatement"
            ],
            fields: {
                left: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                },
                right: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("Statement")
                }
            }
        });
        defineType("ForStatement", {
            visitor: [
                "init",
                "test",
                "update",
                "body"
            ],
            aliases: [
                "Scopable",
                "Statement",
                "For",
                "BlockParent",
                "Loop"
            ],
            fields: {
                init: {
                    validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
                    optional: true
                },
                test: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                },
                update: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                },
                body: {
                    validate: (0, _utils.assertNodeType)("Statement")
                }
            }
        });
        var functionCommon = function() {
            return {
                params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
                generator: {
                    default: false
                },
                async: {
                    default: false
                }
            };
        };
        exports.functionCommon = functionCommon;
        var functionTypeAnnotationCommon = function() {
            return {
                returnType: {
                    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: true
                },
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                    optional: true
                }
            };
        };
        exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
        var functionDeclarationCommon = function() {
            return Object.assign({}, functionCommon(), {
                declare: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                id: {
                    validate: (0, _utils.assertNodeType)("Identifier"),
                    optional: true
                }
            });
        };
        exports.functionDeclarationCommon = functionDeclarationCommon;
        defineType("FunctionDeclaration", {
            builder: [
                "id",
                "params",
                "body",
                "generator",
                "async"
            ],
            visitor: [
                "id",
                "typeParameters",
                "params",
                "returnType",
                "body"
            ],
            fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                },
                predicate: {
                    validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                    optional: true
                }
            }),
            aliases: [
                "Scopable",
                "Function",
                "BlockParent",
                "FunctionParent",
                "Statement",
                "Pureish",
                "Declaration"
            ],
            validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
                var identifier = (0, _utils.assertNodeType)("Identifier");
                return function(parent, key2, node) {
                    if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
                        identifier(node, "id", node.id);
                    }
                };
            }()
        });
        defineType("FunctionExpression", {
            inherits: "FunctionDeclaration",
            aliases: [
                "Scopable",
                "Function",
                "BlockParent",
                "FunctionParent",
                "Expression",
                "Pureish"
            ],
            fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                id: {
                    validate: (0, _utils.assertNodeType)("Identifier"),
                    optional: true
                },
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                },
                predicate: {
                    validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                    optional: true
                }
            })
        });
        var patternLikeCommon = function() {
            return {
                typeAnnotation: {
                    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: true
                },
                optional: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                }
            };
        };
        exports.patternLikeCommon = patternLikeCommon;
        defineType("Identifier", {
            builder: [
                "name"
            ],
            visitor: [
                "typeAnnotation",
                "decorators"
            ],
            aliases: [
                "Expression",
                "PatternLike",
                "LVal",
                "TSEntityName"
            ],
            fields: Object.assign({}, patternLikeCommon(), {
                name: {
                    validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key2, val) {
                        if (!(0, _isValidIdentifier.default)(val, false)) {
                            throw new TypeError('"'.concat(val, '" is not a valid identifier name'));
                        }
                    }, {
                        type: "string"
                    })) : (0, _utils.assertValueType)("string")
                }
            }),
            validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key2, node) {
                var match = /\.(\w+)$/.exec(key2);
                if (!match) return;
                var _match = _sliced_to_array(match, 2), parentKey = _match[1];
                var nonComp = {
                    computed: false
                };
                if (parentKey === "property") {
                    if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
                    if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
                } else if (parentKey === "key") {
                    if ((0, _is.default)("Property", parent, nonComp)) return;
                    if ((0, _is.default)("Method", parent, nonComp)) return;
                } else if (parentKey === "exported") {
                    if ((0, _is.default)("ExportSpecifier", parent)) return;
                } else if (parentKey === "imported") {
                    if ((0, _is.default)("ImportSpecifier", parent, {
                        imported: node
                    })) return;
                } else if (parentKey === "meta") {
                    if ((0, _is.default)("MetaProperty", parent, {
                        meta: node
                    })) return;
                }
                if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
                    throw new TypeError('"'.concat(node.name, '" is not a valid identifier'));
                }
            } : void 0
        });
        defineType("IfStatement", {
            visitor: [
                "test",
                "consequent",
                "alternate"
            ],
            aliases: [
                "Statement",
                "Conditional"
            ],
            fields: {
                test: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                consequent: {
                    validate: (0, _utils.assertNodeType)("Statement")
                },
                alternate: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("Statement")
                }
            }
        });
        defineType("LabeledStatement", {
            visitor: [
                "label",
                "body"
            ],
            aliases: [
                "Statement"
            ],
            fields: {
                label: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("Statement")
                }
            }
        });
        defineType("StringLiteral", {
            builder: [
                "value"
            ],
            fields: {
                value: {
                    validate: (0, _utils.assertValueType)("string")
                }
            },
            aliases: [
                "Expression",
                "Pureish",
                "Literal",
                "Immutable"
            ]
        });
        defineType("NumericLiteral", {
            builder: [
                "value"
            ],
            deprecatedAlias: "NumberLiteral",
            fields: {
                value: {
                    validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node, key2, val) {
                        if (1 / val < 0 || !Number.isFinite(val)) {
                            var error = new Error("NumericLiterals must be non-negative finite numbers. " + "You can use t.valueToNode(".concat(val, ") instead."));
                            {}
                        }
                    }, {
                        type: "number"
                    }))
                }
            },
            aliases: [
                "Expression",
                "Pureish",
                "Literal",
                "Immutable"
            ]
        });
        defineType("NullLiteral", {
            aliases: [
                "Expression",
                "Pureish",
                "Literal",
                "Immutable"
            ]
        });
        defineType("BooleanLiteral", {
            builder: [
                "value"
            ],
            fields: {
                value: {
                    validate: (0, _utils.assertValueType)("boolean")
                }
            },
            aliases: [
                "Expression",
                "Pureish",
                "Literal",
                "Immutable"
            ]
        });
        defineType("RegExpLiteral", {
            builder: [
                "pattern",
                "flags"
            ],
            deprecatedAlias: "RegexLiteral",
            aliases: [
                "Expression",
                "Pureish",
                "Literal"
            ],
            fields: {
                pattern: {
                    validate: (0, _utils.assertValueType)("string")
                },
                flags: {
                    validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key2, val) {
                        var invalid = /[^gimsuy]/.exec(val);
                        if (invalid) {
                            throw new TypeError('"'.concat(invalid[0], '" is not a valid RegExp flag'));
                        }
                    }, {
                        type: "string"
                    })) : (0, _utils.assertValueType)("string"),
                    default: ""
                }
            }
        });
        defineType("LogicalExpression", {
            builder: [
                "operator",
                "left",
                "right"
            ],
            visitor: [
                "left",
                "right"
            ],
            aliases: [
                "Binary",
                "Expression"
            ],
            fields: {
                operator: {
                    validate: (0, _utils.assertOneOf).apply(this, _to_consumable_array(_index.LOGICAL_OPERATORS))
                },
                left: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                right: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("MemberExpression", {
            builder: [
                "object",
                "property",
                "computed"
            ].concat(_to_consumable_array(!process.env.BABEL_TYPES_8_BREAKING ? [
                "optional"
            ] : [])),
            visitor: [
                "object",
                "property"
            ],
            aliases: [
                "Expression",
                "LVal"
            ],
            fields: Object.assign({
                object: {
                    validate: (0, _utils.assertNodeType)("Expression", "Super")
                },
                property: {
                    validate: function() {
                        var normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
                        var computed = (0, _utils.assertNodeType)("Expression");
                        var validator = function validator2(node, key2, val) {
                            var validator3 = node.computed ? computed : normal;
                            validator3(node, key2, val);
                        };
                        validator.oneOfNodeTypes = [
                            "Expression",
                            "Identifier",
                            "PrivateName"
                        ];
                        return validator;
                    }()
                },
                computed: {
                    default: false
                }
            }, !process.env.BABEL_TYPES_8_BREAKING ? {
                optional: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                }
            } : {})
        });
        defineType("NewExpression", {
            inherits: "CallExpression"
        });
        defineType("Program", {
            visitor: [
                "directives",
                "body"
            ],
            builder: [
                "body",
                "directives",
                "sourceType",
                "interpreter"
            ],
            fields: {
                sourceType: {
                    validate: (0, _utils.assertOneOf)("script", "module"),
                    default: "script"
                },
                interpreter: {
                    validate: (0, _utils.assertNodeType)("InterpreterDirective"),
                    default: null,
                    optional: true
                },
                directives: {
                    validate: (0, _utils.arrayOfType)("Directive"),
                    default: []
                },
                body: (0, _utils.validateArrayOfType)("Statement")
            },
            aliases: [
                "Scopable",
                "BlockParent",
                "Block"
            ]
        });
        defineType("ObjectExpression", {
            visitor: [
                "properties"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
            }
        });
        defineType("ObjectMethod", {
            builder: [
                "kind",
                "key",
                "params",
                "body",
                "computed",
                "generator",
                "async"
            ],
            visitor: [
                "decorators",
                "key",
                "typeParameters",
                "params",
                "returnType",
                "body"
            ],
            fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                kind: Object.assign({
                    validate: (0, _utils.assertOneOf)("method", "get", "set")
                }, !process.env.BABEL_TYPES_8_BREAKING ? {
                    default: "method"
                } : {}),
                computed: {
                    default: false
                },
                key: {
                    validate: function() {
                        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
                        var computed = (0, _utils.assertNodeType)("Expression");
                        var validator = function validator2(node, key2, val) {
                            var validator3 = node.computed ? computed : normal;
                            validator3(node, key2, val);
                        };
                        validator.oneOfNodeTypes = [
                            "Expression",
                            "Identifier",
                            "StringLiteral",
                            "NumericLiteral",
                            "BigIntLiteral"
                        ];
                        return validator;
                    }()
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                },
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                }
            }),
            aliases: [
                "UserWhitespacable",
                "Function",
                "Scopable",
                "BlockParent",
                "FunctionParent",
                "Method",
                "ObjectMember"
            ]
        });
        defineType("ObjectProperty", {
            builder: [
                "key",
                "value",
                "computed",
                "shorthand"
            ].concat(_to_consumable_array(!process.env.BABEL_TYPES_8_BREAKING ? [
                "decorators"
            ] : [])),
            fields: {
                computed: {
                    default: false
                },
                key: {
                    validate: function() {
                        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
                        var computed = (0, _utils.assertNodeType)("Expression");
                        var validator = Object.assign(function(node, key2, val) {
                            var validator2 = node.computed ? computed : normal;
                            validator2(node, key2, val);
                        }, {
                            oneOfNodeTypes: [
                                "Expression",
                                "Identifier",
                                "StringLiteral",
                                "NumericLiteral",
                                "BigIntLiteral",
                                "DecimalLiteral",
                                "PrivateName"
                            ]
                        });
                        return validator;
                    }()
                },
                value: {
                    validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
                },
                shorthand: {
                    validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key2, shorthand) {
                        if (!shorthand) return;
                        if (node.computed) {
                            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
                        }
                        if (!(0, _is.default)("Identifier", node.key)) {
                            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
                        }
                    }, {
                        type: "boolean"
                    })) : (0, _utils.assertValueType)("boolean"),
                    default: false
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                }
            },
            visitor: [
                "key",
                "value",
                "decorators"
            ],
            aliases: [
                "UserWhitespacable",
                "Property",
                "ObjectMember"
            ],
            validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
                var pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
                var expression = (0, _utils.assertNodeType)("Expression");
                return function(parent, key2, node) {
                    var validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
                    validator(node, "value", node.value);
                };
            }()
        });
        defineType("RestElement", {
            visitor: [
                "argument",
                "typeAnnotation"
            ],
            builder: [
                "argument"
            ],
            aliases: [
                "LVal",
                "PatternLike"
            ],
            deprecatedAlias: "RestProperty",
            fields: Object.assign({}, patternLikeCommon(), {
                argument: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                }
            }),
            validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key2) {
                var match = /(\w+)\[(\d+)\]/.exec(key2);
                if (!match) throw new Error("Internal Babel error: malformed key.");
                var _match = _sliced_to_array(match, 3), listKey = _match[1], index = _match[2];
                if (parent[listKey].length > +index + 1) {
                    throw new TypeError("RestElement must be last element of ".concat(listKey));
                }
            } : void 0
        });
        defineType("ReturnStatement", {
            visitor: [
                "argument"
            ],
            aliases: [
                "Statement",
                "Terminatorless",
                "CompletionStatement"
            ],
            fields: {
                argument: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                }
            }
        });
        defineType("SequenceExpression", {
            visitor: [
                "expressions"
            ],
            fields: {
                expressions: (0, _utils.validateArrayOfType)("Expression")
            },
            aliases: [
                "Expression"
            ]
        });
        defineType("ParenthesizedExpression", {
            visitor: [
                "expression"
            ],
            aliases: [
                "Expression",
                "ExpressionWrapper"
            ],
            fields: {
                expression: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("SwitchCase", {
            visitor: [
                "test",
                "consequent"
            ],
            fields: {
                test: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                },
                consequent: (0, _utils.validateArrayOfType)("Statement")
            }
        });
        defineType("SwitchStatement", {
            visitor: [
                "discriminant",
                "cases"
            ],
            aliases: [
                "Statement",
                "BlockParent",
                "Scopable"
            ],
            fields: {
                discriminant: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                cases: (0, _utils.validateArrayOfType)("SwitchCase")
            }
        });
        defineType("ThisExpression", {
            aliases: [
                "Expression"
            ]
        });
        defineType("ThrowStatement", {
            visitor: [
                "argument"
            ],
            aliases: [
                "Statement",
                "Terminatorless",
                "CompletionStatement"
            ],
            fields: {
                argument: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("TryStatement", {
            visitor: [
                "block",
                "handler",
                "finalizer"
            ],
            aliases: [
                "Statement"
            ],
            fields: {
                block: {
                    validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
                        if (!node.handler && !node.finalizer) {
                            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
                        }
                    }, {
                        oneOfNodeTypes: [
                            "BlockStatement"
                        ]
                    })) : (0, _utils.assertNodeType)("BlockStatement")
                },
                handler: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("CatchClause")
                },
                finalizer: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                }
            }
        });
        defineType("UnaryExpression", {
            builder: [
                "operator",
                "argument",
                "prefix"
            ],
            fields: {
                prefix: {
                    default: true
                },
                argument: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                operator: {
                    validate: (0, _utils.assertOneOf).apply(this, _to_consumable_array(_index.UNARY_OPERATORS))
                }
            },
            visitor: [
                "argument"
            ],
            aliases: [
                "UnaryLike",
                "Expression"
            ]
        });
        defineType("UpdateExpression", {
            builder: [
                "operator",
                "argument",
                "prefix"
            ],
            fields: {
                prefix: {
                    default: false
                },
                argument: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
                },
                operator: {
                    validate: (0, _utils.assertOneOf).apply(this, _to_consumable_array(_index.UPDATE_OPERATORS))
                }
            },
            visitor: [
                "argument"
            ],
            aliases: [
                "Expression"
            ]
        });
        defineType("VariableDeclaration", {
            builder: [
                "kind",
                "declarations"
            ],
            visitor: [
                "declarations"
            ],
            aliases: [
                "Statement",
                "Declaration"
            ],
            fields: {
                declare: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                kind: {
                    validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
                },
                declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
            },
            validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
                var withoutInit = (0, _utils.assertNodeType)("Identifier");
                return function(parent, key2, node) {
                    if ((0, _is.default)("ForXStatement", parent, {
                        left: node
                    })) {
                        if (node.declarations.length !== 1) {
                            throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(parent.type));
                        }
                    } else {
                        node.declarations.forEach(function(decl) {
                            if (!decl.init) withoutInit(decl, "id", decl.id);
                        });
                    }
                };
            }() : void 0
        });
        defineType("VariableDeclarator", {
            visitor: [
                "id",
                "init"
            ],
            fields: {
                id: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
                },
                definite: {
                    optional: true,
                    validate: (0, _utils.assertValueType)("boolean")
                },
                init: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("WhileStatement", {
            visitor: [
                "test",
                "body"
            ],
            aliases: [
                "Statement",
                "BlockParent",
                "Loop",
                "While",
                "Scopable"
            ],
            fields: {
                test: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("Statement")
                }
            }
        });
        defineType("WithStatement", {
            visitor: [
                "object",
                "body"
            ],
            aliases: [
                "Statement"
            ],
            fields: {
                object: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("Statement")
                }
            }
        });
        defineType("AssignmentPattern", {
            visitor: [
                "left",
                "right",
                "decorators"
            ],
            builder: [
                "left",
                "right"
            ],
            aliases: [
                "Pattern",
                "PatternLike",
                "LVal"
            ],
            fields: Object.assign({}, patternLikeCommon(), {
                left: {
                    validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                },
                right: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                }
            })
        });
        defineType("ArrayPattern", {
            visitor: [
                "elements",
                "typeAnnotation"
            ],
            builder: [
                "elements"
            ],
            aliases: [
                "Pattern",
                "PatternLike",
                "LVal"
            ],
            fields: Object.assign({}, patternLikeCommon(), {
                elements: {
                    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
                }
            })
        });
        defineType("ArrowFunctionExpression", {
            builder: [
                "params",
                "body",
                "async"
            ],
            visitor: [
                "typeParameters",
                "params",
                "returnType",
                "body"
            ],
            aliases: [
                "Scopable",
                "Function",
                "BlockParent",
                "FunctionParent",
                "Expression",
                "Pureish"
            ],
            fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                expression: {
                    validate: (0, _utils.assertValueType)("boolean")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
                },
                predicate: {
                    validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                    optional: true
                }
            })
        });
        defineType("ClassBody", {
            visitor: [
                "body"
            ],
            fields: {
                body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
            }
        });
        defineType("ClassExpression", {
            builder: [
                "id",
                "superClass",
                "body",
                "decorators"
            ],
            visitor: [
                "decorators",
                "id",
                "typeParameters",
                "superClass",
                "superTypeParameters",
                "mixins",
                "implements",
                "body"
            ],
            aliases: [
                "Scopable",
                "Class",
                "Expression"
            ],
            fields: {
                id: {
                    validate: (0, _utils.assertNodeType)("Identifier"),
                    optional: true
                },
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                    optional: true
                },
                body: {
                    validate: (0, _utils.assertNodeType)("ClassBody")
                },
                superClass: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                superTypeParameters: {
                    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                    optional: true
                },
                implements: {
                    validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                },
                mixins: {
                    validate: (0, _utils.assertNodeType)("InterfaceExtends"),
                    optional: true
                }
            }
        });
        defineType("ClassDeclaration", {
            inherits: "ClassExpression",
            aliases: [
                "Scopable",
                "Class",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: {
                    validate: (0, _utils.assertNodeType)("Identifier"),
                    optional: true
                },
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                    optional: true
                },
                body: {
                    validate: (0, _utils.assertNodeType)("ClassBody")
                },
                superClass: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                superTypeParameters: {
                    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                    optional: true
                },
                implements: {
                    validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                },
                mixins: {
                    validate: (0, _utils.assertNodeType)("InterfaceExtends"),
                    optional: true
                },
                declare: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                abstract: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                }
            },
            validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
                var identifier = (0, _utils.assertNodeType)("Identifier");
                return function(parent, key2, node) {
                    if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
                        identifier(node, "id", node.id);
                    }
                };
            }()
        });
        var importAttributes = exports.importAttributes = {
            attributes: {
                optional: true,
                validate: (0, _utils.arrayOfType)("ImportAttribute")
            },
            assertions: {
                deprecated: true,
                optional: true,
                validate: (0, _utils.arrayOfType)("ImportAttribute")
            }
        };
        defineType("ExportAllDeclaration", {
            builder: [
                "source"
            ],
            visitor: [
                "source",
                "attributes",
                "assertions"
            ],
            aliases: [
                "Statement",
                "Declaration",
                "ImportOrExportDeclaration",
                "ExportDeclaration"
            ],
            fields: Object.assign({
                source: {
                    validate: (0, _utils.assertNodeType)("StringLiteral")
                },
                exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
            }, importAttributes)
        });
        defineType("ExportDefaultDeclaration", {
            visitor: [
                "declaration"
            ],
            aliases: [
                "Statement",
                "Declaration",
                "ImportOrExportDeclaration",
                "ExportDeclaration"
            ],
            fields: {
                declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
                exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
            }
        });
        defineType("ExportNamedDeclaration", {
            builder: [
                "declaration",
                "specifiers",
                "source"
            ],
            visitor: process.env ? [
                "declaration",
                "specifiers",
                "source",
                "attributes"
            ] : [
                "declaration",
                "specifiers",
                "source",
                "attributes",
                "assertions"
            ],
            aliases: [
                "Statement",
                "Declaration",
                "ImportOrExportDeclaration",
                "ExportDeclaration"
            ],
            fields: Object.assign({
                declaration: {
                    optional: true,
                    validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key2, val) {
                        if (val && node.specifiers.length) {
                            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
                        }
                        if (val && node.source) {
                            throw new TypeError("Cannot export a declaration from a source");
                        }
                    }, {
                        oneOfNodeTypes: [
                            "Declaration"
                        ]
                    })) : (0, _utils.assertNodeType)("Declaration")
                }
            }, importAttributes, {
                specifiers: {
                    default: [],
                    validate: (0, _utils.arrayOf)(function() {
                        var sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
                        var sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
                        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
                        return Object.assign(function(node, key2, val) {
                            var validator = node.source ? sourced : sourceless;
                            validator(node, key2, val);
                        }, {
                            oneOfNodeTypes: [
                                "ExportSpecifier",
                                "ExportDefaultSpecifier",
                                "ExportNamespaceSpecifier"
                            ]
                        });
                    }())
                },
                source: {
                    validate: (0, _utils.assertNodeType)("StringLiteral"),
                    optional: true
                },
                exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
            })
        });
        defineType("ExportSpecifier", {
            visitor: [
                "local",
                "exported"
            ],
            aliases: [
                "ModuleSpecifier"
            ],
            fields: {
                local: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                },
                exported: {
                    validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
                },
                exportKind: {
                    validate: (0, _utils.assertOneOf)("type", "value"),
                    optional: true
                }
            }
        });
        defineType("ForOfStatement", {
            visitor: [
                "left",
                "right",
                "body"
            ],
            builder: [
                "left",
                "right",
                "body",
                "await"
            ],
            aliases: [
                "Scopable",
                "Statement",
                "For",
                "BlockParent",
                "Loop",
                "ForXStatement"
            ],
            fields: {
                left: {
                    validate: function() {
                        if (!process.env.BABEL_TYPES_8_BREAKING) {
                            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
                        }
                        var declaration = (0, _utils.assertNodeType)("VariableDeclaration");
                        var lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
                        return Object.assign(function(node, key2, val) {
                            if ((0, _is.default)("VariableDeclaration", val)) {
                                declaration(node, key2, val);
                            } else {
                                lval(node, key2, val);
                            }
                        }, {
                            oneOfNodeTypes: [
                                "VariableDeclaration",
                                "Identifier",
                                "MemberExpression",
                                "ArrayPattern",
                                "ObjectPattern",
                                "TSAsExpression",
                                "TSSatisfiesExpression",
                                "TSTypeAssertion",
                                "TSNonNullExpression"
                            ]
                        });
                    }()
                },
                right: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("Statement")
                },
                await: {
                    default: false
                }
            }
        });
        defineType("ImportDeclaration", {
            builder: [
                "specifiers",
                "source"
            ],
            visitor: [
                "specifiers",
                "source",
                "attributes",
                "assertions"
            ],
            aliases: [
                "Statement",
                "Declaration",
                "ImportOrExportDeclaration"
            ],
            fields: Object.assign({}, importAttributes, {
                module: {
                    optional: true,
                    validate: (0, _utils.assertValueType)("boolean")
                },
                phase: {
                    default: null,
                    validate: (0, _utils.assertOneOf)("source", "defer")
                },
                specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
                source: {
                    validate: (0, _utils.assertNodeType)("StringLiteral")
                },
                importKind: {
                    validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
                    optional: true
                }
            })
        });
        defineType("ImportDefaultSpecifier", {
            visitor: [
                "local"
            ],
            aliases: [
                "ModuleSpecifier"
            ],
            fields: {
                local: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                }
            }
        });
        defineType("ImportNamespaceSpecifier", {
            visitor: [
                "local"
            ],
            aliases: [
                "ModuleSpecifier"
            ],
            fields: {
                local: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                }
            }
        });
        defineType("ImportSpecifier", {
            visitor: [
                "imported",
                "local"
            ],
            builder: [
                "local",
                "imported"
            ],
            aliases: [
                "ModuleSpecifier"
            ],
            fields: {
                local: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                },
                imported: {
                    validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
                },
                importKind: {
                    validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
                    optional: true
                }
            }
        });
        defineType("ImportExpression", {
            visitor: [
                "source",
                "options"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                phase: {
                    default: null,
                    validate: (0, _utils.assertOneOf)("source", "defer")
                },
                source: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                options: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                }
            }
        });
        defineType("MetaProperty", {
            visitor: [
                "meta",
                "property"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                meta: {
                    validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key2, val) {
                        var property;
                        switch(val.name){
                            case "function":
                                property = "sent";
                                break;
                            case "new":
                                property = "target";
                                break;
                            case "import":
                                property = "meta";
                                break;
                        }
                        if (!(0, _is.default)("Identifier", node.property, {
                            name: property
                        })) {
                            throw new TypeError("Unrecognised MetaProperty");
                        }
                    }, {
                        oneOfNodeTypes: [
                            "Identifier"
                        ]
                    })) : (0, _utils.assertNodeType)("Identifier")
                },
                property: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                }
            }
        });
        var classMethodOrPropertyCommon = function() {
            return {
                abstract: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                accessibility: {
                    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
                    optional: true
                },
                static: {
                    default: false
                },
                override: {
                    default: false
                },
                computed: {
                    default: false
                },
                optional: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                key: {
                    validate: (0, _utils.chain)(function() {
                        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
                        var computed = (0, _utils.assertNodeType)("Expression");
                        return function(node, key2, val) {
                            var validator = node.computed ? computed : normal;
                            validator(node, key2, val);
                        };
                    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
                }
            };
        };
        exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
        var classMethodOrDeclareMethodCommon = function() {
            return Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
                params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
                kind: {
                    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
                    default: "method"
                },
                access: {
                    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                }
            });
        };
        exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
        defineType("ClassMethod", {
            aliases: [
                "Function",
                "Scopable",
                "BlockParent",
                "FunctionParent",
                "Method"
            ],
            builder: [
                "kind",
                "key",
                "params",
                "body",
                "computed",
                "static",
                "generator",
                "async"
            ],
            visitor: [
                "decorators",
                "key",
                "typeParameters",
                "params",
                "returnType",
                "body"
            ],
            fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                }
            })
        });
        defineType("ObjectPattern", {
            visitor: [
                "properties",
                "typeAnnotation",
                "decorators"
            ],
            builder: [
                "properties"
            ],
            aliases: [
                "Pattern",
                "PatternLike",
                "LVal"
            ],
            fields: Object.assign({}, patternLikeCommon(), {
                properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
            })
        });
        defineType("SpreadElement", {
            visitor: [
                "argument"
            ],
            aliases: [
                "UnaryLike"
            ],
            deprecatedAlias: "SpreadProperty",
            fields: {
                argument: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("Super", {
            aliases: [
                "Expression"
            ]
        });
        defineType("TaggedTemplateExpression", {
            visitor: [
                "tag",
                "typeParameters",
                "quasi"
            ],
            builder: [
                "tag",
                "quasi"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                tag: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                quasi: {
                    validate: (0, _utils.assertNodeType)("TemplateLiteral")
                },
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                    optional: true
                }
            }
        });
        defineType("TemplateElement", {
            builder: [
                "value",
                "tail"
            ],
            fields: {
                value: {
                    validate: (0, _utils.chain)((0, _utils.assertShape)({
                        raw: {
                            validate: (0, _utils.assertValueType)("string")
                        },
                        cooked: {
                            validate: (0, _utils.assertValueType)("string"),
                            optional: true
                        }
                    }), function templateElementCookedValidator(node) {
                        var raw = node.value.raw;
                        var unterminatedCalled = false;
                        var error = function() {
                            throw new Error("Internal @babel/types error.");
                        };
                        var _ref = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
                            unterminated: function unterminated() {
                                unterminatedCalled = true;
                            },
                            strictNumericEscape: error,
                            invalidEscapeSequence: error,
                            numericSeparatorInEscapeSequence: error,
                            unexpectedNumericSeparator: error,
                            invalidDigit: error,
                            invalidCodePoint: error
                        }), str = _ref.str, firstInvalidLoc = _ref.firstInvalidLoc;
                        if (!unterminatedCalled) throw new Error("Invalid raw");
                        node.value.cooked = firstInvalidLoc ? null : str;
                    })
                },
                tail: {
                    default: false
                }
            }
        });
        defineType("TemplateLiteral", {
            visitor: [
                "quasis",
                "expressions"
            ],
            aliases: [
                "Expression",
                "Literal"
            ],
            fields: {
                quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
                expressions: {
                    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key2, val) {
                        if (node.quasis.length !== val.length + 1) {
                            throw new TypeError("Number of ".concat(node.type, " quasis should be exactly one more than the number of expressions.\nExpected ").concat(val.length + 1, " quasis but got ").concat(node.quasis.length));
                        }
                    })
                }
            }
        });
        defineType("YieldExpression", {
            builder: [
                "argument",
                "delegate"
            ],
            visitor: [
                "argument"
            ],
            aliases: [
                "Expression",
                "Terminatorless"
            ],
            fields: {
                delegate: {
                    validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key2, val) {
                        if (val && !node.argument) {
                            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
                        }
                    }, {
                        type: "boolean"
                    })) : (0, _utils.assertValueType)("boolean"),
                    default: false
                },
                argument: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("AwaitExpression", {
            builder: [
                "argument"
            ],
            visitor: [
                "argument"
            ],
            aliases: [
                "Expression",
                "Terminatorless"
            ],
            fields: {
                argument: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("Import", {
            aliases: [
                "Expression"
            ]
        });
        defineType("BigIntLiteral", {
            builder: [
                "value"
            ],
            fields: {
                value: {
                    validate: (0, _utils.assertValueType)("string")
                }
            },
            aliases: [
                "Expression",
                "Pureish",
                "Literal",
                "Immutable"
            ]
        });
        defineType("ExportNamespaceSpecifier", {
            visitor: [
                "exported"
            ],
            aliases: [
                "ModuleSpecifier"
            ],
            fields: {
                exported: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                }
            }
        });
        defineType("OptionalMemberExpression", {
            builder: [
                "object",
                "property",
                "computed",
                "optional"
            ],
            visitor: [
                "object",
                "property"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                object: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                property: {
                    validate: function() {
                        var normal = (0, _utils.assertNodeType)("Identifier");
                        var computed = (0, _utils.assertNodeType)("Expression");
                        var validator = Object.assign(function(node, key2, val) {
                            var validator2 = node.computed ? computed : normal;
                            validator2(node, key2, val);
                        }, {
                            oneOfNodeTypes: [
                                "Expression",
                                "Identifier"
                            ]
                        });
                        return validator;
                    }()
                },
                computed: {
                    default: false
                },
                optional: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
                }
            }
        });
        defineType("OptionalCallExpression", {
            visitor: [
                "callee",
                "arguments",
                "typeParameters",
                "typeArguments"
            ],
            builder: [
                "callee",
                "arguments",
                "optional"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                callee: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
                optional: {
                    validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
                },
                typeArguments: {
                    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
                    optional: true
                },
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
                    optional: true
                }
            }
        });
        defineType("ClassProperty", {
            visitor: [
                "decorators",
                "key",
                "typeAnnotation",
                "value"
            ],
            builder: [
                "key",
                "value",
                "typeAnnotation",
                "decorators",
                "computed",
                "static"
            ],
            aliases: [
                "Property"
            ],
            fields: Object.assign({}, classMethodOrPropertyCommon(), {
                value: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                },
                definite: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                typeAnnotation: {
                    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                },
                readonly: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                declare: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                variance: {
                    validate: (0, _utils.assertNodeType)("Variance"),
                    optional: true
                }
            })
        });
        defineType("ClassAccessorProperty", {
            visitor: [
                "decorators",
                "key",
                "typeAnnotation",
                "value"
            ],
            builder: [
                "key",
                "value",
                "typeAnnotation",
                "decorators",
                "computed",
                "static"
            ],
            aliases: [
                "Property",
                "Accessor"
            ],
            fields: Object.assign({}, classMethodOrPropertyCommon(), {
                key: {
                    validate: (0, _utils.chain)(function() {
                        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
                        var computed = (0, _utils.assertNodeType)("Expression");
                        return function(node, key2, val) {
                            var validator = node.computed ? computed : normal;
                            validator(node, key2, val);
                        };
                    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
                },
                value: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                },
                definite: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                typeAnnotation: {
                    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                },
                readonly: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                declare: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                variance: {
                    validate: (0, _utils.assertNodeType)("Variance"),
                    optional: true
                }
            })
        });
        defineType("ClassPrivateProperty", {
            visitor: [
                "decorators",
                "key",
                "typeAnnotation",
                "value"
            ],
            builder: [
                "key",
                "value",
                "decorators",
                "static"
            ],
            aliases: [
                "Property",
                "Private"
            ],
            fields: {
                key: {
                    validate: (0, _utils.assertNodeType)("PrivateName")
                },
                value: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                },
                typeAnnotation: {
                    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                },
                static: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    default: false
                },
                readonly: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                definite: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                variance: {
                    validate: (0, _utils.assertNodeType)("Variance"),
                    optional: true
                }
            }
        });
        defineType("ClassPrivateMethod", {
            builder: [
                "kind",
                "key",
                "params",
                "body",
                "static"
            ],
            visitor: [
                "decorators",
                "key",
                "typeParameters",
                "params",
                "returnType",
                "body"
            ],
            aliases: [
                "Function",
                "Scopable",
                "BlockParent",
                "FunctionParent",
                "Method",
                "Private"
            ],
            fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
                kind: {
                    validate: (0, _utils.assertOneOf)("get", "set", "method"),
                    default: "method"
                },
                key: {
                    validate: (0, _utils.assertNodeType)("PrivateName")
                },
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                }
            })
        });
        defineType("PrivateName", {
            visitor: [
                "id"
            ],
            aliases: [
                "Private"
            ],
            fields: {
                id: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                }
            }
        });
        defineType("StaticBlock", {
            visitor: [
                "body"
            ],
            fields: {
                body: (0, _utils.validateArrayOfType)("Statement")
            },
            aliases: [
                "Scopable",
                "BlockParent",
                "FunctionParent"
            ]
        });
    }
});
// ../../node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/flow.js": function() {
        "use strict";
        var _core = require_core();
        var _utils = require_utils();
        var defineType = (0, _utils.defineAliasedType)("Flow");
        var defineInterfaceishType = function(name) {
            var isDeclareClass = name === "DeclareClass";
            defineType(name, {
                builder: [
                    "id",
                    "typeParameters",
                    "extends",
                    "body"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "extends"
                ].concat(_to_consumable_array(isDeclareClass ? [
                    "mixins",
                    "implements"
                ] : []), [
                    "body"
                ]),
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: Object.assign({
                    id: (0, _utils.validateType)("Identifier"),
                    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
                    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
                }, isDeclareClass ? {
                    mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
                    implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
                } : {}, {
                    body: (0, _utils.validateType)("ObjectTypeAnnotation")
                })
            });
        };
        defineType("AnyTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("ArrayTypeAnnotation", {
            visitor: [
                "elementType"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                elementType: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("BooleanTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("BooleanLiteralTypeAnnotation", {
            builder: [
                "value"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("NullLiteralTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("ClassImplements", {
            visitor: [
                "id",
                "typeParameters"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
            }
        });
        defineInterfaceishType("DeclareClass");
        defineType("DeclareFunction", {
            visitor: [
                "id"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
            }
        });
        defineInterfaceishType("DeclareInterface");
        defineType("DeclareModule", {
            builder: [
                "id",
                "body",
                "kind"
            ],
            visitor: [
                "id",
                "body"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier", "StringLiteral"),
                body: (0, _utils.validateType)("BlockStatement"),
                kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
            }
        });
        defineType("DeclareModuleExports", {
            visitor: [
                "typeAnnotation"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
            }
        });
        defineType("DeclareTypeAlias", {
            visitor: [
                "id",
                "typeParameters",
                "right"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
                right: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("DeclareOpaqueType", {
            visitor: [
                "id",
                "typeParameters",
                "supertype"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0, _utils.validateOptionalType)("FlowType"),
                impltype: (0, _utils.validateOptionalType)("FlowType")
            }
        });
        defineType("DeclareVariable", {
            visitor: [
                "id"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier")
            }
        });
        defineType("DeclareExportDeclaration", {
            visitor: [
                "declaration",
                "specifiers",
                "source",
                "attributes"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: Object.assign({
                declaration: (0, _utils.validateOptionalType)("Flow"),
                specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
                source: (0, _utils.validateOptionalType)("StringLiteral"),
                default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
            }, _core.importAttributes)
        });
        defineType("DeclareExportAllDeclaration", {
            visitor: [
                "source",
                "attributes"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: Object.assign({
                source: (0, _utils.validateType)("StringLiteral"),
                exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
            }, _core.importAttributes)
        });
        defineType("DeclaredPredicate", {
            visitor: [
                "value"
            ],
            aliases: [
                "FlowPredicate"
            ],
            fields: {
                value: (0, _utils.validateType)("Flow")
            }
        });
        defineType("ExistsTypeAnnotation", {
            aliases: [
                "FlowType"
            ]
        });
        defineType("FunctionTypeAnnotation", {
            visitor: [
                "typeParameters",
                "params",
                "rest",
                "returnType"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
                params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
                rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
                this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
                returnType: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("FunctionTypeParam", {
            visitor: [
                "name",
                "typeAnnotation"
            ],
            fields: {
                name: (0, _utils.validateOptionalType)("Identifier"),
                typeAnnotation: (0, _utils.validateType)("FlowType"),
                optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("GenericTypeAnnotation", {
            visitor: [
                "id",
                "typeParameters"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
            }
        });
        defineType("InferredPredicate", {
            aliases: [
                "FlowPredicate"
            ]
        });
        defineType("InterfaceExtends", {
            visitor: [
                "id",
                "typeParameters"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
            }
        });
        defineInterfaceishType("InterfaceDeclaration");
        defineType("InterfaceTypeAnnotation", {
            visitor: [
                "extends",
                "body"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
                body: (0, _utils.validateType)("ObjectTypeAnnotation")
            }
        });
        defineType("IntersectionTypeAnnotation", {
            visitor: [
                "types"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
            }
        });
        defineType("MixedTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("EmptyTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("NullableTypeAnnotation", {
            visitor: [
                "typeAnnotation"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                typeAnnotation: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("NumberLiteralTypeAnnotation", {
            builder: [
                "value"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
            }
        });
        defineType("NumberTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("ObjectTypeAnnotation", {
            visitor: [
                "properties",
                "indexers",
                "callProperties",
                "internalSlots"
            ],
            aliases: [
                "FlowType"
            ],
            builder: [
                "properties",
                "indexers",
                "callProperties",
                "internalSlots",
                "exact"
            ],
            fields: {
                properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
                indexers: {
                    validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
                    optional: true,
                    default: []
                },
                callProperties: {
                    validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
                    optional: true,
                    default: []
                },
                internalSlots: {
                    validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
                    optional: true,
                    default: []
                },
                exact: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    default: false
                },
                inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("ObjectTypeInternalSlot", {
            visitor: [
                "id",
                "value"
            ],
            builder: [
                "id",
                "value",
                "optional",
                "static",
                "method"
            ],
            aliases: [
                "UserWhitespacable"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                value: (0, _utils.validateType)("FlowType"),
                optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("ObjectTypeCallProperty", {
            visitor: [
                "value"
            ],
            aliases: [
                "UserWhitespacable"
            ],
            fields: {
                value: (0, _utils.validateType)("FlowType"),
                static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("ObjectTypeIndexer", {
            visitor: [
                "variance",
                "id",
                "key",
                "value"
            ],
            builder: [
                "id",
                "key",
                "value",
                "variance"
            ],
            aliases: [
                "UserWhitespacable"
            ],
            fields: {
                id: (0, _utils.validateOptionalType)("Identifier"),
                key: (0, _utils.validateType)("FlowType"),
                value: (0, _utils.validateType)("FlowType"),
                static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                variance: (0, _utils.validateOptionalType)("Variance")
            }
        });
        defineType("ObjectTypeProperty", {
            visitor: [
                "key",
                "value",
                "variance"
            ],
            aliases: [
                "UserWhitespacable"
            ],
            fields: {
                key: (0, _utils.validateType)("Identifier", "StringLiteral"),
                value: (0, _utils.validateType)("FlowType"),
                kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
                static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                variance: (0, _utils.validateOptionalType)("Variance"),
                method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("ObjectTypeSpreadProperty", {
            visitor: [
                "argument"
            ],
            aliases: [
                "UserWhitespacable"
            ],
            fields: {
                argument: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("OpaqueType", {
            visitor: [
                "id",
                "typeParameters",
                "supertype",
                "impltype"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0, _utils.validateOptionalType)("FlowType"),
                impltype: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("QualifiedTypeIdentifier", {
            visitor: [
                "qualification",
                "id"
            ],
            builder: [
                "id",
                "qualification"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
            }
        });
        defineType("StringLiteralTypeAnnotation", {
            builder: [
                "value"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
            }
        });
        defineType("StringTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("SymbolTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("ThisTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("TupleTypeAnnotation", {
            visitor: [
                "types"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
            }
        });
        defineType("TypeofTypeAnnotation", {
            visitor: [
                "argument"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                argument: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("TypeAlias", {
            visitor: [
                "id",
                "typeParameters",
                "right"
            ],
            aliases: [
                "FlowDeclaration",
                "Statement",
                "Declaration"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
                right: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("TypeAnnotation", {
            visitor: [
                "typeAnnotation"
            ],
            fields: {
                typeAnnotation: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("TypeCastExpression", {
            visitor: [
                "expression",
                "typeAnnotation"
            ],
            aliases: [
                "ExpressionWrapper",
                "Expression"
            ],
            fields: {
                expression: (0, _utils.validateType)("Expression"),
                typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
            }
        });
        defineType("TypeParameter", {
            visitor: [
                "bound",
                "default",
                "variance"
            ],
            fields: {
                name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
                bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
                default: (0, _utils.validateOptionalType)("FlowType"),
                variance: (0, _utils.validateOptionalType)("Variance")
            }
        });
        defineType("TypeParameterDeclaration", {
            visitor: [
                "params"
            ],
            fields: {
                params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
            }
        });
        defineType("TypeParameterInstantiation", {
            visitor: [
                "params"
            ],
            fields: {
                params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
            }
        });
        defineType("UnionTypeAnnotation", {
            visitor: [
                "types"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
            }
        });
        defineType("Variance", {
            builder: [
                "kind"
            ],
            fields: {
                kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
            }
        });
        defineType("VoidTypeAnnotation", {
            aliases: [
                "FlowType",
                "FlowBaseAnnotation"
            ]
        });
        defineType("EnumDeclaration", {
            aliases: [
                "Statement",
                "Declaration"
            ],
            visitor: [
                "id",
                "body"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
            }
        });
        defineType("EnumBooleanBody", {
            aliases: [
                "EnumBody"
            ],
            visitor: [
                "members"
            ],
            fields: {
                explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
                hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("EnumNumberBody", {
            aliases: [
                "EnumBody"
            ],
            visitor: [
                "members"
            ],
            fields: {
                explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
                hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("EnumStringBody", {
            aliases: [
                "EnumBody"
            ],
            visitor: [
                "members"
            ],
            fields: {
                explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
                members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
                hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("EnumSymbolBody", {
            aliases: [
                "EnumBody"
            ],
            visitor: [
                "members"
            ],
            fields: {
                members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
                hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
        defineType("EnumBooleanMember", {
            aliases: [
                "EnumMember"
            ],
            visitor: [
                "id"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                init: (0, _utils.validateType)("BooleanLiteral")
            }
        });
        defineType("EnumNumberMember", {
            aliases: [
                "EnumMember"
            ],
            visitor: [
                "id",
                "init"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                init: (0, _utils.validateType)("NumericLiteral")
            }
        });
        defineType("EnumStringMember", {
            aliases: [
                "EnumMember"
            ],
            visitor: [
                "id",
                "init"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier"),
                init: (0, _utils.validateType)("StringLiteral")
            }
        });
        defineType("EnumDefaultedMember", {
            aliases: [
                "EnumMember"
            ],
            visitor: [
                "id"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier")
            }
        });
        defineType("IndexedAccessType", {
            visitor: [
                "objectType",
                "indexType"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                objectType: (0, _utils.validateType)("FlowType"),
                indexType: (0, _utils.validateType)("FlowType")
            }
        });
        defineType("OptionalIndexedAccessType", {
            visitor: [
                "objectType",
                "indexType"
            ],
            aliases: [
                "FlowType"
            ],
            fields: {
                objectType: (0, _utils.validateType)("FlowType"),
                indexType: (0, _utils.validateType)("FlowType"),
                optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
            }
        });
    }
});
// ../../node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/jsx.js": function() {
        "use strict";
        var _utils = require_utils();
        var defineType = (0, _utils.defineAliasedType)("JSX");
        defineType("JSXAttribute", {
            visitor: [
                "name",
                "value"
            ],
            aliases: [
                "Immutable"
            ],
            fields: {
                name: {
                    validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
                },
                value: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
                }
            }
        });
        defineType("JSXClosingElement", {
            visitor: [
                "name"
            ],
            aliases: [
                "Immutable"
            ],
            fields: {
                name: {
                    validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                }
            }
        });
        defineType("JSXElement", {
            builder: [
                "openingElement",
                "closingElement",
                "children",
                "selfClosing"
            ],
            visitor: [
                "openingElement",
                "children",
                "closingElement"
            ],
            aliases: [
                "Immutable",
                "Expression"
            ],
            fields: Object.assign({
                openingElement: {
                    validate: (0, _utils.assertNodeType)("JSXOpeningElement")
                },
                closingElement: {
                    optional: true,
                    validate: (0, _utils.assertNodeType)("JSXClosingElement")
                },
                children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
            }, {
                selfClosing: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                }
            })
        });
        defineType("JSXEmptyExpression", {});
        defineType("JSXExpressionContainer", {
            visitor: [
                "expression"
            ],
            aliases: [
                "Immutable"
            ],
            fields: {
                expression: {
                    validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
                }
            }
        });
        defineType("JSXSpreadChild", {
            visitor: [
                "expression"
            ],
            aliases: [
                "Immutable"
            ],
            fields: {
                expression: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("JSXIdentifier", {
            builder: [
                "name"
            ],
            fields: {
                name: {
                    validate: (0, _utils.assertValueType)("string")
                }
            }
        });
        defineType("JSXMemberExpression", {
            visitor: [
                "object",
                "property"
            ],
            fields: {
                object: {
                    validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
                },
                property: {
                    validate: (0, _utils.assertNodeType)("JSXIdentifier")
                }
            }
        });
        defineType("JSXNamespacedName", {
            visitor: [
                "namespace",
                "name"
            ],
            fields: {
                namespace: {
                    validate: (0, _utils.assertNodeType)("JSXIdentifier")
                },
                name: {
                    validate: (0, _utils.assertNodeType)("JSXIdentifier")
                }
            }
        });
        defineType("JSXOpeningElement", {
            builder: [
                "name",
                "attributes",
                "selfClosing"
            ],
            visitor: [
                "name",
                "attributes"
            ],
            aliases: [
                "Immutable"
            ],
            fields: {
                name: {
                    validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                },
                selfClosing: {
                    default: false
                },
                attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                    optional: true
                }
            }
        });
        defineType("JSXSpreadAttribute", {
            visitor: [
                "argument"
            ],
            fields: {
                argument: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        defineType("JSXText", {
            aliases: [
                "Immutable"
            ],
            builder: [
                "value"
            ],
            fields: {
                value: {
                    validate: (0, _utils.assertValueType)("string")
                }
            }
        });
        defineType("JSXFragment", {
            builder: [
                "openingFragment",
                "closingFragment",
                "children"
            ],
            visitor: [
                "openingFragment",
                "children",
                "closingFragment"
            ],
            aliases: [
                "Immutable",
                "Expression"
            ],
            fields: {
                openingFragment: {
                    validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
                },
                closingFragment: {
                    validate: (0, _utils.assertNodeType)("JSXClosingFragment")
                },
                children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
            }
        });
        defineType("JSXOpeningFragment", {
            aliases: [
                "Immutable"
            ]
        });
        defineType("JSXClosingFragment", {
            aliases: [
                "Immutable"
            ]
        });
    }
});
// ../../node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/placeholders.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
        var _utils = require_utils();
        var PLACEHOLDERS = exports.PLACEHOLDERS = [
            "Identifier",
            "StringLiteral",
            "Expression",
            "Statement",
            "Declaration",
            "BlockStatement",
            "ClassBody",
            "Pattern"
        ];
        var PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {
            Declaration: [
                "Statement"
            ],
            Pattern: [
                "PatternLike",
                "LVal"
            ]
        };
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = PLACEHOLDERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                type = _step.value;
                alias = _utils.ALIAS_KEYS[type];
                if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var alias;
        var type;
        var PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};
        Object.keys(PLACEHOLDERS_ALIAS).forEach(function(type2) {
            PLACEHOLDERS_ALIAS[type2].forEach(function(alias2) {
                if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias2)) {
                    PLACEHOLDERS_FLIPPED_ALIAS[alias2] = [];
                }
                PLACEHOLDERS_FLIPPED_ALIAS[alias2].push(type2);
            });
        });
    }
});
// ../../node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/misc.js": function() {
        "use strict";
        var _utils = require_utils();
        var _placeholders = require_placeholders();
        var _core = require_core();
        var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
        {
            defineType("Noop", {
                visitor: []
            });
        }
        defineType("Placeholder", {
            visitor: [],
            builder: [
                "expectedNode",
                "name"
            ],
            fields: Object.assign({
                name: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                },
                expectedNode: {
                    validate: (0, _utils.assertOneOf).apply(this, _to_consumable_array(_placeholders.PLACEHOLDERS))
                }
            }, (0, _core.patternLikeCommon)())
        });
        defineType("V8IntrinsicIdentifier", {
            builder: [
                "name"
            ],
            fields: {
                name: {
                    validate: (0, _utils.assertValueType)("string")
                }
            }
        });
    }
});
// ../../node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/experimental.js": function() {
        "use strict";
        var _utils = require_utils();
        (0, _utils.default)("ArgumentPlaceholder", {});
        (0, _utils.default)("BindExpression", {
            visitor: [
                "object",
                "callee"
            ],
            aliases: [
                "Expression"
            ],
            fields: !process.env.BABEL_TYPES_8_BREAKING ? {
                object: {
                    validate: Object.assign(function() {}, {
                        oneOfNodeTypes: [
                            "Expression"
                        ]
                    })
                },
                callee: {
                    validate: Object.assign(function() {}, {
                        oneOfNodeTypes: [
                            "Expression"
                        ]
                    })
                }
            } : {
                object: {
                    validate: (0, _utils.assertNodeType)("Expression")
                },
                callee: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        (0, _utils.default)("ImportAttribute", {
            visitor: [
                "key",
                "value"
            ],
            fields: {
                key: {
                    validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
                },
                value: {
                    validate: (0, _utils.assertNodeType)("StringLiteral")
                }
            }
        });
        (0, _utils.default)("Decorator", {
            visitor: [
                "expression"
            ],
            fields: {
                expression: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            }
        });
        (0, _utils.default)("DoExpression", {
            visitor: [
                "body"
            ],
            builder: [
                "body",
                "async"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                body: {
                    validate: (0, _utils.assertNodeType)("BlockStatement")
                },
                async: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    default: false
                }
            }
        });
        (0, _utils.default)("ExportDefaultSpecifier", {
            visitor: [
                "exported"
            ],
            aliases: [
                "ModuleSpecifier"
            ],
            fields: {
                exported: {
                    validate: (0, _utils.assertNodeType)("Identifier")
                }
            }
        });
        (0, _utils.default)("RecordExpression", {
            visitor: [
                "properties"
            ],
            aliases: [
                "Expression"
            ],
            fields: {
                properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
            }
        });
        (0, _utils.default)("TupleExpression", {
            fields: {
                elements: {
                    validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
                    default: []
                }
            },
            visitor: [
                "elements"
            ],
            aliases: [
                "Expression"
            ]
        });
        {
            (0, _utils.default)("DecimalLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, _utils.assertValueType)("string")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
        }
        (0, _utils.default)("ModuleExpression", {
            visitor: [
                "body"
            ],
            fields: {
                body: {
                    validate: (0, _utils.assertNodeType)("Program")
                }
            },
            aliases: [
                "Expression"
            ]
        });
        (0, _utils.default)("TopicReference", {
            aliases: [
                "Expression"
            ]
        });
        (0, _utils.default)("PipelineTopicExpression", {
            builder: [
                "expression"
            ],
            visitor: [
                "expression"
            ],
            fields: {
                expression: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            },
            aliases: [
                "Expression"
            ]
        });
        (0, _utils.default)("PipelineBareFunction", {
            builder: [
                "callee"
            ],
            visitor: [
                "callee"
            ],
            fields: {
                callee: {
                    validate: (0, _utils.assertNodeType)("Expression")
                }
            },
            aliases: [
                "Expression"
            ]
        });
        (0, _utils.default)("PipelinePrimaryTopicReference", {
            aliases: [
                "Expression"
            ]
        });
    }
});
// ../../node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/typescript.js": function() {
        "use strict";
        var _utils = require_utils();
        var _core = require_core();
        var _is = require_is();
        var defineType = (0, _utils.defineAliasedType)("TypeScript");
        var bool = (0, _utils.assertValueType)("boolean");
        var tSFunctionTypeAnnotationCommon = function() {
            return {
                returnType: {
                    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
                    optional: true
                },
                typeParameters: {
                    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
                    optional: true
                }
            };
        };
        defineType("TSParameterProperty", {
            aliases: [
                "LVal"
            ],
            visitor: [
                "parameter"
            ],
            fields: {
                accessibility: {
                    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
                    optional: true
                },
                readonly: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                parameter: {
                    validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
                },
                override: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                decorators: {
                    validate: (0, _utils.arrayOfType)("Decorator"),
                    optional: true
                }
            }
        });
        defineType("TSDeclareFunction", {
            aliases: [
                "Statement",
                "Declaration"
            ],
            visitor: [
                "id",
                "typeParameters",
                "params",
                "returnType"
            ],
            fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
        });
        defineType("TSDeclareMethod", {
            visitor: [
                "decorators",
                "key",
                "typeParameters",
                "params",
                "returnType"
            ],
            fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
        });
        defineType("TSQualifiedName", {
            aliases: [
                "TSEntityName"
            ],
            visitor: [
                "left",
                "right"
            ],
            fields: {
                left: (0, _utils.validateType)("TSEntityName"),
                right: (0, _utils.validateType)("Identifier")
            }
        });
        var signatureDeclarationCommon = function() {
            var _obj;
            return _obj = {
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration")
            }, _define_property(_obj, "parameters", (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement")), _define_property(_obj, "typeAnnotation", (0, _utils.validateOptionalType)("TSTypeAnnotation")), _obj;
        };
        var callConstructSignatureDeclaration = {
            aliases: [
                "TSTypeElement"
            ],
            visitor: [
                "typeParameters",
                "parameters",
                "typeAnnotation"
            ],
            fields: signatureDeclarationCommon()
        };
        defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
        defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
        var namedTypeElementCommon = function() {
            return {
                key: (0, _utils.validateType)("Expression"),
                computed: {
                    default: false
                },
                optional: (0, _utils.validateOptional)(bool)
            };
        };
        defineType("TSPropertySignature", {
            aliases: [
                "TSTypeElement"
            ],
            visitor: [
                "key",
                "typeAnnotation"
            ],
            fields: Object.assign({}, namedTypeElementCommon(), {
                readonly: (0, _utils.validateOptional)(bool),
                typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
                kind: {
                    validate: (0, _utils.assertOneOf)("get", "set")
                }
            })
        });
        defineType("TSMethodSignature", {
            aliases: [
                "TSTypeElement"
            ],
            visitor: [
                "key",
                "typeParameters",
                "parameters",
                "typeAnnotation"
            ],
            fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
                kind: {
                    validate: (0, _utils.assertOneOf)("method", "get", "set")
                }
            })
        });
        defineType("TSIndexSignature", {
            aliases: [
                "TSTypeElement"
            ],
            visitor: [
                "parameters",
                "typeAnnotation"
            ],
            fields: {
                readonly: (0, _utils.validateOptional)(bool),
                static: (0, _utils.validateOptional)(bool),
                parameters: (0, _utils.validateArrayOfType)("Identifier"),
                typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
            }
        });
        var tsKeywordTypes = [
            "TSAnyKeyword",
            "TSBooleanKeyword",
            "TSBigIntKeyword",
            "TSIntrinsicKeyword",
            "TSNeverKeyword",
            "TSNullKeyword",
            "TSNumberKeyword",
            "TSObjectKeyword",
            "TSStringKeyword",
            "TSSymbolKeyword",
            "TSUndefinedKeyword",
            "TSUnknownKeyword",
            "TSVoidKeyword"
        ];
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = tsKeywordTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                type = _step.value;
                defineType(type, {
                    aliases: [
                        "TSType",
                        "TSBaseType"
                    ],
                    visitor: [],
                    fields: {}
                });
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var type;
        defineType("TSThisType", {
            aliases: [
                "TSType",
                "TSBaseType"
            ],
            visitor: [],
            fields: {}
        });
        var fnOrCtrBase = {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeParameters",
                "parameters",
                "typeAnnotation"
            ]
        };
        defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
            fields: signatureDeclarationCommon()
        }));
        defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
            fields: Object.assign({}, signatureDeclarationCommon(), {
                abstract: (0, _utils.validateOptional)(bool)
            })
        }));
        defineType("TSTypeReference", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeName",
                "typeParameters"
            ],
            fields: {
                typeName: (0, _utils.validateType)("TSEntityName"),
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
            }
        });
        defineType("TSTypePredicate", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "parameterName",
                "typeAnnotation"
            ],
            builder: [
                "parameterName",
                "typeAnnotation",
                "asserts"
            ],
            fields: {
                parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
                typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
                asserts: (0, _utils.validateOptional)(bool)
            }
        });
        defineType("TSTypeQuery", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "exprName",
                "typeParameters"
            ],
            fields: {
                exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
            }
        });
        defineType("TSTypeLiteral", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "members"
            ],
            fields: {
                members: (0, _utils.validateArrayOfType)("TSTypeElement")
            }
        });
        defineType("TSArrayType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "elementType"
            ],
            fields: {
                elementType: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSTupleType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "elementTypes"
            ],
            fields: {
                elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
            }
        });
        defineType("TSOptionalType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeAnnotation"
            ],
            fields: {
                typeAnnotation: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSRestType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeAnnotation"
            ],
            fields: {
                typeAnnotation: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSNamedTupleMember", {
            visitor: [
                "label",
                "elementType"
            ],
            builder: [
                "label",
                "elementType",
                "optional"
            ],
            fields: {
                label: (0, _utils.validateType)("Identifier"),
                optional: {
                    validate: bool,
                    default: false
                },
                elementType: (0, _utils.validateType)("TSType")
            }
        });
        var unionOrIntersection = {
            aliases: [
                "TSType"
            ],
            visitor: [
                "types"
            ],
            fields: {
                types: (0, _utils.validateArrayOfType)("TSType")
            }
        };
        defineType("TSUnionType", unionOrIntersection);
        defineType("TSIntersectionType", unionOrIntersection);
        defineType("TSConditionalType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "checkType",
                "extendsType",
                "trueType",
                "falseType"
            ],
            fields: {
                checkType: (0, _utils.validateType)("TSType"),
                extendsType: (0, _utils.validateType)("TSType"),
                trueType: (0, _utils.validateType)("TSType"),
                falseType: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSInferType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeParameter"
            ],
            fields: {
                typeParameter: (0, _utils.validateType)("TSTypeParameter")
            }
        });
        defineType("TSParenthesizedType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeAnnotation"
            ],
            fields: {
                typeAnnotation: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSTypeOperator", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeAnnotation"
            ],
            fields: {
                operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
                typeAnnotation: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSIndexedAccessType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "objectType",
                "indexType"
            ],
            fields: {
                objectType: (0, _utils.validateType)("TSType"),
                indexType: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSMappedType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "typeParameter",
                "nameType",
                "typeAnnotation"
            ],
            builder: [
                "typeParameter",
                "typeAnnotation",
                "nameType"
            ],
            fields: Object.assign({}, {
                typeParameter: (0, _utils.validateType)("TSTypeParameter")
            }, {
                readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
                optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
                typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
                nameType: (0, _utils.validateOptionalType)("TSType")
            })
        });
        defineType("TSLiteralType", {
            aliases: [
                "TSType",
                "TSBaseType"
            ],
            visitor: [
                "literal"
            ],
            fields: {
                literal: {
                    validate: function() {
                        var unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
                        var unaryOperator = (0, _utils.assertOneOf)("-");
                        var literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
                        function validator(parent, key2, node) {
                            if ((0, _is.default)("UnaryExpression", node)) {
                                unaryOperator(node, "operator", node.operator);
                                unaryExpression(node, "argument", node.argument);
                            } else {
                                literal(parent, key2, node);
                            }
                        }
                        validator.oneOfNodeTypes = [
                            "NumericLiteral",
                            "StringLiteral",
                            "BooleanLiteral",
                            "BigIntLiteral",
                            "TemplateLiteral",
                            "UnaryExpression"
                        ];
                        return validator;
                    }()
                }
            }
        });
        var expressionWithTypeArguments = {
            aliases: [
                "TSType"
            ],
            visitor: [
                "expression",
                "typeParameters"
            ],
            fields: {
                expression: (0, _utils.validateType)("TSEntityName"),
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
            }
        };
        {
            defineType("TSExpressionWithTypeArguments", expressionWithTypeArguments);
        }
        defineType("TSInterfaceDeclaration", {
            aliases: [
                "Statement",
                "Declaration"
            ],
            visitor: [
                "id",
                "typeParameters",
                "extends",
                "body"
            ],
            fields: {
                declare: (0, _utils.validateOptional)(bool),
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
                extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
                body: (0, _utils.validateType)("TSInterfaceBody")
            }
        });
        defineType("TSInterfaceBody", {
            visitor: [
                "body"
            ],
            fields: {
                body: (0, _utils.validateArrayOfType)("TSTypeElement")
            }
        });
        defineType("TSTypeAliasDeclaration", {
            aliases: [
                "Statement",
                "Declaration"
            ],
            visitor: [
                "id",
                "typeParameters",
                "typeAnnotation"
            ],
            fields: {
                declare: (0, _utils.validateOptional)(bool),
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
                typeAnnotation: (0, _utils.validateType)("TSType")
            }
        });
        defineType("TSInstantiationExpression", {
            aliases: [
                "Expression"
            ],
            visitor: [
                "expression",
                "typeParameters"
            ],
            fields: {
                expression: (0, _utils.validateType)("Expression"),
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
            }
        });
        var TSTypeExpression = {
            aliases: [
                "Expression",
                "LVal",
                "PatternLike"
            ],
            visitor: [
                "expression",
                "typeAnnotation"
            ],
            fields: {
                expression: (0, _utils.validateType)("Expression"),
                typeAnnotation: (0, _utils.validateType)("TSType")
            }
        };
        defineType("TSAsExpression", TSTypeExpression);
        defineType("TSSatisfiesExpression", TSTypeExpression);
        defineType("TSTypeAssertion", {
            aliases: [
                "Expression",
                "LVal",
                "PatternLike"
            ],
            visitor: [
                "typeAnnotation",
                "expression"
            ],
            fields: {
                typeAnnotation: (0, _utils.validateType)("TSType"),
                expression: (0, _utils.validateType)("Expression")
            }
        });
        defineType("TSEnumDeclaration", {
            aliases: [
                "Statement",
                "Declaration"
            ],
            visitor: [
                "id",
                "members"
            ],
            fields: {
                declare: (0, _utils.validateOptional)(bool),
                const: (0, _utils.validateOptional)(bool),
                id: (0, _utils.validateType)("Identifier"),
                members: (0, _utils.validateArrayOfType)("TSEnumMember"),
                initializer: (0, _utils.validateOptionalType)("Expression")
            }
        });
        defineType("TSEnumMember", {
            visitor: [
                "id",
                "initializer"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier", "StringLiteral"),
                initializer: (0, _utils.validateOptionalType)("Expression")
            }
        });
        defineType("TSModuleDeclaration", {
            aliases: [
                "Statement",
                "Declaration"
            ],
            visitor: [
                "id",
                "body"
            ],
            fields: Object.assign({
                kind: {
                    validate: (0, _utils.assertOneOf)("global", "module", "namespace")
                },
                declare: (0, _utils.validateOptional)(bool)
            }, {
                global: (0, _utils.validateOptional)(bool)
            }, {
                id: (0, _utils.validateType)("Identifier", "StringLiteral"),
                body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
            })
        });
        defineType("TSModuleBlock", {
            aliases: [
                "Scopable",
                "Block",
                "BlockParent",
                "FunctionParent"
            ],
            visitor: [
                "body"
            ],
            fields: {
                body: (0, _utils.validateArrayOfType)("Statement")
            }
        });
        defineType("TSImportType", {
            aliases: [
                "TSType"
            ],
            visitor: [
                "argument",
                "qualifier",
                "typeParameters"
            ],
            fields: {
                argument: (0, _utils.validateType)("StringLiteral"),
                qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
                typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
                options: {
                    validate: (0, _utils.assertNodeType)("Expression"),
                    optional: true
                }
            }
        });
        defineType("TSImportEqualsDeclaration", {
            aliases: [
                "Statement"
            ],
            visitor: [
                "id",
                "moduleReference"
            ],
            fields: {
                isExport: (0, _utils.validate)(bool),
                id: (0, _utils.validateType)("Identifier"),
                moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
                importKind: {
                    validate: (0, _utils.assertOneOf)("type", "value"),
                    optional: true
                }
            }
        });
        defineType("TSExternalModuleReference", {
            visitor: [
                "expression"
            ],
            fields: {
                expression: (0, _utils.validateType)("StringLiteral")
            }
        });
        defineType("TSNonNullExpression", {
            aliases: [
                "Expression",
                "LVal",
                "PatternLike"
            ],
            visitor: [
                "expression"
            ],
            fields: {
                expression: (0, _utils.validateType)("Expression")
            }
        });
        defineType("TSExportAssignment", {
            aliases: [
                "Statement"
            ],
            visitor: [
                "expression"
            ],
            fields: {
                expression: (0, _utils.validateType)("Expression")
            }
        });
        defineType("TSNamespaceExportDeclaration", {
            aliases: [
                "Statement"
            ],
            visitor: [
                "id"
            ],
            fields: {
                id: (0, _utils.validateType)("Identifier")
            }
        });
        defineType("TSTypeAnnotation", {
            visitor: [
                "typeAnnotation"
            ],
            fields: {
                typeAnnotation: {
                    validate: (0, _utils.assertNodeType)("TSType")
                }
            }
        });
        defineType("TSTypeParameterInstantiation", {
            visitor: [
                "params"
            ],
            fields: {
                params: (0, _utils.validateArrayOfType)("TSType")
            }
        });
        defineType("TSTypeParameterDeclaration", {
            visitor: [
                "params"
            ],
            fields: {
                params: (0, _utils.validateArrayOfType)("TSTypeParameter")
            }
        });
        defineType("TSTypeParameter", {
            builder: [
                "constraint",
                "default",
                "name"
            ],
            visitor: [
                "constraint",
                "default"
            ],
            fields: {
                name: {
                    validate: (0, _utils.assertValueType)("string")
                },
                in: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                out: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                const: {
                    validate: (0, _utils.assertValueType)("boolean"),
                    optional: true
                },
                constraint: {
                    validate: (0, _utils.assertNodeType)("TSType"),
                    optional: true
                },
                default: {
                    validate: (0, _utils.assertNodeType)("TSType"),
                    optional: true
                }
            }
        });
    }
});
// ../../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/deprecated-aliases.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.DEPRECATED_ALIASES = void 0;
        var DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {
            ModuleDeclaration: "ImportOrExportDeclaration"
        };
    }
});
// ../../node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
    "../../node_modules/@babel/types/lib/definitions/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        Object.defineProperty(exports, "ALIAS_KEYS", {
            enumerable: true,
            get: function get3() {
                return _utils.ALIAS_KEYS;
            }
        });
        Object.defineProperty(exports, "BUILDER_KEYS", {
            enumerable: true,
            get: function get3() {
                return _utils.BUILDER_KEYS;
            }
        });
        Object.defineProperty(exports, "DEPRECATED_ALIASES", {
            enumerable: true,
            get: function get3() {
                return _deprecatedAliases.DEPRECATED_ALIASES;
            }
        });
        Object.defineProperty(exports, "DEPRECATED_KEYS", {
            enumerable: true,
            get: function get3() {
                return _utils.DEPRECATED_KEYS;
            }
        });
        Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
            enumerable: true,
            get: function get3() {
                return _utils.FLIPPED_ALIAS_KEYS;
            }
        });
        Object.defineProperty(exports, "NODE_FIELDS", {
            enumerable: true,
            get: function get3() {
                return _utils.NODE_FIELDS;
            }
        });
        Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
            enumerable: true,
            get: function get3() {
                return _utils.NODE_PARENT_VALIDATIONS;
            }
        });
        Object.defineProperty(exports, "PLACEHOLDERS", {
            enumerable: true,
            get: function get3() {
                return _placeholders.PLACEHOLDERS;
            }
        });
        Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
            enumerable: true,
            get: function get3() {
                return _placeholders.PLACEHOLDERS_ALIAS;
            }
        });
        Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
            enumerable: true,
            get: function get3() {
                return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
            }
        });
        exports.TYPES = void 0;
        Object.defineProperty(exports, "VISITOR_KEYS", {
            enumerable: true,
            get: function get3() {
                return _utils.VISITOR_KEYS;
            }
        });
        require_core();
        require_flow();
        require_jsx();
        require_misc();
        require_experimental();
        require_typescript();
        var _utils = require_utils();
        var _placeholders = require_placeholders();
        var _deprecatedAliases = require_deprecated_aliases();
        Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(function(deprecatedAlias) {
            _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
        });
        var TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
    }
});
// ../../node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
    "../../node_modules/@babel/types/lib/validators/validate.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = validate;
        exports.validateChild = validateChild;
        exports.validateField = validateField;
        exports.validateInternal = validateInternal;
        var _index = require_definitions();
        function validate(node, key2, val) {
            if (!node) return;
            var fields = _index.NODE_FIELDS[node.type];
            if (!fields) return;
            var field = fields[key2];
            validateField(node, key2, val, field);
            validateChild(node, key2, val);
        }
        function validateInternal(field, node, key2, val, maybeNode) {
            if (!(field != null && field.validate)) return;
            if (field.optional && val == null) return;
            field.validate(node, key2, val);
            if (maybeNode) {
                var _NODE_PARENT_VALIDATI;
                var type = val.type;
                if (type == null) return;
                (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key2, val);
            }
        }
        function validateField(node, key2, val, field) {
            if (!(field != null && field.validate)) return;
            if (field.optional && val == null) return;
            field.validate(node, key2, val);
        }
        function validateChild(node, key2, val) {
            var _NODE_PARENT_VALIDATI2;
            var type = val == null ? void 0 : val.type;
            if (type == null) return;
            (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key2, val);
        }
    }
});
// ../../node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
    "../../node_modules/@babel/types/lib/builders/generated/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.anyTypeAnnotation = anyTypeAnnotation;
        exports.argumentPlaceholder = argumentPlaceholder;
        exports.arrayExpression = arrayExpression;
        exports.arrayPattern = arrayPattern;
        exports.arrayTypeAnnotation = arrayTypeAnnotation;
        exports.arrowFunctionExpression = arrowFunctionExpression;
        exports.assignmentExpression = assignmentExpression;
        exports.assignmentPattern = assignmentPattern;
        exports.awaitExpression = awaitExpression;
        exports.bigIntLiteral = bigIntLiteral;
        exports.binaryExpression = binaryExpression;
        exports.bindExpression = bindExpression;
        exports.blockStatement = blockStatement;
        exports.booleanLiteral = booleanLiteral;
        exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
        exports.booleanTypeAnnotation = booleanTypeAnnotation;
        exports.breakStatement = breakStatement;
        exports.callExpression = callExpression;
        exports.catchClause = catchClause;
        exports.classAccessorProperty = classAccessorProperty;
        exports.classBody = classBody;
        exports.classDeclaration = classDeclaration;
        exports.classExpression = classExpression;
        exports.classImplements = classImplements;
        exports.classMethod = classMethod;
        exports.classPrivateMethod = classPrivateMethod;
        exports.classPrivateProperty = classPrivateProperty;
        exports.classProperty = classProperty;
        exports.conditionalExpression = conditionalExpression;
        exports.continueStatement = continueStatement;
        exports.debuggerStatement = debuggerStatement;
        exports.decimalLiteral = decimalLiteral;
        exports.declareClass = declareClass;
        exports.declareExportAllDeclaration = declareExportAllDeclaration;
        exports.declareExportDeclaration = declareExportDeclaration;
        exports.declareFunction = declareFunction;
        exports.declareInterface = declareInterface;
        exports.declareModule = declareModule;
        exports.declareModuleExports = declareModuleExports;
        exports.declareOpaqueType = declareOpaqueType;
        exports.declareTypeAlias = declareTypeAlias;
        exports.declareVariable = declareVariable;
        exports.declaredPredicate = declaredPredicate;
        exports.decorator = decorator;
        exports.directive = directive;
        exports.directiveLiteral = directiveLiteral;
        exports.doExpression = doExpression;
        exports.doWhileStatement = doWhileStatement;
        exports.emptyStatement = emptyStatement;
        exports.emptyTypeAnnotation = emptyTypeAnnotation;
        exports.enumBooleanBody = enumBooleanBody;
        exports.enumBooleanMember = enumBooleanMember;
        exports.enumDeclaration = enumDeclaration;
        exports.enumDefaultedMember = enumDefaultedMember;
        exports.enumNumberBody = enumNumberBody;
        exports.enumNumberMember = enumNumberMember;
        exports.enumStringBody = enumStringBody;
        exports.enumStringMember = enumStringMember;
        exports.enumSymbolBody = enumSymbolBody;
        exports.existsTypeAnnotation = existsTypeAnnotation;
        exports.exportAllDeclaration = exportAllDeclaration;
        exports.exportDefaultDeclaration = exportDefaultDeclaration;
        exports.exportDefaultSpecifier = exportDefaultSpecifier;
        exports.exportNamedDeclaration = exportNamedDeclaration;
        exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
        exports.exportSpecifier = exportSpecifier;
        exports.expressionStatement = expressionStatement;
        exports.file = file;
        exports.forInStatement = forInStatement;
        exports.forOfStatement = forOfStatement;
        exports.forStatement = forStatement;
        exports.functionDeclaration = functionDeclaration;
        exports.functionExpression = functionExpression;
        exports.functionTypeAnnotation = functionTypeAnnotation;
        exports.functionTypeParam = functionTypeParam;
        exports.genericTypeAnnotation = genericTypeAnnotation;
        exports.identifier = identifier;
        exports.ifStatement = ifStatement;
        exports.import = _import;
        exports.importAttribute = importAttribute;
        exports.importDeclaration = importDeclaration;
        exports.importDefaultSpecifier = importDefaultSpecifier;
        exports.importExpression = importExpression;
        exports.importNamespaceSpecifier = importNamespaceSpecifier;
        exports.importSpecifier = importSpecifier;
        exports.indexedAccessType = indexedAccessType;
        exports.inferredPredicate = inferredPredicate;
        exports.interfaceDeclaration = interfaceDeclaration;
        exports.interfaceExtends = interfaceExtends;
        exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
        exports.interpreterDirective = interpreterDirective;
        exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
        exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
        exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
        exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
        exports.jSXElement = exports.jsxElement = jsxElement;
        exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
        exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
        exports.jSXFragment = exports.jsxFragment = jsxFragment;
        exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
        exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
        exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
        exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
        exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
        exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
        exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
        exports.jSXText = exports.jsxText = jsxText;
        exports.labeledStatement = labeledStatement;
        exports.logicalExpression = logicalExpression;
        exports.memberExpression = memberExpression;
        exports.metaProperty = metaProperty;
        exports.mixedTypeAnnotation = mixedTypeAnnotation;
        exports.moduleExpression = moduleExpression;
        exports.newExpression = newExpression;
        exports.noop = noop2;
        exports.nullLiteral = nullLiteral;
        exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
        exports.nullableTypeAnnotation = nullableTypeAnnotation;
        exports.numberLiteral = NumberLiteral;
        exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
        exports.numberTypeAnnotation = numberTypeAnnotation;
        exports.numericLiteral = numericLiteral;
        exports.objectExpression = objectExpression;
        exports.objectMethod = objectMethod;
        exports.objectPattern = objectPattern;
        exports.objectProperty = objectProperty;
        exports.objectTypeAnnotation = objectTypeAnnotation;
        exports.objectTypeCallProperty = objectTypeCallProperty;
        exports.objectTypeIndexer = objectTypeIndexer;
        exports.objectTypeInternalSlot = objectTypeInternalSlot;
        exports.objectTypeProperty = objectTypeProperty;
        exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
        exports.opaqueType = opaqueType;
        exports.optionalCallExpression = optionalCallExpression;
        exports.optionalIndexedAccessType = optionalIndexedAccessType;
        exports.optionalMemberExpression = optionalMemberExpression;
        exports.parenthesizedExpression = parenthesizedExpression;
        exports.pipelineBareFunction = pipelineBareFunction;
        exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
        exports.pipelineTopicExpression = pipelineTopicExpression;
        exports.placeholder = placeholder;
        exports.privateName = privateName;
        exports.program = program;
        exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
        exports.recordExpression = recordExpression;
        exports.regExpLiteral = regExpLiteral;
        exports.regexLiteral = RegexLiteral;
        exports.restElement = restElement;
        exports.restProperty = RestProperty;
        exports.returnStatement = returnStatement;
        exports.sequenceExpression = sequenceExpression;
        exports.spreadElement = spreadElement;
        exports.spreadProperty = SpreadProperty;
        exports.staticBlock = staticBlock;
        exports.stringLiteral = stringLiteral;
        exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
        exports.stringTypeAnnotation = stringTypeAnnotation;
        exports.super = _super;
        exports.switchCase = switchCase;
        exports.switchStatement = switchStatement;
        exports.symbolTypeAnnotation = symbolTypeAnnotation;
        exports.taggedTemplateExpression = taggedTemplateExpression;
        exports.templateElement = templateElement;
        exports.templateLiteral = templateLiteral;
        exports.thisExpression = thisExpression;
        exports.thisTypeAnnotation = thisTypeAnnotation;
        exports.throwStatement = throwStatement;
        exports.topicReference = topicReference;
        exports.tryStatement = tryStatement;
        exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
        exports.tSArrayType = exports.tsArrayType = tsArrayType;
        exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
        exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
        exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
        exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
        exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
        exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
        exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
        exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
        exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
        exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
        exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
        exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
        exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
        exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
        exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
        exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
        exports.tSImportType = exports.tsImportType = tsImportType;
        exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
        exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
        exports.tSInferType = exports.tsInferType = tsInferType;
        exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
        exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
        exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
        exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
        exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
        exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
        exports.tSMappedType = exports.tsMappedType = tsMappedType;
        exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
        exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
        exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
        exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
        exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
        exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
        exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
        exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
        exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
        exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
        exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
        exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
        exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
        exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
        exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
        exports.tSRestType = exports.tsRestType = tsRestType;
        exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
        exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
        exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
        exports.tSThisType = exports.tsThisType = tsThisType;
        exports.tSTupleType = exports.tsTupleType = tsTupleType;
        exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
        exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
        exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
        exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
        exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
        exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
        exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
        exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
        exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
        exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
        exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
        exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
        exports.tSUnionType = exports.tsUnionType = tsUnionType;
        exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
        exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
        exports.tupleExpression = tupleExpression;
        exports.tupleTypeAnnotation = tupleTypeAnnotation;
        exports.typeAlias = typeAlias;
        exports.typeAnnotation = typeAnnotation;
        exports.typeCastExpression = typeCastExpression;
        exports.typeParameter = typeParameter;
        exports.typeParameterDeclaration = typeParameterDeclaration;
        exports.typeParameterInstantiation = typeParameterInstantiation;
        exports.typeofTypeAnnotation = typeofTypeAnnotation;
        exports.unaryExpression = unaryExpression;
        exports.unionTypeAnnotation = unionTypeAnnotation;
        exports.updateExpression = updateExpression;
        exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
        exports.variableDeclaration = variableDeclaration;
        exports.variableDeclarator = variableDeclarator;
        exports.variance = variance;
        exports.voidTypeAnnotation = voidTypeAnnotation;
        exports.whileStatement = whileStatement;
        exports.withStatement = withStatement;
        exports.yieldExpression = yieldExpression;
        var _validate = require_validate();
        var _deprecationWarning = require_deprecationWarning();
        var utils = require_utils();
        var validate = _validate.validateInternal;
        var NODE_FIELDS = utils.NODE_FIELDS;
        function arrayExpression() {
            var elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var node = {
                type: "ArrayExpression",
                elements: elements
            };
            var defs = NODE_FIELDS.ArrayExpression;
            validate(defs.elements, node, "elements", elements, 1);
            return node;
        }
        function assignmentExpression(operator, left, right) {
            var node = {
                type: "AssignmentExpression",
                operator: operator,
                left: left,
                right: right
            };
            var defs = NODE_FIELDS.AssignmentExpression;
            validate(defs.operator, node, "operator", operator);
            validate(defs.left, node, "left", left, 1);
            validate(defs.right, node, "right", right, 1);
            return node;
        }
        function binaryExpression(operator, left, right) {
            var node = {
                type: "BinaryExpression",
                operator: operator,
                left: left,
                right: right
            };
            var defs = NODE_FIELDS.BinaryExpression;
            validate(defs.operator, node, "operator", operator);
            validate(defs.left, node, "left", left, 1);
            validate(defs.right, node, "right", right, 1);
            return node;
        }
        function interpreterDirective(value) {
            var node = {
                type: "InterpreterDirective",
                value: value
            };
            var defs = NODE_FIELDS.InterpreterDirective;
            validate(defs.value, node, "value", value);
            return node;
        }
        function directive(value) {
            var node = {
                type: "Directive",
                value: value
            };
            var defs = NODE_FIELDS.Directive;
            validate(defs.value, node, "value", value, 1);
            return node;
        }
        function directiveLiteral(value) {
            var node = {
                type: "DirectiveLiteral",
                value: value
            };
            var defs = NODE_FIELDS.DirectiveLiteral;
            validate(defs.value, node, "value", value);
            return node;
        }
        function blockStatement(body3) {
            var directives = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            var node = {
                type: "BlockStatement",
                body: body3,
                directives: directives
            };
            var defs = NODE_FIELDS.BlockStatement;
            validate(defs.body, node, "body", body3, 1);
            validate(defs.directives, node, "directives", directives, 1);
            return node;
        }
        function breakStatement() {
            var label = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var node = {
                type: "BreakStatement",
                label: label
            };
            var defs = NODE_FIELDS.BreakStatement;
            validate(defs.label, node, "label", label, 1);
            return node;
        }
        function callExpression(callee, _arguments) {
            var node = {
                type: "CallExpression",
                callee: callee,
                arguments: _arguments
            };
            var defs = NODE_FIELDS.CallExpression;
            validate(defs.callee, node, "callee", callee, 1);
            validate(defs.arguments, node, "arguments", _arguments, 1);
            return node;
        }
        function catchClause() {
            var param = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var body3 = arguments.length > 1 ? arguments[1] : void 0;
            var node = {
                type: "CatchClause",
                param: param,
                body: body3
            };
            var defs = NODE_FIELDS.CatchClause;
            validate(defs.param, node, "param", param, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function conditionalExpression(test, consequent, alternate) {
            var node = {
                type: "ConditionalExpression",
                test: test,
                consequent: consequent,
                alternate: alternate
            };
            var defs = NODE_FIELDS.ConditionalExpression;
            validate(defs.test, node, "test", test, 1);
            validate(defs.consequent, node, "consequent", consequent, 1);
            validate(defs.alternate, node, "alternate", alternate, 1);
            return node;
        }
        function continueStatement() {
            var label = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var node = {
                type: "ContinueStatement",
                label: label
            };
            var defs = NODE_FIELDS.ContinueStatement;
            validate(defs.label, node, "label", label, 1);
            return node;
        }
        function debuggerStatement() {
            return {
                type: "DebuggerStatement"
            };
        }
        function doWhileStatement(test, body3) {
            var node = {
                type: "DoWhileStatement",
                test: test,
                body: body3
            };
            var defs = NODE_FIELDS.DoWhileStatement;
            validate(defs.test, node, "test", test, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function emptyStatement() {
            return {
                type: "EmptyStatement"
            };
        }
        function expressionStatement(expression) {
            var node = {
                type: "ExpressionStatement",
                expression: expression
            };
            var defs = NODE_FIELDS.ExpressionStatement;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function file(program2) {
            var comments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var tokens = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "File",
                program: program2,
                comments: comments,
                tokens: tokens
            };
            var defs = NODE_FIELDS.File;
            validate(defs.program, node, "program", program2, 1);
            validate(defs.comments, node, "comments", comments, 1);
            validate(defs.tokens, node, "tokens", tokens);
            return node;
        }
        function forInStatement(left, right, body3) {
            var node = {
                type: "ForInStatement",
                left: left,
                right: right,
                body: body3
            };
            var defs = NODE_FIELDS.ForInStatement;
            validate(defs.left, node, "left", left, 1);
            validate(defs.right, node, "right", right, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function forStatement() {
            var init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var test = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var update = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "ForStatement",
                init: init,
                test: test,
                update: update,
                body: body3
            };
            var defs = NODE_FIELDS.ForStatement;
            validate(defs.init, node, "init", init, 1);
            validate(defs.test, node, "test", test, 1);
            validate(defs.update, node, "update", update, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function functionDeclaration() {
            var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var params = arguments.length > 1 ? arguments[1] : void 0;
            var body3 = arguments.length > 2 ? arguments[2] : void 0;
            var generator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var async = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var node = {
                type: "FunctionDeclaration",
                id: id,
                params: params,
                body: body3,
                generator: generator,
                async: async
            };
            var defs = NODE_FIELDS.FunctionDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.generator, node, "generator", generator);
            validate(defs.async, node, "async", async);
            return node;
        }
        function functionExpression() {
            var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var params = arguments.length > 1 ? arguments[1] : void 0;
            var body3 = arguments.length > 2 ? arguments[2] : void 0;
            var generator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var async = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var node = {
                type: "FunctionExpression",
                id: id,
                params: params,
                body: body3,
                generator: generator,
                async: async
            };
            var defs = NODE_FIELDS.FunctionExpression;
            validate(defs.id, node, "id", id, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.generator, node, "generator", generator);
            validate(defs.async, node, "async", async);
            return node;
        }
        function identifier(name) {
            var node = {
                type: "Identifier",
                name: name
            };
            var defs = NODE_FIELDS.Identifier;
            validate(defs.name, node, "name", name);
            return node;
        }
        function ifStatement(test, consequent) {
            var alternate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "IfStatement",
                test: test,
                consequent: consequent,
                alternate: alternate
            };
            var defs = NODE_FIELDS.IfStatement;
            validate(defs.test, node, "test", test, 1);
            validate(defs.consequent, node, "consequent", consequent, 1);
            validate(defs.alternate, node, "alternate", alternate, 1);
            return node;
        }
        function labeledStatement(label, body3) {
            var node = {
                type: "LabeledStatement",
                label: label,
                body: body3
            };
            var defs = NODE_FIELDS.LabeledStatement;
            validate(defs.label, node, "label", label, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function stringLiteral(value) {
            var node = {
                type: "StringLiteral",
                value: value
            };
            var defs = NODE_FIELDS.StringLiteral;
            validate(defs.value, node, "value", value);
            return node;
        }
        function numericLiteral(value) {
            var node = {
                type: "NumericLiteral",
                value: value
            };
            var defs = NODE_FIELDS.NumericLiteral;
            validate(defs.value, node, "value", value);
            return node;
        }
        function nullLiteral() {
            return {
                type: "NullLiteral"
            };
        }
        function booleanLiteral(value) {
            var node = {
                type: "BooleanLiteral",
                value: value
            };
            var defs = NODE_FIELDS.BooleanLiteral;
            validate(defs.value, node, "value", value);
            return node;
        }
        function regExpLiteral(pattern) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            var node = {
                type: "RegExpLiteral",
                pattern: pattern,
                flags: flags
            };
            var defs = NODE_FIELDS.RegExpLiteral;
            validate(defs.pattern, node, "pattern", pattern);
            validate(defs.flags, node, "flags", flags);
            return node;
        }
        function logicalExpression(operator, left, right) {
            var node = {
                type: "LogicalExpression",
                operator: operator,
                left: left,
                right: right
            };
            var defs = NODE_FIELDS.LogicalExpression;
            validate(defs.operator, node, "operator", operator);
            validate(defs.left, node, "left", left, 1);
            validate(defs.right, node, "right", right, 1);
            return node;
        }
        function memberExpression(object, property) {
            var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var optional = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "MemberExpression",
                object: object,
                property: property,
                computed: computed,
                optional: optional
            };
            var defs = NODE_FIELDS.MemberExpression;
            validate(defs.object, node, "object", object, 1);
            validate(defs.property, node, "property", property, 1);
            validate(defs.computed, node, "computed", computed);
            validate(defs.optional, node, "optional", optional);
            return node;
        }
        function newExpression(callee, _arguments) {
            var node = {
                type: "NewExpression",
                callee: callee,
                arguments: _arguments
            };
            var defs = NODE_FIELDS.NewExpression;
            validate(defs.callee, node, "callee", callee, 1);
            validate(defs.arguments, node, "arguments", _arguments, 1);
            return node;
        }
        function program(body3) {
            var directives = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            var sourceType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "script";
            var interpreter = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "Program",
                body: body3,
                directives: directives,
                sourceType: sourceType,
                interpreter: interpreter
            };
            var defs = NODE_FIELDS.Program;
            validate(defs.body, node, "body", body3, 1);
            validate(defs.directives, node, "directives", directives, 1);
            validate(defs.sourceType, node, "sourceType", sourceType);
            validate(defs.interpreter, node, "interpreter", interpreter, 1);
            return node;
        }
        function objectExpression(properties) {
            var node = {
                type: "ObjectExpression",
                properties: properties
            };
            var defs = NODE_FIELDS.ObjectExpression;
            validate(defs.properties, node, "properties", properties, 1);
            return node;
        }
        function objectMethod() {
            var kind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method";
            var key2 = arguments.length > 1 ? arguments[1] : void 0;
            var params = arguments.length > 2 ? arguments[2] : void 0;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var generator = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
            var async = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
            var node = {
                type: "ObjectMethod",
                kind: kind,
                key: key2,
                params: params,
                body: body3,
                computed: computed,
                generator: generator,
                async: async
            };
            var defs = NODE_FIELDS.ObjectMethod;
            validate(defs.kind, node, "kind", kind);
            validate(defs.key, node, "key", key2, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.computed, node, "computed", computed);
            validate(defs.generator, node, "generator", generator);
            validate(defs.async, node, "async", async);
            return node;
        }
        function objectProperty(key2, value) {
            var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var shorthand = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var decorators = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
            var node = {
                type: "ObjectProperty",
                key: key2,
                value: value,
                computed: computed,
                shorthand: shorthand,
                decorators: decorators
            };
            var defs = NODE_FIELDS.ObjectProperty;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.value, node, "value", value, 1);
            validate(defs.computed, node, "computed", computed);
            validate(defs.shorthand, node, "shorthand", shorthand);
            validate(defs.decorators, node, "decorators", decorators, 1);
            return node;
        }
        function restElement(argument) {
            var node = {
                type: "RestElement",
                argument: argument
            };
            var defs = NODE_FIELDS.RestElement;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function returnStatement() {
            var argument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var node = {
                type: "ReturnStatement",
                argument: argument
            };
            var defs = NODE_FIELDS.ReturnStatement;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function sequenceExpression(expressions) {
            var node = {
                type: "SequenceExpression",
                expressions: expressions
            };
            var defs = NODE_FIELDS.SequenceExpression;
            validate(defs.expressions, node, "expressions", expressions, 1);
            return node;
        }
        function parenthesizedExpression(expression) {
            var node = {
                type: "ParenthesizedExpression",
                expression: expression
            };
            var defs = NODE_FIELDS.ParenthesizedExpression;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function switchCase() {
            var test = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var consequent = arguments.length > 1 ? arguments[1] : void 0;
            var node = {
                type: "SwitchCase",
                test: test,
                consequent: consequent
            };
            var defs = NODE_FIELDS.SwitchCase;
            validate(defs.test, node, "test", test, 1);
            validate(defs.consequent, node, "consequent", consequent, 1);
            return node;
        }
        function switchStatement(discriminant, cases) {
            var node = {
                type: "SwitchStatement",
                discriminant: discriminant,
                cases: cases
            };
            var defs = NODE_FIELDS.SwitchStatement;
            validate(defs.discriminant, node, "discriminant", discriminant, 1);
            validate(defs.cases, node, "cases", cases, 1);
            return node;
        }
        function thisExpression() {
            return {
                type: "ThisExpression"
            };
        }
        function throwStatement(argument) {
            var node = {
                type: "ThrowStatement",
                argument: argument
            };
            var defs = NODE_FIELDS.ThrowStatement;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function tryStatement(block) {
            var handler = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var finalizer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TryStatement",
                block: block,
                handler: handler,
                finalizer: finalizer
            };
            var defs = NODE_FIELDS.TryStatement;
            validate(defs.block, node, "block", block, 1);
            validate(defs.handler, node, "handler", handler, 1);
            validate(defs.finalizer, node, "finalizer", finalizer, 1);
            return node;
        }
        function unaryExpression(operator, argument) {
            var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            var node = {
                type: "UnaryExpression",
                operator: operator,
                argument: argument,
                prefix: prefix
            };
            var defs = NODE_FIELDS.UnaryExpression;
            validate(defs.operator, node, "operator", operator);
            validate(defs.argument, node, "argument", argument, 1);
            validate(defs.prefix, node, "prefix", prefix);
            return node;
        }
        function updateExpression(operator, argument) {
            var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var node = {
                type: "UpdateExpression",
                operator: operator,
                argument: argument,
                prefix: prefix
            };
            var defs = NODE_FIELDS.UpdateExpression;
            validate(defs.operator, node, "operator", operator);
            validate(defs.argument, node, "argument", argument, 1);
            validate(defs.prefix, node, "prefix", prefix);
            return node;
        }
        function variableDeclaration(kind, declarations) {
            var node = {
                type: "VariableDeclaration",
                kind: kind,
                declarations: declarations
            };
            var defs = NODE_FIELDS.VariableDeclaration;
            validate(defs.kind, node, "kind", kind);
            validate(defs.declarations, node, "declarations", declarations, 1);
            return node;
        }
        function variableDeclarator(id) {
            var init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "VariableDeclarator",
                id: id,
                init: init
            };
            var defs = NODE_FIELDS.VariableDeclarator;
            validate(defs.id, node, "id", id, 1);
            validate(defs.init, node, "init", init, 1);
            return node;
        }
        function whileStatement(test, body3) {
            var node = {
                type: "WhileStatement",
                test: test,
                body: body3
            };
            var defs = NODE_FIELDS.WhileStatement;
            validate(defs.test, node, "test", test, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function withStatement(object, body3) {
            var node = {
                type: "WithStatement",
                object: object,
                body: body3
            };
            var defs = NODE_FIELDS.WithStatement;
            validate(defs.object, node, "object", object, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function assignmentPattern(left, right) {
            var node = {
                type: "AssignmentPattern",
                left: left,
                right: right
            };
            var defs = NODE_FIELDS.AssignmentPattern;
            validate(defs.left, node, "left", left, 1);
            validate(defs.right, node, "right", right, 1);
            return node;
        }
        function arrayPattern(elements) {
            var node = {
                type: "ArrayPattern",
                elements: elements
            };
            var defs = NODE_FIELDS.ArrayPattern;
            validate(defs.elements, node, "elements", elements, 1);
            return node;
        }
        function arrowFunctionExpression(params, body3) {
            var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var node = {
                type: "ArrowFunctionExpression",
                params: params,
                body: body3,
                async: async,
                expression: null
            };
            var defs = NODE_FIELDS.ArrowFunctionExpression;
            validate(defs.params, node, "params", params, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.async, node, "async", async);
            return node;
        }
        function classBody(body3) {
            var node = {
                type: "ClassBody",
                body: body3
            };
            var defs = NODE_FIELDS.ClassBody;
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function classExpression() {
            var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var superClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var body3 = arguments.length > 2 ? arguments[2] : void 0;
            var decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "ClassExpression",
                id: id,
                superClass: superClass,
                body: body3,
                decorators: decorators
            };
            var defs = NODE_FIELDS.ClassExpression;
            validate(defs.id, node, "id", id, 1);
            validate(defs.superClass, node, "superClass", superClass, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.decorators, node, "decorators", decorators, 1);
            return node;
        }
        function classDeclaration() {
            var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var superClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var body3 = arguments.length > 2 ? arguments[2] : void 0;
            var decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "ClassDeclaration",
                id: id,
                superClass: superClass,
                body: body3,
                decorators: decorators
            };
            var defs = NODE_FIELDS.ClassDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.superClass, node, "superClass", superClass, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.decorators, node, "decorators", decorators, 1);
            return node;
        }
        function exportAllDeclaration(source) {
            var node = {
                type: "ExportAllDeclaration",
                source: source
            };
            var defs = NODE_FIELDS.ExportAllDeclaration;
            validate(defs.source, node, "source", source, 1);
            return node;
        }
        function exportDefaultDeclaration(declaration) {
            var node = {
                type: "ExportDefaultDeclaration",
                declaration: declaration
            };
            var defs = NODE_FIELDS.ExportDefaultDeclaration;
            validate(defs.declaration, node, "declaration", declaration, 1);
            return node;
        }
        function exportNamedDeclaration() {
            var declaration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var specifiers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "ExportNamedDeclaration",
                declaration: declaration,
                specifiers: specifiers,
                source: source
            };
            var defs = NODE_FIELDS.ExportNamedDeclaration;
            validate(defs.declaration, node, "declaration", declaration, 1);
            validate(defs.specifiers, node, "specifiers", specifiers, 1);
            validate(defs.source, node, "source", source, 1);
            return node;
        }
        function exportSpecifier(local, exported) {
            var node = {
                type: "ExportSpecifier",
                local: local,
                exported: exported
            };
            var defs = NODE_FIELDS.ExportSpecifier;
            validate(defs.local, node, "local", local, 1);
            validate(defs.exported, node, "exported", exported, 1);
            return node;
        }
        function forOfStatement(left, right, body3) {
            var _await = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var node = {
                type: "ForOfStatement",
                left: left,
                right: right,
                body: body3,
                await: _await
            };
            var defs = NODE_FIELDS.ForOfStatement;
            validate(defs.left, node, "left", left, 1);
            validate(defs.right, node, "right", right, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.await, node, "await", _await);
            return node;
        }
        function importDeclaration(specifiers, source) {
            var node = {
                type: "ImportDeclaration",
                specifiers: specifiers,
                source: source
            };
            var defs = NODE_FIELDS.ImportDeclaration;
            validate(defs.specifiers, node, "specifiers", specifiers, 1);
            validate(defs.source, node, "source", source, 1);
            return node;
        }
        function importDefaultSpecifier(local) {
            var node = {
                type: "ImportDefaultSpecifier",
                local: local
            };
            var defs = NODE_FIELDS.ImportDefaultSpecifier;
            validate(defs.local, node, "local", local, 1);
            return node;
        }
        function importNamespaceSpecifier(local) {
            var node = {
                type: "ImportNamespaceSpecifier",
                local: local
            };
            var defs = NODE_FIELDS.ImportNamespaceSpecifier;
            validate(defs.local, node, "local", local, 1);
            return node;
        }
        function importSpecifier(local, imported) {
            var node = {
                type: "ImportSpecifier",
                local: local,
                imported: imported
            };
            var defs = NODE_FIELDS.ImportSpecifier;
            validate(defs.local, node, "local", local, 1);
            validate(defs.imported, node, "imported", imported, 1);
            return node;
        }
        function importExpression(source) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "ImportExpression",
                source: source,
                options: options
            };
            var defs = NODE_FIELDS.ImportExpression;
            validate(defs.source, node, "source", source, 1);
            validate(defs.options, node, "options", options, 1);
            return node;
        }
        function metaProperty(meta, property) {
            var node = {
                type: "MetaProperty",
                meta: meta,
                property: property
            };
            var defs = NODE_FIELDS.MetaProperty;
            validate(defs.meta, node, "meta", meta, 1);
            validate(defs.property, node, "property", property, 1);
            return node;
        }
        function classMethod() {
            var kind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method";
            var key2 = arguments.length > 1 ? arguments[1] : void 0;
            var params = arguments.length > 2 ? arguments[2] : void 0;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var _static = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
            var generator = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
            var async = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
            var node = {
                type: "ClassMethod",
                kind: kind,
                key: key2,
                params: params,
                body: body3,
                computed: computed,
                static: _static,
                generator: generator,
                async: async
            };
            var defs = NODE_FIELDS.ClassMethod;
            validate(defs.kind, node, "kind", kind);
            validate(defs.key, node, "key", key2, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.computed, node, "computed", computed);
            validate(defs.static, node, "static", _static);
            validate(defs.generator, node, "generator", generator);
            validate(defs.async, node, "async", async);
            return node;
        }
        function objectPattern(properties) {
            var node = {
                type: "ObjectPattern",
                properties: properties
            };
            var defs = NODE_FIELDS.ObjectPattern;
            validate(defs.properties, node, "properties", properties, 1);
            return node;
        }
        function spreadElement(argument) {
            var node = {
                type: "SpreadElement",
                argument: argument
            };
            var defs = NODE_FIELDS.SpreadElement;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function _super() {
            return {
                type: "Super"
            };
        }
        function taggedTemplateExpression(tag, quasi) {
            var node = {
                type: "TaggedTemplateExpression",
                tag: tag,
                quasi: quasi
            };
            var defs = NODE_FIELDS.TaggedTemplateExpression;
            validate(defs.tag, node, "tag", tag, 1);
            validate(defs.quasi, node, "quasi", quasi, 1);
            return node;
        }
        function templateElement(value) {
            var tail = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var node = {
                type: "TemplateElement",
                value: value,
                tail: tail
            };
            var defs = NODE_FIELDS.TemplateElement;
            validate(defs.value, node, "value", value);
            validate(defs.tail, node, "tail", tail);
            return node;
        }
        function templateLiteral(quasis, expressions) {
            var node = {
                type: "TemplateLiteral",
                quasis: quasis,
                expressions: expressions
            };
            var defs = NODE_FIELDS.TemplateLiteral;
            validate(defs.quasis, node, "quasis", quasis, 1);
            validate(defs.expressions, node, "expressions", expressions, 1);
            return node;
        }
        function yieldExpression() {
            var argument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var delegate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var node = {
                type: "YieldExpression",
                argument: argument,
                delegate: delegate
            };
            var defs = NODE_FIELDS.YieldExpression;
            validate(defs.argument, node, "argument", argument, 1);
            validate(defs.delegate, node, "delegate", delegate);
            return node;
        }
        function awaitExpression(argument) {
            var node = {
                type: "AwaitExpression",
                argument: argument
            };
            var defs = NODE_FIELDS.AwaitExpression;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function _import() {
            return {
                type: "Import"
            };
        }
        function bigIntLiteral(value) {
            var node = {
                type: "BigIntLiteral",
                value: value
            };
            var defs = NODE_FIELDS.BigIntLiteral;
            validate(defs.value, node, "value", value);
            return node;
        }
        function exportNamespaceSpecifier(exported) {
            var node = {
                type: "ExportNamespaceSpecifier",
                exported: exported
            };
            var defs = NODE_FIELDS.ExportNamespaceSpecifier;
            validate(defs.exported, node, "exported", exported, 1);
            return node;
        }
        function optionalMemberExpression(object, property) {
            var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var optional = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "OptionalMemberExpression",
                object: object,
                property: property,
                computed: computed,
                optional: optional
            };
            var defs = NODE_FIELDS.OptionalMemberExpression;
            validate(defs.object, node, "object", object, 1);
            validate(defs.property, node, "property", property, 1);
            validate(defs.computed, node, "computed", computed);
            validate(defs.optional, node, "optional", optional);
            return node;
        }
        function optionalCallExpression(callee, _arguments, optional) {
            var node = {
                type: "OptionalCallExpression",
                callee: callee,
                arguments: _arguments,
                optional: optional
            };
            var defs = NODE_FIELDS.OptionalCallExpression;
            validate(defs.callee, node, "callee", callee, 1);
            validate(defs.arguments, node, "arguments", _arguments, 1);
            validate(defs.optional, node, "optional", optional);
            return node;
        }
        function classProperty(key2) {
            var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var _static = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
            var node = {
                type: "ClassProperty",
                key: key2,
                value: value,
                typeAnnotation: typeAnnotation2,
                decorators: decorators,
                computed: computed,
                static: _static
            };
            var defs = NODE_FIELDS.ClassProperty;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.value, node, "value", value, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            validate(defs.decorators, node, "decorators", decorators, 1);
            validate(defs.computed, node, "computed", computed);
            validate(defs.static, node, "static", _static);
            return node;
        }
        function classAccessorProperty(key2) {
            var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var decorators = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var computed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var _static = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
            var node = {
                type: "ClassAccessorProperty",
                key: key2,
                value: value,
                typeAnnotation: typeAnnotation2,
                decorators: decorators,
                computed: computed,
                static: _static
            };
            var defs = NODE_FIELDS.ClassAccessorProperty;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.value, node, "value", value, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            validate(defs.decorators, node, "decorators", decorators, 1);
            validate(defs.computed, node, "computed", computed);
            validate(defs.static, node, "static", _static);
            return node;
        }
        function classPrivateProperty(key2) {
            var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var decorators = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var _static = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var node = {
                type: "ClassPrivateProperty",
                key: key2,
                value: value,
                decorators: decorators,
                static: _static
            };
            var defs = NODE_FIELDS.ClassPrivateProperty;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.value, node, "value", value, 1);
            validate(defs.decorators, node, "decorators", decorators, 1);
            validate(defs.static, node, "static", _static);
            return node;
        }
        function classPrivateMethod() {
            var kind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method";
            var key2 = arguments.length > 1 ? arguments[1] : void 0;
            var params = arguments.length > 2 ? arguments[2] : void 0;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var _static = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var node = {
                type: "ClassPrivateMethod",
                kind: kind,
                key: key2,
                params: params,
                body: body3,
                static: _static
            };
            var defs = NODE_FIELDS.ClassPrivateMethod;
            validate(defs.kind, node, "kind", kind);
            validate(defs.key, node, "key", key2, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.static, node, "static", _static);
            return node;
        }
        function privateName(id) {
            var node = {
                type: "PrivateName",
                id: id
            };
            var defs = NODE_FIELDS.PrivateName;
            validate(defs.id, node, "id", id, 1);
            return node;
        }
        function staticBlock(body3) {
            var node = {
                type: "StaticBlock",
                body: body3
            };
            var defs = NODE_FIELDS.StaticBlock;
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function anyTypeAnnotation() {
            return {
                type: "AnyTypeAnnotation"
            };
        }
        function arrayTypeAnnotation(elementType) {
            var node = {
                type: "ArrayTypeAnnotation",
                elementType: elementType
            };
            var defs = NODE_FIELDS.ArrayTypeAnnotation;
            validate(defs.elementType, node, "elementType", elementType, 1);
            return node;
        }
        function booleanTypeAnnotation() {
            return {
                type: "BooleanTypeAnnotation"
            };
        }
        function booleanLiteralTypeAnnotation(value) {
            var node = {
                type: "BooleanLiteralTypeAnnotation",
                value: value
            };
            var defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
            validate(defs.value, node, "value", value);
            return node;
        }
        function nullLiteralTypeAnnotation() {
            return {
                type: "NullLiteralTypeAnnotation"
            };
        }
        function classImplements(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "ClassImplements",
                id: id,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.ClassImplements;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function declareClass(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "DeclareClass",
                id: id,
                typeParameters: typeParameters,
                extends: _extends,
                body: body3
            };
            var defs = NODE_FIELDS.DeclareClass;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.extends, node, "extends", _extends, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function declareFunction(id) {
            var node = {
                type: "DeclareFunction",
                id: id
            };
            var defs = NODE_FIELDS.DeclareFunction;
            validate(defs.id, node, "id", id, 1);
            return node;
        }
        function declareInterface(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "DeclareInterface",
                id: id,
                typeParameters: typeParameters,
                extends: _extends,
                body: body3
            };
            var defs = NODE_FIELDS.DeclareInterface;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.extends, node, "extends", _extends, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function declareModule(id, body3) {
            var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "DeclareModule",
                id: id,
                body: body3,
                kind: kind
            };
            var defs = NODE_FIELDS.DeclareModule;
            validate(defs.id, node, "id", id, 1);
            validate(defs.body, node, "body", body3, 1);
            validate(defs.kind, node, "kind", kind);
            return node;
        }
        function declareModuleExports(typeAnnotation2) {
            var node = {
                type: "DeclareModuleExports",
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.DeclareModuleExports;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function declareTypeAlias(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var right = arguments.length > 2 ? arguments[2] : void 0;
            var node = {
                type: "DeclareTypeAlias",
                id: id,
                typeParameters: typeParameters,
                right: right
            };
            var defs = NODE_FIELDS.DeclareTypeAlias;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.right, node, "right", right, 1);
            return node;
        }
        function declareOpaqueType(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var supertype = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "DeclareOpaqueType",
                id: id,
                typeParameters: typeParameters,
                supertype: supertype
            };
            var defs = NODE_FIELDS.DeclareOpaqueType;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.supertype, node, "supertype", supertype, 1);
            return node;
        }
        function declareVariable(id) {
            var node = {
                type: "DeclareVariable",
                id: id
            };
            var defs = NODE_FIELDS.DeclareVariable;
            validate(defs.id, node, "id", id, 1);
            return node;
        }
        function declareExportDeclaration() {
            var declaration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var specifiers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var attributes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "DeclareExportDeclaration",
                declaration: declaration,
                specifiers: specifiers,
                source: source,
                attributes: attributes
            };
            var defs = NODE_FIELDS.DeclareExportDeclaration;
            validate(defs.declaration, node, "declaration", declaration, 1);
            validate(defs.specifiers, node, "specifiers", specifiers, 1);
            validate(defs.source, node, "source", source, 1);
            validate(defs.attributes, node, "attributes", attributes, 1);
            return node;
        }
        function declareExportAllDeclaration(source) {
            var attributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "DeclareExportAllDeclaration",
                source: source,
                attributes: attributes
            };
            var defs = NODE_FIELDS.DeclareExportAllDeclaration;
            validate(defs.source, node, "source", source, 1);
            validate(defs.attributes, node, "attributes", attributes, 1);
            return node;
        }
        function declaredPredicate(value) {
            var node = {
                type: "DeclaredPredicate",
                value: value
            };
            var defs = NODE_FIELDS.DeclaredPredicate;
            validate(defs.value, node, "value", value, 1);
            return node;
        }
        function existsTypeAnnotation() {
            return {
                type: "ExistsTypeAnnotation"
            };
        }
        function functionTypeAnnotation() {
            var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var params = arguments.length > 1 ? arguments[1] : void 0;
            var rest = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var returnType = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "FunctionTypeAnnotation",
                typeParameters: typeParameters,
                params: params,
                rest: rest,
                returnType: returnType
            };
            var defs = NODE_FIELDS.FunctionTypeAnnotation;
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.rest, node, "rest", rest, 1);
            validate(defs.returnType, node, "returnType", returnType, 1);
            return node;
        }
        function functionTypeParam() {
            var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var typeAnnotation2 = arguments.length > 1 ? arguments[1] : void 0;
            var node = {
                type: "FunctionTypeParam",
                name: name,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.FunctionTypeParam;
            validate(defs.name, node, "name", name, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function genericTypeAnnotation(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "GenericTypeAnnotation",
                id: id,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.GenericTypeAnnotation;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function inferredPredicate() {
            return {
                type: "InferredPredicate"
            };
        }
        function interfaceExtends(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "InterfaceExtends",
                id: id,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.InterfaceExtends;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function interfaceDeclaration(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "InterfaceDeclaration",
                id: id,
                typeParameters: typeParameters,
                extends: _extends,
                body: body3
            };
            var defs = NODE_FIELDS.InterfaceDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.extends, node, "extends", _extends, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function interfaceTypeAnnotation() {
            var _extends = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var body3 = arguments.length > 1 ? arguments[1] : void 0;
            var node = {
                type: "InterfaceTypeAnnotation",
                extends: _extends,
                body: body3
            };
            var defs = NODE_FIELDS.InterfaceTypeAnnotation;
            validate(defs.extends, node, "extends", _extends, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function intersectionTypeAnnotation(types) {
            var node = {
                type: "IntersectionTypeAnnotation",
                types: types
            };
            var defs = NODE_FIELDS.IntersectionTypeAnnotation;
            validate(defs.types, node, "types", types, 1);
            return node;
        }
        function mixedTypeAnnotation() {
            return {
                type: "MixedTypeAnnotation"
            };
        }
        function emptyTypeAnnotation() {
            return {
                type: "EmptyTypeAnnotation"
            };
        }
        function nullableTypeAnnotation(typeAnnotation2) {
            var node = {
                type: "NullableTypeAnnotation",
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.NullableTypeAnnotation;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function numberLiteralTypeAnnotation(value) {
            var node = {
                type: "NumberLiteralTypeAnnotation",
                value: value
            };
            var defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
            validate(defs.value, node, "value", value);
            return node;
        }
        function numberTypeAnnotation() {
            return {
                type: "NumberTypeAnnotation"
            };
        }
        function objectTypeAnnotation(properties) {
            var indexers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            var callProperties = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            var internalSlots = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
            var exact = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
            var node = {
                type: "ObjectTypeAnnotation",
                properties: properties,
                indexers: indexers,
                callProperties: callProperties,
                internalSlots: internalSlots,
                exact: exact
            };
            var defs = NODE_FIELDS.ObjectTypeAnnotation;
            validate(defs.properties, node, "properties", properties, 1);
            validate(defs.indexers, node, "indexers", indexers, 1);
            validate(defs.callProperties, node, "callProperties", callProperties, 1);
            validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
            validate(defs.exact, node, "exact", exact);
            return node;
        }
        function objectTypeInternalSlot(id, value, optional, _static, method) {
            var node = {
                type: "ObjectTypeInternalSlot",
                id: id,
                value: value,
                optional: optional,
                static: _static,
                method: method
            };
            var defs = NODE_FIELDS.ObjectTypeInternalSlot;
            validate(defs.id, node, "id", id, 1);
            validate(defs.value, node, "value", value, 1);
            validate(defs.optional, node, "optional", optional);
            validate(defs.static, node, "static", _static);
            validate(defs.method, node, "method", method);
            return node;
        }
        function objectTypeCallProperty(value) {
            var node = {
                type: "ObjectTypeCallProperty",
                value: value,
                static: null
            };
            var defs = NODE_FIELDS.ObjectTypeCallProperty;
            validate(defs.value, node, "value", value, 1);
            return node;
        }
        function objectTypeIndexer() {
            var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var key2 = arguments.length > 1 ? arguments[1] : void 0;
            var value = arguments.length > 2 ? arguments[2] : void 0;
            var variance2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "ObjectTypeIndexer",
                id: id,
                key: key2,
                value: value,
                variance: variance2,
                static: null
            };
            var defs = NODE_FIELDS.ObjectTypeIndexer;
            validate(defs.id, node, "id", id, 1);
            validate(defs.key, node, "key", key2, 1);
            validate(defs.value, node, "value", value, 1);
            validate(defs.variance, node, "variance", variance2, 1);
            return node;
        }
        function objectTypeProperty(key2, value) {
            var variance2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "ObjectTypeProperty",
                key: key2,
                value: value,
                variance: variance2,
                kind: null,
                method: null,
                optional: null,
                proto: null,
                static: null
            };
            var defs = NODE_FIELDS.ObjectTypeProperty;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.value, node, "value", value, 1);
            validate(defs.variance, node, "variance", variance2, 1);
            return node;
        }
        function objectTypeSpreadProperty(argument) {
            var node = {
                type: "ObjectTypeSpreadProperty",
                argument: argument
            };
            var defs = NODE_FIELDS.ObjectTypeSpreadProperty;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function opaqueType(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var supertype = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var impltype = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "OpaqueType",
                id: id,
                typeParameters: typeParameters,
                supertype: supertype,
                impltype: impltype
            };
            var defs = NODE_FIELDS.OpaqueType;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.supertype, node, "supertype", supertype, 1);
            validate(defs.impltype, node, "impltype", impltype, 1);
            return node;
        }
        function qualifiedTypeIdentifier(id, qualification) {
            var node = {
                type: "QualifiedTypeIdentifier",
                id: id,
                qualification: qualification
            };
            var defs = NODE_FIELDS.QualifiedTypeIdentifier;
            validate(defs.id, node, "id", id, 1);
            validate(defs.qualification, node, "qualification", qualification, 1);
            return node;
        }
        function stringLiteralTypeAnnotation(value) {
            var node = {
                type: "StringLiteralTypeAnnotation",
                value: value
            };
            var defs = NODE_FIELDS.StringLiteralTypeAnnotation;
            validate(defs.value, node, "value", value);
            return node;
        }
        function stringTypeAnnotation() {
            return {
                type: "StringTypeAnnotation"
            };
        }
        function symbolTypeAnnotation() {
            return {
                type: "SymbolTypeAnnotation"
            };
        }
        function thisTypeAnnotation() {
            return {
                type: "ThisTypeAnnotation"
            };
        }
        function tupleTypeAnnotation(types) {
            var node = {
                type: "TupleTypeAnnotation",
                types: types
            };
            var defs = NODE_FIELDS.TupleTypeAnnotation;
            validate(defs.types, node, "types", types, 1);
            return node;
        }
        function typeofTypeAnnotation(argument) {
            var node = {
                type: "TypeofTypeAnnotation",
                argument: argument
            };
            var defs = NODE_FIELDS.TypeofTypeAnnotation;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function typeAlias(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var right = arguments.length > 2 ? arguments[2] : void 0;
            var node = {
                type: "TypeAlias",
                id: id,
                typeParameters: typeParameters,
                right: right
            };
            var defs = NODE_FIELDS.TypeAlias;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.right, node, "right", right, 1);
            return node;
        }
        function typeAnnotation(typeAnnotation2) {
            var node = {
                type: "TypeAnnotation",
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TypeAnnotation;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function typeCastExpression(expression, typeAnnotation2) {
            var node = {
                type: "TypeCastExpression",
                expression: expression,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TypeCastExpression;
            validate(defs.expression, node, "expression", expression, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function typeParameter() {
            var bound = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var _default = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var variance2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TypeParameter",
                bound: bound,
                default: _default,
                variance: variance2,
                name: null
            };
            var defs = NODE_FIELDS.TypeParameter;
            validate(defs.bound, node, "bound", bound, 1);
            validate(defs.default, node, "default", _default, 1);
            validate(defs.variance, node, "variance", variance2, 1);
            return node;
        }
        function typeParameterDeclaration(params) {
            var node = {
                type: "TypeParameterDeclaration",
                params: params
            };
            var defs = NODE_FIELDS.TypeParameterDeclaration;
            validate(defs.params, node, "params", params, 1);
            return node;
        }
        function typeParameterInstantiation(params) {
            var node = {
                type: "TypeParameterInstantiation",
                params: params
            };
            var defs = NODE_FIELDS.TypeParameterInstantiation;
            validate(defs.params, node, "params", params, 1);
            return node;
        }
        function unionTypeAnnotation(types) {
            var node = {
                type: "UnionTypeAnnotation",
                types: types
            };
            var defs = NODE_FIELDS.UnionTypeAnnotation;
            validate(defs.types, node, "types", types, 1);
            return node;
        }
        function variance(kind) {
            var node = {
                type: "Variance",
                kind: kind
            };
            var defs = NODE_FIELDS.Variance;
            validate(defs.kind, node, "kind", kind);
            return node;
        }
        function voidTypeAnnotation() {
            return {
                type: "VoidTypeAnnotation"
            };
        }
        function enumDeclaration(id, body3) {
            var node = {
                type: "EnumDeclaration",
                id: id,
                body: body3
            };
            var defs = NODE_FIELDS.EnumDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function enumBooleanBody(members) {
            var node = {
                type: "EnumBooleanBody",
                members: members,
                explicitType: null,
                hasUnknownMembers: null
            };
            var defs = NODE_FIELDS.EnumBooleanBody;
            validate(defs.members, node, "members", members, 1);
            return node;
        }
        function enumNumberBody(members) {
            var node = {
                type: "EnumNumberBody",
                members: members,
                explicitType: null,
                hasUnknownMembers: null
            };
            var defs = NODE_FIELDS.EnumNumberBody;
            validate(defs.members, node, "members", members, 1);
            return node;
        }
        function enumStringBody(members) {
            var node = {
                type: "EnumStringBody",
                members: members,
                explicitType: null,
                hasUnknownMembers: null
            };
            var defs = NODE_FIELDS.EnumStringBody;
            validate(defs.members, node, "members", members, 1);
            return node;
        }
        function enumSymbolBody(members) {
            var node = {
                type: "EnumSymbolBody",
                members: members,
                hasUnknownMembers: null
            };
            var defs = NODE_FIELDS.EnumSymbolBody;
            validate(defs.members, node, "members", members, 1);
            return node;
        }
        function enumBooleanMember(id) {
            var node = {
                type: "EnumBooleanMember",
                id: id,
                init: null
            };
            var defs = NODE_FIELDS.EnumBooleanMember;
            validate(defs.id, node, "id", id, 1);
            return node;
        }
        function enumNumberMember(id, init) {
            var node = {
                type: "EnumNumberMember",
                id: id,
                init: init
            };
            var defs = NODE_FIELDS.EnumNumberMember;
            validate(defs.id, node, "id", id, 1);
            validate(defs.init, node, "init", init, 1);
            return node;
        }
        function enumStringMember(id, init) {
            var node = {
                type: "EnumStringMember",
                id: id,
                init: init
            };
            var defs = NODE_FIELDS.EnumStringMember;
            validate(defs.id, node, "id", id, 1);
            validate(defs.init, node, "init", init, 1);
            return node;
        }
        function enumDefaultedMember(id) {
            var node = {
                type: "EnumDefaultedMember",
                id: id
            };
            var defs = NODE_FIELDS.EnumDefaultedMember;
            validate(defs.id, node, "id", id, 1);
            return node;
        }
        function indexedAccessType(objectType, indexType) {
            var node = {
                type: "IndexedAccessType",
                objectType: objectType,
                indexType: indexType
            };
            var defs = NODE_FIELDS.IndexedAccessType;
            validate(defs.objectType, node, "objectType", objectType, 1);
            validate(defs.indexType, node, "indexType", indexType, 1);
            return node;
        }
        function optionalIndexedAccessType(objectType, indexType) {
            var node = {
                type: "OptionalIndexedAccessType",
                objectType: objectType,
                indexType: indexType,
                optional: null
            };
            var defs = NODE_FIELDS.OptionalIndexedAccessType;
            validate(defs.objectType, node, "objectType", objectType, 1);
            validate(defs.indexType, node, "indexType", indexType, 1);
            return node;
        }
        function jsxAttribute(name) {
            var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "JSXAttribute",
                name: name,
                value: value
            };
            var defs = NODE_FIELDS.JSXAttribute;
            validate(defs.name, node, "name", name, 1);
            validate(defs.value, node, "value", value, 1);
            return node;
        }
        function jsxClosingElement(name) {
            var node = {
                type: "JSXClosingElement",
                name: name
            };
            var defs = NODE_FIELDS.JSXClosingElement;
            validate(defs.name, node, "name", name, 1);
            return node;
        }
        function jsxElement(openingElement) {
            var closingElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var children = arguments.length > 2 ? arguments[2] : void 0;
            var selfClosing = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "JSXElement",
                openingElement: openingElement,
                closingElement: closingElement,
                children: children,
                selfClosing: selfClosing
            };
            var defs = NODE_FIELDS.JSXElement;
            validate(defs.openingElement, node, "openingElement", openingElement, 1);
            validate(defs.closingElement, node, "closingElement", closingElement, 1);
            validate(defs.children, node, "children", children, 1);
            validate(defs.selfClosing, node, "selfClosing", selfClosing);
            return node;
        }
        function jsxEmptyExpression() {
            return {
                type: "JSXEmptyExpression"
            };
        }
        function jsxExpressionContainer(expression) {
            var node = {
                type: "JSXExpressionContainer",
                expression: expression
            };
            var defs = NODE_FIELDS.JSXExpressionContainer;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function jsxSpreadChild(expression) {
            var node = {
                type: "JSXSpreadChild",
                expression: expression
            };
            var defs = NODE_FIELDS.JSXSpreadChild;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function jsxIdentifier(name) {
            var node = {
                type: "JSXIdentifier",
                name: name
            };
            var defs = NODE_FIELDS.JSXIdentifier;
            validate(defs.name, node, "name", name);
            return node;
        }
        function jsxMemberExpression(object, property) {
            var node = {
                type: "JSXMemberExpression",
                object: object,
                property: property
            };
            var defs = NODE_FIELDS.JSXMemberExpression;
            validate(defs.object, node, "object", object, 1);
            validate(defs.property, node, "property", property, 1);
            return node;
        }
        function jsxNamespacedName(namespace, name) {
            var node = {
                type: "JSXNamespacedName",
                namespace: namespace,
                name: name
            };
            var defs = NODE_FIELDS.JSXNamespacedName;
            validate(defs.namespace, node, "namespace", namespace, 1);
            validate(defs.name, node, "name", name, 1);
            return node;
        }
        function jsxOpeningElement(name, attributes) {
            var selfClosing = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var node = {
                type: "JSXOpeningElement",
                name: name,
                attributes: attributes,
                selfClosing: selfClosing
            };
            var defs = NODE_FIELDS.JSXOpeningElement;
            validate(defs.name, node, "name", name, 1);
            validate(defs.attributes, node, "attributes", attributes, 1);
            validate(defs.selfClosing, node, "selfClosing", selfClosing);
            return node;
        }
        function jsxSpreadAttribute(argument) {
            var node = {
                type: "JSXSpreadAttribute",
                argument: argument
            };
            var defs = NODE_FIELDS.JSXSpreadAttribute;
            validate(defs.argument, node, "argument", argument, 1);
            return node;
        }
        function jsxText(value) {
            var node = {
                type: "JSXText",
                value: value
            };
            var defs = NODE_FIELDS.JSXText;
            validate(defs.value, node, "value", value);
            return node;
        }
        function jsxFragment(openingFragment, closingFragment, children) {
            var node = {
                type: "JSXFragment",
                openingFragment: openingFragment,
                closingFragment: closingFragment,
                children: children
            };
            var defs = NODE_FIELDS.JSXFragment;
            validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
            validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
            validate(defs.children, node, "children", children, 1);
            return node;
        }
        function jsxOpeningFragment() {
            return {
                type: "JSXOpeningFragment"
            };
        }
        function jsxClosingFragment() {
            return {
                type: "JSXClosingFragment"
            };
        }
        function noop2() {
            return {
                type: "Noop"
            };
        }
        function placeholder(expectedNode, name) {
            var node = {
                type: "Placeholder",
                expectedNode: expectedNode,
                name: name
            };
            var defs = NODE_FIELDS.Placeholder;
            validate(defs.expectedNode, node, "expectedNode", expectedNode);
            validate(defs.name, node, "name", name, 1);
            return node;
        }
        function v8IntrinsicIdentifier(name) {
            var node = {
                type: "V8IntrinsicIdentifier",
                name: name
            };
            var defs = NODE_FIELDS.V8IntrinsicIdentifier;
            validate(defs.name, node, "name", name);
            return node;
        }
        function argumentPlaceholder() {
            return {
                type: "ArgumentPlaceholder"
            };
        }
        function bindExpression(object, callee) {
            var node = {
                type: "BindExpression",
                object: object,
                callee: callee
            };
            var defs = NODE_FIELDS.BindExpression;
            validate(defs.object, node, "object", object, 1);
            validate(defs.callee, node, "callee", callee, 1);
            return node;
        }
        function importAttribute(key2, value) {
            var node = {
                type: "ImportAttribute",
                key: key2,
                value: value
            };
            var defs = NODE_FIELDS.ImportAttribute;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.value, node, "value", value, 1);
            return node;
        }
        function decorator(expression) {
            var node = {
                type: "Decorator",
                expression: expression
            };
            var defs = NODE_FIELDS.Decorator;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function doExpression(body3) {
            var async = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var node = {
                type: "DoExpression",
                body: body3,
                async: async
            };
            var defs = NODE_FIELDS.DoExpression;
            validate(defs.body, node, "body", body3, 1);
            validate(defs.async, node, "async", async);
            return node;
        }
        function exportDefaultSpecifier(exported) {
            var node = {
                type: "ExportDefaultSpecifier",
                exported: exported
            };
            var defs = NODE_FIELDS.ExportDefaultSpecifier;
            validate(defs.exported, node, "exported", exported, 1);
            return node;
        }
        function recordExpression(properties) {
            var node = {
                type: "RecordExpression",
                properties: properties
            };
            var defs = NODE_FIELDS.RecordExpression;
            validate(defs.properties, node, "properties", properties, 1);
            return node;
        }
        function tupleExpression() {
            var elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var node = {
                type: "TupleExpression",
                elements: elements
            };
            var defs = NODE_FIELDS.TupleExpression;
            validate(defs.elements, node, "elements", elements, 1);
            return node;
        }
        function decimalLiteral(value) {
            var node = {
                type: "DecimalLiteral",
                value: value
            };
            var defs = NODE_FIELDS.DecimalLiteral;
            validate(defs.value, node, "value", value);
            return node;
        }
        function moduleExpression(body3) {
            var node = {
                type: "ModuleExpression",
                body: body3
            };
            var defs = NODE_FIELDS.ModuleExpression;
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function topicReference() {
            return {
                type: "TopicReference"
            };
        }
        function pipelineTopicExpression(expression) {
            var node = {
                type: "PipelineTopicExpression",
                expression: expression
            };
            var defs = NODE_FIELDS.PipelineTopicExpression;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function pipelineBareFunction(callee) {
            var node = {
                type: "PipelineBareFunction",
                callee: callee
            };
            var defs = NODE_FIELDS.PipelineBareFunction;
            validate(defs.callee, node, "callee", callee, 1);
            return node;
        }
        function pipelinePrimaryTopicReference() {
            return {
                type: "PipelinePrimaryTopicReference"
            };
        }
        function tsParameterProperty(parameter) {
            var node = {
                type: "TSParameterProperty",
                parameter: parameter
            };
            var defs = NODE_FIELDS.TSParameterProperty;
            validate(defs.parameter, node, "parameter", parameter, 1);
            return node;
        }
        function tsDeclareFunction() {
            var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var params = arguments.length > 2 ? arguments[2] : void 0;
            var returnType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "TSDeclareFunction",
                id: id,
                typeParameters: typeParameters,
                params: params,
                returnType: returnType
            };
            var defs = NODE_FIELDS.TSDeclareFunction;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.returnType, node, "returnType", returnType, 1);
            return node;
        }
        function tsDeclareMethod() {
            var decorators = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var key2 = arguments.length > 1 ? arguments[1] : void 0;
            var typeParameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var params = arguments.length > 3 ? arguments[3] : void 0;
            var returnType = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
            var node = {
                type: "TSDeclareMethod",
                decorators: decorators,
                key: key2,
                typeParameters: typeParameters,
                params: params,
                returnType: returnType
            };
            var defs = NODE_FIELDS.TSDeclareMethod;
            validate(defs.decorators, node, "decorators", decorators, 1);
            validate(defs.key, node, "key", key2, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.params, node, "params", params, 1);
            validate(defs.returnType, node, "returnType", returnType, 1);
            return node;
        }
        function tsQualifiedName(left, right) {
            var node = {
                type: "TSQualifiedName",
                left: left,
                right: right
            };
            var defs = NODE_FIELDS.TSQualifiedName;
            validate(defs.left, node, "left", left, 1);
            validate(defs.right, node, "right", right, 1);
            return node;
        }
        function tsCallSignatureDeclaration() {
            var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var parameters = arguments.length > 1 ? arguments[1] : void 0;
            var typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TSCallSignatureDeclaration",
                typeParameters: typeParameters,
                parameters: parameters,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSCallSignatureDeclaration;
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.parameters, node, "parameters", parameters, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsConstructSignatureDeclaration() {
            var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var parameters = arguments.length > 1 ? arguments[1] : void 0;
            var typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TSConstructSignatureDeclaration",
                typeParameters: typeParameters,
                parameters: parameters,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSConstructSignatureDeclaration;
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.parameters, node, "parameters", parameters, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsPropertySignature(key2) {
            var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "TSPropertySignature",
                key: key2,
                typeAnnotation: typeAnnotation2,
                kind: null
            };
            var defs = NODE_FIELDS.TSPropertySignature;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsMethodSignature(key2) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var parameters = arguments.length > 2 ? arguments[2] : void 0;
            var typeAnnotation2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var node = {
                type: "TSMethodSignature",
                key: key2,
                typeParameters: typeParameters,
                parameters: parameters,
                typeAnnotation: typeAnnotation2,
                kind: null
            };
            var defs = NODE_FIELDS.TSMethodSignature;
            validate(defs.key, node, "key", key2, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.parameters, node, "parameters", parameters, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsIndexSignature(parameters) {
            var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "TSIndexSignature",
                parameters: parameters,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSIndexSignature;
            validate(defs.parameters, node, "parameters", parameters, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsAnyKeyword() {
            return {
                type: "TSAnyKeyword"
            };
        }
        function tsBooleanKeyword() {
            return {
                type: "TSBooleanKeyword"
            };
        }
        function tsBigIntKeyword() {
            return {
                type: "TSBigIntKeyword"
            };
        }
        function tsIntrinsicKeyword() {
            return {
                type: "TSIntrinsicKeyword"
            };
        }
        function tsNeverKeyword() {
            return {
                type: "TSNeverKeyword"
            };
        }
        function tsNullKeyword() {
            return {
                type: "TSNullKeyword"
            };
        }
        function tsNumberKeyword() {
            return {
                type: "TSNumberKeyword"
            };
        }
        function tsObjectKeyword() {
            return {
                type: "TSObjectKeyword"
            };
        }
        function tsStringKeyword() {
            return {
                type: "TSStringKeyword"
            };
        }
        function tsSymbolKeyword() {
            return {
                type: "TSSymbolKeyword"
            };
        }
        function tsUndefinedKeyword() {
            return {
                type: "TSUndefinedKeyword"
            };
        }
        function tsUnknownKeyword() {
            return {
                type: "TSUnknownKeyword"
            };
        }
        function tsVoidKeyword() {
            return {
                type: "TSVoidKeyword"
            };
        }
        function tsThisType() {
            return {
                type: "TSThisType"
            };
        }
        function tsFunctionType() {
            var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var parameters = arguments.length > 1 ? arguments[1] : void 0;
            var typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TSFunctionType",
                typeParameters: typeParameters,
                parameters: parameters,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSFunctionType;
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.parameters, node, "parameters", parameters, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsConstructorType() {
            var typeParameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var parameters = arguments.length > 1 ? arguments[1] : void 0;
            var typeAnnotation2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TSConstructorType",
                typeParameters: typeParameters,
                parameters: parameters,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSConstructorType;
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.parameters, node, "parameters", parameters, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsTypeReference(typeName) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "TSTypeReference",
                typeName: typeName,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.TSTypeReference;
            validate(defs.typeName, node, "typeName", typeName, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function tsTypePredicate(parameterName) {
            var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var asserts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TSTypePredicate",
                parameterName: parameterName,
                typeAnnotation: typeAnnotation2,
                asserts: asserts
            };
            var defs = NODE_FIELDS.TSTypePredicate;
            validate(defs.parameterName, node, "parameterName", parameterName, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            validate(defs.asserts, node, "asserts", asserts);
            return node;
        }
        function tsTypeQuery(exprName) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "TSTypeQuery",
                exprName: exprName,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.TSTypeQuery;
            validate(defs.exprName, node, "exprName", exprName, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function tsTypeLiteral(members) {
            var node = {
                type: "TSTypeLiteral",
                members: members
            };
            var defs = NODE_FIELDS.TSTypeLiteral;
            validate(defs.members, node, "members", members, 1);
            return node;
        }
        function tsArrayType(elementType) {
            var node = {
                type: "TSArrayType",
                elementType: elementType
            };
            var defs = NODE_FIELDS.TSArrayType;
            validate(defs.elementType, node, "elementType", elementType, 1);
            return node;
        }
        function tsTupleType(elementTypes) {
            var node = {
                type: "TSTupleType",
                elementTypes: elementTypes
            };
            var defs = NODE_FIELDS.TSTupleType;
            validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
            return node;
        }
        function tsOptionalType(typeAnnotation2) {
            var node = {
                type: "TSOptionalType",
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSOptionalType;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsRestType(typeAnnotation2) {
            var node = {
                type: "TSRestType",
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSRestType;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsNamedTupleMember(label, elementType) {
            var optional = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var node = {
                type: "TSNamedTupleMember",
                label: label,
                elementType: elementType,
                optional: optional
            };
            var defs = NODE_FIELDS.TSNamedTupleMember;
            validate(defs.label, node, "label", label, 1);
            validate(defs.elementType, node, "elementType", elementType, 1);
            validate(defs.optional, node, "optional", optional);
            return node;
        }
        function tsUnionType(types) {
            var node = {
                type: "TSUnionType",
                types: types
            };
            var defs = NODE_FIELDS.TSUnionType;
            validate(defs.types, node, "types", types, 1);
            return node;
        }
        function tsIntersectionType(types) {
            var node = {
                type: "TSIntersectionType",
                types: types
            };
            var defs = NODE_FIELDS.TSIntersectionType;
            validate(defs.types, node, "types", types, 1);
            return node;
        }
        function tsConditionalType(checkType, extendsType, trueType, falseType) {
            var node = {
                type: "TSConditionalType",
                checkType: checkType,
                extendsType: extendsType,
                trueType: trueType,
                falseType: falseType
            };
            var defs = NODE_FIELDS.TSConditionalType;
            validate(defs.checkType, node, "checkType", checkType, 1);
            validate(defs.extendsType, node, "extendsType", extendsType, 1);
            validate(defs.trueType, node, "trueType", trueType, 1);
            validate(defs.falseType, node, "falseType", falseType, 1);
            return node;
        }
        function tsInferType(typeParameter2) {
            var node = {
                type: "TSInferType",
                typeParameter: typeParameter2
            };
            var defs = NODE_FIELDS.TSInferType;
            validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
            return node;
        }
        function tsParenthesizedType(typeAnnotation2) {
            var node = {
                type: "TSParenthesizedType",
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSParenthesizedType;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsTypeOperator(typeAnnotation2) {
            var node = {
                type: "TSTypeOperator",
                typeAnnotation: typeAnnotation2,
                operator: null
            };
            var defs = NODE_FIELDS.TSTypeOperator;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsIndexedAccessType(objectType, indexType) {
            var node = {
                type: "TSIndexedAccessType",
                objectType: objectType,
                indexType: indexType
            };
            var defs = NODE_FIELDS.TSIndexedAccessType;
            validate(defs.objectType, node, "objectType", objectType, 1);
            validate(defs.indexType, node, "indexType", indexType, 1);
            return node;
        }
        function tsMappedType(typeParameter2) {
            var typeAnnotation2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var nameType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TSMappedType",
                typeParameter: typeParameter2,
                typeAnnotation: typeAnnotation2,
                nameType: nameType
            };
            var defs = NODE_FIELDS.TSMappedType;
            validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            validate(defs.nameType, node, "nameType", nameType, 1);
            return node;
        }
        function tsLiteralType(literal) {
            var node = {
                type: "TSLiteralType",
                literal: literal
            };
            var defs = NODE_FIELDS.TSLiteralType;
            validate(defs.literal, node, "literal", literal, 1);
            return node;
        }
        function tsExpressionWithTypeArguments(expression) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "TSExpressionWithTypeArguments",
                expression: expression,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.TSExpressionWithTypeArguments;
            validate(defs.expression, node, "expression", expression, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function tsInterfaceDeclaration(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var _extends = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var body3 = arguments.length > 3 ? arguments[3] : void 0;
            var node = {
                type: "TSInterfaceDeclaration",
                id: id,
                typeParameters: typeParameters,
                extends: _extends,
                body: body3
            };
            var defs = NODE_FIELDS.TSInterfaceDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.extends, node, "extends", _extends, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function tsInterfaceBody(body3) {
            var node = {
                type: "TSInterfaceBody",
                body: body3
            };
            var defs = NODE_FIELDS.TSInterfaceBody;
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function tsTypeAliasDeclaration(id) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var typeAnnotation2 = arguments.length > 2 ? arguments[2] : void 0;
            var node = {
                type: "TSTypeAliasDeclaration",
                id: id,
                typeParameters: typeParameters,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSTypeAliasDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsInstantiationExpression(expression) {
            var typeParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "TSInstantiationExpression",
                expression: expression,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.TSInstantiationExpression;
            validate(defs.expression, node, "expression", expression, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function tsAsExpression(expression, typeAnnotation2) {
            var node = {
                type: "TSAsExpression",
                expression: expression,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSAsExpression;
            validate(defs.expression, node, "expression", expression, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsSatisfiesExpression(expression, typeAnnotation2) {
            var node = {
                type: "TSSatisfiesExpression",
                expression: expression,
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSSatisfiesExpression;
            validate(defs.expression, node, "expression", expression, 1);
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsTypeAssertion(typeAnnotation2, expression) {
            var node = {
                type: "TSTypeAssertion",
                typeAnnotation: typeAnnotation2,
                expression: expression
            };
            var defs = NODE_FIELDS.TSTypeAssertion;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function tsEnumDeclaration(id, members) {
            var node = {
                type: "TSEnumDeclaration",
                id: id,
                members: members
            };
            var defs = NODE_FIELDS.TSEnumDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.members, node, "members", members, 1);
            return node;
        }
        function tsEnumMember(id) {
            var initializer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var node = {
                type: "TSEnumMember",
                id: id,
                initializer: initializer
            };
            var defs = NODE_FIELDS.TSEnumMember;
            validate(defs.id, node, "id", id, 1);
            validate(defs.initializer, node, "initializer", initializer, 1);
            return node;
        }
        function tsModuleDeclaration(id, body3) {
            var node = {
                type: "TSModuleDeclaration",
                id: id,
                body: body3,
                kind: null
            };
            var defs = NODE_FIELDS.TSModuleDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function tsModuleBlock(body3) {
            var node = {
                type: "TSModuleBlock",
                body: body3
            };
            var defs = NODE_FIELDS.TSModuleBlock;
            validate(defs.body, node, "body", body3, 1);
            return node;
        }
        function tsImportType(argument) {
            var qualifier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var typeParameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var node = {
                type: "TSImportType",
                argument: argument,
                qualifier: qualifier,
                typeParameters: typeParameters
            };
            var defs = NODE_FIELDS.TSImportType;
            validate(defs.argument, node, "argument", argument, 1);
            validate(defs.qualifier, node, "qualifier", qualifier, 1);
            validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
            return node;
        }
        function tsImportEqualsDeclaration(id, moduleReference) {
            var node = {
                type: "TSImportEqualsDeclaration",
                id: id,
                moduleReference: moduleReference,
                isExport: null
            };
            var defs = NODE_FIELDS.TSImportEqualsDeclaration;
            validate(defs.id, node, "id", id, 1);
            validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
            return node;
        }
        function tsExternalModuleReference(expression) {
            var node = {
                type: "TSExternalModuleReference",
                expression: expression
            };
            var defs = NODE_FIELDS.TSExternalModuleReference;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function tsNonNullExpression(expression) {
            var node = {
                type: "TSNonNullExpression",
                expression: expression
            };
            var defs = NODE_FIELDS.TSNonNullExpression;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function tsExportAssignment(expression) {
            var node = {
                type: "TSExportAssignment",
                expression: expression
            };
            var defs = NODE_FIELDS.TSExportAssignment;
            validate(defs.expression, node, "expression", expression, 1);
            return node;
        }
        function tsNamespaceExportDeclaration(id) {
            var node = {
                type: "TSNamespaceExportDeclaration",
                id: id
            };
            var defs = NODE_FIELDS.TSNamespaceExportDeclaration;
            validate(defs.id, node, "id", id, 1);
            return node;
        }
        function tsTypeAnnotation(typeAnnotation2) {
            var node = {
                type: "TSTypeAnnotation",
                typeAnnotation: typeAnnotation2
            };
            var defs = NODE_FIELDS.TSTypeAnnotation;
            validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
            return node;
        }
        function tsTypeParameterInstantiation(params) {
            var node = {
                type: "TSTypeParameterInstantiation",
                params: params
            };
            var defs = NODE_FIELDS.TSTypeParameterInstantiation;
            validate(defs.params, node, "params", params, 1);
            return node;
        }
        function tsTypeParameterDeclaration(params) {
            var node = {
                type: "TSTypeParameterDeclaration",
                params: params
            };
            var defs = NODE_FIELDS.TSTypeParameterDeclaration;
            validate(defs.params, node, "params", params, 1);
            return node;
        }
        function tsTypeParameter() {
            var constraint = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            var _default = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var name = arguments.length > 2 ? arguments[2] : void 0;
            var node = {
                type: "TSTypeParameter",
                constraint: constraint,
                default: _default,
                name: name
            };
            var defs = NODE_FIELDS.TSTypeParameter;
            validate(defs.constraint, node, "constraint", constraint, 1);
            validate(defs.default, node, "default", _default, 1);
            validate(defs.name, node, "name", name);
            return node;
        }
        function NumberLiteral(value) {
            (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
            return numericLiteral(value);
        }
        function RegexLiteral(pattern) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
            return regExpLiteral(pattern, flags);
        }
        function RestProperty(argument) {
            (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
            return restElement(argument);
        }
        function SpreadProperty(argument) {
            (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
            return spreadElement(argument);
        }
    }
});
// ../../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
    "../../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = cleanJSXElementLiteralChild;
        var _index = require_generated2();
        var _index2 = require_lib4();
        function cleanJSXElementLiteralChild(child, args) {
            var lines = child.value.split(/\r\n|\n|\r/);
            var lastNonEmptyLine = 0;
            for(var i = 0; i < lines.length; i++){
                if (/[^ \t]/.exec(lines[i])) {
                    lastNonEmptyLine = i;
                }
            }
            var str = "";
            for(var _i = 0; _i < lines.length; _i++){
                var line = lines[_i];
                var isFirstLine = _i === 0;
                var isLastLine = _i === lines.length - 1;
                var isLastNonEmptyLine = _i === lastNonEmptyLine;
                var trimmedLine = line.replace(/\t/g, " ");
                if (!isFirstLine) {
                    trimmedLine = trimmedLine.replace(/^ +/, "");
                }
                if (!isLastLine) {
                    trimmedLine = trimmedLine.replace(/ +$/, "");
                }
                if (trimmedLine) {
                    if (!isLastNonEmptyLine) {
                        trimmedLine += " ";
                    }
                    str += trimmedLine;
                }
            }
            if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
        }
    }
});
// ../../node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
    "../../node_modules/@babel/types/lib/builders/react/buildChildren.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = buildChildren;
        var _index = require_generated();
        var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
        function buildChildren(node) {
            var elements = [];
            for(var i = 0; i < node.children.length; i++){
                var child = node.children[i];
                if ((0, _index.isJSXText)(child)) {
                    (0, _cleanJSXElementLiteralChild.default)(child, elements);
                    continue;
                }
                if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
                if ((0, _index.isJSXEmptyExpression)(child)) continue;
                elements.push(child);
            }
            return elements;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isNode.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isNode;
        var _index = require_definitions();
        function isNode(node) {
            return !!(node && _index.VISITOR_KEYS[node.type]);
        }
    }
});
// ../../node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
    "../../node_modules/@babel/types/lib/asserts/assertNode.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = assertNode;
        var _isNode = require_isNode();
        function assertNode(node) {
            if (!(0, _isNode.default)(node)) {
                var _node$type;
                var type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
                throw new TypeError('Not a valid node of type "'.concat(type, '"'));
            }
        }
    }
});
// ../../node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
    "../../node_modules/@babel/types/lib/asserts/generated/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.assertAccessor = assertAccessor;
        exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
        exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
        exports.assertArrayExpression = assertArrayExpression;
        exports.assertArrayPattern = assertArrayPattern;
        exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
        exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
        exports.assertAssignmentExpression = assertAssignmentExpression;
        exports.assertAssignmentPattern = assertAssignmentPattern;
        exports.assertAwaitExpression = assertAwaitExpression;
        exports.assertBigIntLiteral = assertBigIntLiteral;
        exports.assertBinary = assertBinary;
        exports.assertBinaryExpression = assertBinaryExpression;
        exports.assertBindExpression = assertBindExpression;
        exports.assertBlock = assertBlock;
        exports.assertBlockParent = assertBlockParent;
        exports.assertBlockStatement = assertBlockStatement;
        exports.assertBooleanLiteral = assertBooleanLiteral;
        exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
        exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
        exports.assertBreakStatement = assertBreakStatement;
        exports.assertCallExpression = assertCallExpression;
        exports.assertCatchClause = assertCatchClause;
        exports.assertClass = assertClass;
        exports.assertClassAccessorProperty = assertClassAccessorProperty;
        exports.assertClassBody = assertClassBody;
        exports.assertClassDeclaration = assertClassDeclaration;
        exports.assertClassExpression = assertClassExpression;
        exports.assertClassImplements = assertClassImplements;
        exports.assertClassMethod = assertClassMethod;
        exports.assertClassPrivateMethod = assertClassPrivateMethod;
        exports.assertClassPrivateProperty = assertClassPrivateProperty;
        exports.assertClassProperty = assertClassProperty;
        exports.assertCompletionStatement = assertCompletionStatement;
        exports.assertConditional = assertConditional;
        exports.assertConditionalExpression = assertConditionalExpression;
        exports.assertContinueStatement = assertContinueStatement;
        exports.assertDebuggerStatement = assertDebuggerStatement;
        exports.assertDecimalLiteral = assertDecimalLiteral;
        exports.assertDeclaration = assertDeclaration;
        exports.assertDeclareClass = assertDeclareClass;
        exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
        exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
        exports.assertDeclareFunction = assertDeclareFunction;
        exports.assertDeclareInterface = assertDeclareInterface;
        exports.assertDeclareModule = assertDeclareModule;
        exports.assertDeclareModuleExports = assertDeclareModuleExports;
        exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
        exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
        exports.assertDeclareVariable = assertDeclareVariable;
        exports.assertDeclaredPredicate = assertDeclaredPredicate;
        exports.assertDecorator = assertDecorator;
        exports.assertDirective = assertDirective;
        exports.assertDirectiveLiteral = assertDirectiveLiteral;
        exports.assertDoExpression = assertDoExpression;
        exports.assertDoWhileStatement = assertDoWhileStatement;
        exports.assertEmptyStatement = assertEmptyStatement;
        exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
        exports.assertEnumBody = assertEnumBody;
        exports.assertEnumBooleanBody = assertEnumBooleanBody;
        exports.assertEnumBooleanMember = assertEnumBooleanMember;
        exports.assertEnumDeclaration = assertEnumDeclaration;
        exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
        exports.assertEnumMember = assertEnumMember;
        exports.assertEnumNumberBody = assertEnumNumberBody;
        exports.assertEnumNumberMember = assertEnumNumberMember;
        exports.assertEnumStringBody = assertEnumStringBody;
        exports.assertEnumStringMember = assertEnumStringMember;
        exports.assertEnumSymbolBody = assertEnumSymbolBody;
        exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
        exports.assertExportAllDeclaration = assertExportAllDeclaration;
        exports.assertExportDeclaration = assertExportDeclaration;
        exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
        exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
        exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
        exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
        exports.assertExportSpecifier = assertExportSpecifier;
        exports.assertExpression = assertExpression;
        exports.assertExpressionStatement = assertExpressionStatement;
        exports.assertExpressionWrapper = assertExpressionWrapper;
        exports.assertFile = assertFile;
        exports.assertFlow = assertFlow;
        exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
        exports.assertFlowDeclaration = assertFlowDeclaration;
        exports.assertFlowPredicate = assertFlowPredicate;
        exports.assertFlowType = assertFlowType;
        exports.assertFor = assertFor;
        exports.assertForInStatement = assertForInStatement;
        exports.assertForOfStatement = assertForOfStatement;
        exports.assertForStatement = assertForStatement;
        exports.assertForXStatement = assertForXStatement;
        exports.assertFunction = assertFunction;
        exports.assertFunctionDeclaration = assertFunctionDeclaration;
        exports.assertFunctionExpression = assertFunctionExpression;
        exports.assertFunctionParent = assertFunctionParent;
        exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
        exports.assertFunctionTypeParam = assertFunctionTypeParam;
        exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
        exports.assertIdentifier = assertIdentifier;
        exports.assertIfStatement = assertIfStatement;
        exports.assertImmutable = assertImmutable;
        exports.assertImport = assertImport;
        exports.assertImportAttribute = assertImportAttribute;
        exports.assertImportDeclaration = assertImportDeclaration;
        exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
        exports.assertImportExpression = assertImportExpression;
        exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
        exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
        exports.assertImportSpecifier = assertImportSpecifier;
        exports.assertIndexedAccessType = assertIndexedAccessType;
        exports.assertInferredPredicate = assertInferredPredicate;
        exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
        exports.assertInterfaceExtends = assertInterfaceExtends;
        exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
        exports.assertInterpreterDirective = assertInterpreterDirective;
        exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
        exports.assertJSX = assertJSX;
        exports.assertJSXAttribute = assertJSXAttribute;
        exports.assertJSXClosingElement = assertJSXClosingElement;
        exports.assertJSXClosingFragment = assertJSXClosingFragment;
        exports.assertJSXElement = assertJSXElement;
        exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
        exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
        exports.assertJSXFragment = assertJSXFragment;
        exports.assertJSXIdentifier = assertJSXIdentifier;
        exports.assertJSXMemberExpression = assertJSXMemberExpression;
        exports.assertJSXNamespacedName = assertJSXNamespacedName;
        exports.assertJSXOpeningElement = assertJSXOpeningElement;
        exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
        exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
        exports.assertJSXSpreadChild = assertJSXSpreadChild;
        exports.assertJSXText = assertJSXText;
        exports.assertLVal = assertLVal;
        exports.assertLabeledStatement = assertLabeledStatement;
        exports.assertLiteral = assertLiteral;
        exports.assertLogicalExpression = assertLogicalExpression;
        exports.assertLoop = assertLoop;
        exports.assertMemberExpression = assertMemberExpression;
        exports.assertMetaProperty = assertMetaProperty;
        exports.assertMethod = assertMethod;
        exports.assertMiscellaneous = assertMiscellaneous;
        exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
        exports.assertModuleDeclaration = assertModuleDeclaration;
        exports.assertModuleExpression = assertModuleExpression;
        exports.assertModuleSpecifier = assertModuleSpecifier;
        exports.assertNewExpression = assertNewExpression;
        exports.assertNoop = assertNoop;
        exports.assertNullLiteral = assertNullLiteral;
        exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
        exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
        exports.assertNumberLiteral = assertNumberLiteral;
        exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
        exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
        exports.assertNumericLiteral = assertNumericLiteral;
        exports.assertObjectExpression = assertObjectExpression;
        exports.assertObjectMember = assertObjectMember;
        exports.assertObjectMethod = assertObjectMethod;
        exports.assertObjectPattern = assertObjectPattern;
        exports.assertObjectProperty = assertObjectProperty;
        exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
        exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
        exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
        exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
        exports.assertObjectTypeProperty = assertObjectTypeProperty;
        exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
        exports.assertOpaqueType = assertOpaqueType;
        exports.assertOptionalCallExpression = assertOptionalCallExpression;
        exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
        exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
        exports.assertParenthesizedExpression = assertParenthesizedExpression;
        exports.assertPattern = assertPattern;
        exports.assertPatternLike = assertPatternLike;
        exports.assertPipelineBareFunction = assertPipelineBareFunction;
        exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
        exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
        exports.assertPlaceholder = assertPlaceholder;
        exports.assertPrivate = assertPrivate;
        exports.assertPrivateName = assertPrivateName;
        exports.assertProgram = assertProgram;
        exports.assertProperty = assertProperty;
        exports.assertPureish = assertPureish;
        exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
        exports.assertRecordExpression = assertRecordExpression;
        exports.assertRegExpLiteral = assertRegExpLiteral;
        exports.assertRegexLiteral = assertRegexLiteral;
        exports.assertRestElement = assertRestElement;
        exports.assertRestProperty = assertRestProperty;
        exports.assertReturnStatement = assertReturnStatement;
        exports.assertScopable = assertScopable;
        exports.assertSequenceExpression = assertSequenceExpression;
        exports.assertSpreadElement = assertSpreadElement;
        exports.assertSpreadProperty = assertSpreadProperty;
        exports.assertStandardized = assertStandardized;
        exports.assertStatement = assertStatement;
        exports.assertStaticBlock = assertStaticBlock;
        exports.assertStringLiteral = assertStringLiteral;
        exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
        exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
        exports.assertSuper = assertSuper;
        exports.assertSwitchCase = assertSwitchCase;
        exports.assertSwitchStatement = assertSwitchStatement;
        exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
        exports.assertTSAnyKeyword = assertTSAnyKeyword;
        exports.assertTSArrayType = assertTSArrayType;
        exports.assertTSAsExpression = assertTSAsExpression;
        exports.assertTSBaseType = assertTSBaseType;
        exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
        exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
        exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
        exports.assertTSConditionalType = assertTSConditionalType;
        exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
        exports.assertTSConstructorType = assertTSConstructorType;
        exports.assertTSDeclareFunction = assertTSDeclareFunction;
        exports.assertTSDeclareMethod = assertTSDeclareMethod;
        exports.assertTSEntityName = assertTSEntityName;
        exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
        exports.assertTSEnumMember = assertTSEnumMember;
        exports.assertTSExportAssignment = assertTSExportAssignment;
        exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
        exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
        exports.assertTSFunctionType = assertTSFunctionType;
        exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
        exports.assertTSImportType = assertTSImportType;
        exports.assertTSIndexSignature = assertTSIndexSignature;
        exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
        exports.assertTSInferType = assertTSInferType;
        exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
        exports.assertTSInterfaceBody = assertTSInterfaceBody;
        exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
        exports.assertTSIntersectionType = assertTSIntersectionType;
        exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
        exports.assertTSLiteralType = assertTSLiteralType;
        exports.assertTSMappedType = assertTSMappedType;
        exports.assertTSMethodSignature = assertTSMethodSignature;
        exports.assertTSModuleBlock = assertTSModuleBlock;
        exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
        exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
        exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
        exports.assertTSNeverKeyword = assertTSNeverKeyword;
        exports.assertTSNonNullExpression = assertTSNonNullExpression;
        exports.assertTSNullKeyword = assertTSNullKeyword;
        exports.assertTSNumberKeyword = assertTSNumberKeyword;
        exports.assertTSObjectKeyword = assertTSObjectKeyword;
        exports.assertTSOptionalType = assertTSOptionalType;
        exports.assertTSParameterProperty = assertTSParameterProperty;
        exports.assertTSParenthesizedType = assertTSParenthesizedType;
        exports.assertTSPropertySignature = assertTSPropertySignature;
        exports.assertTSQualifiedName = assertTSQualifiedName;
        exports.assertTSRestType = assertTSRestType;
        exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
        exports.assertTSStringKeyword = assertTSStringKeyword;
        exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
        exports.assertTSThisType = assertTSThisType;
        exports.assertTSTupleType = assertTSTupleType;
        exports.assertTSType = assertTSType;
        exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
        exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
        exports.assertTSTypeAssertion = assertTSTypeAssertion;
        exports.assertTSTypeElement = assertTSTypeElement;
        exports.assertTSTypeLiteral = assertTSTypeLiteral;
        exports.assertTSTypeOperator = assertTSTypeOperator;
        exports.assertTSTypeParameter = assertTSTypeParameter;
        exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
        exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
        exports.assertTSTypePredicate = assertTSTypePredicate;
        exports.assertTSTypeQuery = assertTSTypeQuery;
        exports.assertTSTypeReference = assertTSTypeReference;
        exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
        exports.assertTSUnionType = assertTSUnionType;
        exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
        exports.assertTSVoidKeyword = assertTSVoidKeyword;
        exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
        exports.assertTemplateElement = assertTemplateElement;
        exports.assertTemplateLiteral = assertTemplateLiteral;
        exports.assertTerminatorless = assertTerminatorless;
        exports.assertThisExpression = assertThisExpression;
        exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
        exports.assertThrowStatement = assertThrowStatement;
        exports.assertTopicReference = assertTopicReference;
        exports.assertTryStatement = assertTryStatement;
        exports.assertTupleExpression = assertTupleExpression;
        exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
        exports.assertTypeAlias = assertTypeAlias;
        exports.assertTypeAnnotation = assertTypeAnnotation;
        exports.assertTypeCastExpression = assertTypeCastExpression;
        exports.assertTypeParameter = assertTypeParameter;
        exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
        exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
        exports.assertTypeScript = assertTypeScript;
        exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
        exports.assertUnaryExpression = assertUnaryExpression;
        exports.assertUnaryLike = assertUnaryLike;
        exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
        exports.assertUpdateExpression = assertUpdateExpression;
        exports.assertUserWhitespacable = assertUserWhitespacable;
        exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
        exports.assertVariableDeclaration = assertVariableDeclaration;
        exports.assertVariableDeclarator = assertVariableDeclarator;
        exports.assertVariance = assertVariance;
        exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
        exports.assertWhile = assertWhile;
        exports.assertWhileStatement = assertWhileStatement;
        exports.assertWithStatement = assertWithStatement;
        exports.assertYieldExpression = assertYieldExpression;
        var _is = require_is();
        var _deprecationWarning = require_deprecationWarning();
        function assert(type, node, opts) {
            if (!(0, _is.default)(type, node, opts)) {
                throw new Error('Expected type "'.concat(type, '" with option ').concat(JSON.stringify(opts), ", ") + 'but instead got "'.concat(node.type, '".'));
            }
        }
        function assertArrayExpression(node, opts) {
            assert("ArrayExpression", node, opts);
        }
        function assertAssignmentExpression(node, opts) {
            assert("AssignmentExpression", node, opts);
        }
        function assertBinaryExpression(node, opts) {
            assert("BinaryExpression", node, opts);
        }
        function assertInterpreterDirective(node, opts) {
            assert("InterpreterDirective", node, opts);
        }
        function assertDirective(node, opts) {
            assert("Directive", node, opts);
        }
        function assertDirectiveLiteral(node, opts) {
            assert("DirectiveLiteral", node, opts);
        }
        function assertBlockStatement(node, opts) {
            assert("BlockStatement", node, opts);
        }
        function assertBreakStatement(node, opts) {
            assert("BreakStatement", node, opts);
        }
        function assertCallExpression(node, opts) {
            assert("CallExpression", node, opts);
        }
        function assertCatchClause(node, opts) {
            assert("CatchClause", node, opts);
        }
        function assertConditionalExpression(node, opts) {
            assert("ConditionalExpression", node, opts);
        }
        function assertContinueStatement(node, opts) {
            assert("ContinueStatement", node, opts);
        }
        function assertDebuggerStatement(node, opts) {
            assert("DebuggerStatement", node, opts);
        }
        function assertDoWhileStatement(node, opts) {
            assert("DoWhileStatement", node, opts);
        }
        function assertEmptyStatement(node, opts) {
            assert("EmptyStatement", node, opts);
        }
        function assertExpressionStatement(node, opts) {
            assert("ExpressionStatement", node, opts);
        }
        function assertFile(node, opts) {
            assert("File", node, opts);
        }
        function assertForInStatement(node, opts) {
            assert("ForInStatement", node, opts);
        }
        function assertForStatement(node, opts) {
            assert("ForStatement", node, opts);
        }
        function assertFunctionDeclaration(node, opts) {
            assert("FunctionDeclaration", node, opts);
        }
        function assertFunctionExpression(node, opts) {
            assert("FunctionExpression", node, opts);
        }
        function assertIdentifier(node, opts) {
            assert("Identifier", node, opts);
        }
        function assertIfStatement(node, opts) {
            assert("IfStatement", node, opts);
        }
        function assertLabeledStatement(node, opts) {
            assert("LabeledStatement", node, opts);
        }
        function assertStringLiteral(node, opts) {
            assert("StringLiteral", node, opts);
        }
        function assertNumericLiteral(node, opts) {
            assert("NumericLiteral", node, opts);
        }
        function assertNullLiteral(node, opts) {
            assert("NullLiteral", node, opts);
        }
        function assertBooleanLiteral(node, opts) {
            assert("BooleanLiteral", node, opts);
        }
        function assertRegExpLiteral(node, opts) {
            assert("RegExpLiteral", node, opts);
        }
        function assertLogicalExpression(node, opts) {
            assert("LogicalExpression", node, opts);
        }
        function assertMemberExpression(node, opts) {
            assert("MemberExpression", node, opts);
        }
        function assertNewExpression(node, opts) {
            assert("NewExpression", node, opts);
        }
        function assertProgram(node, opts) {
            assert("Program", node, opts);
        }
        function assertObjectExpression(node, opts) {
            assert("ObjectExpression", node, opts);
        }
        function assertObjectMethod(node, opts) {
            assert("ObjectMethod", node, opts);
        }
        function assertObjectProperty(node, opts) {
            assert("ObjectProperty", node, opts);
        }
        function assertRestElement(node, opts) {
            assert("RestElement", node, opts);
        }
        function assertReturnStatement(node, opts) {
            assert("ReturnStatement", node, opts);
        }
        function assertSequenceExpression(node, opts) {
            assert("SequenceExpression", node, opts);
        }
        function assertParenthesizedExpression(node, opts) {
            assert("ParenthesizedExpression", node, opts);
        }
        function assertSwitchCase(node, opts) {
            assert("SwitchCase", node, opts);
        }
        function assertSwitchStatement(node, opts) {
            assert("SwitchStatement", node, opts);
        }
        function assertThisExpression(node, opts) {
            assert("ThisExpression", node, opts);
        }
        function assertThrowStatement(node, opts) {
            assert("ThrowStatement", node, opts);
        }
        function assertTryStatement(node, opts) {
            assert("TryStatement", node, opts);
        }
        function assertUnaryExpression(node, opts) {
            assert("UnaryExpression", node, opts);
        }
        function assertUpdateExpression(node, opts) {
            assert("UpdateExpression", node, opts);
        }
        function assertVariableDeclaration(node, opts) {
            assert("VariableDeclaration", node, opts);
        }
        function assertVariableDeclarator(node, opts) {
            assert("VariableDeclarator", node, opts);
        }
        function assertWhileStatement(node, opts) {
            assert("WhileStatement", node, opts);
        }
        function assertWithStatement(node, opts) {
            assert("WithStatement", node, opts);
        }
        function assertAssignmentPattern(node, opts) {
            assert("AssignmentPattern", node, opts);
        }
        function assertArrayPattern(node, opts) {
            assert("ArrayPattern", node, opts);
        }
        function assertArrowFunctionExpression(node, opts) {
            assert("ArrowFunctionExpression", node, opts);
        }
        function assertClassBody(node, opts) {
            assert("ClassBody", node, opts);
        }
        function assertClassExpression(node, opts) {
            assert("ClassExpression", node, opts);
        }
        function assertClassDeclaration(node, opts) {
            assert("ClassDeclaration", node, opts);
        }
        function assertExportAllDeclaration(node, opts) {
            assert("ExportAllDeclaration", node, opts);
        }
        function assertExportDefaultDeclaration(node, opts) {
            assert("ExportDefaultDeclaration", node, opts);
        }
        function assertExportNamedDeclaration(node, opts) {
            assert("ExportNamedDeclaration", node, opts);
        }
        function assertExportSpecifier(node, opts) {
            assert("ExportSpecifier", node, opts);
        }
        function assertForOfStatement(node, opts) {
            assert("ForOfStatement", node, opts);
        }
        function assertImportDeclaration(node, opts) {
            assert("ImportDeclaration", node, opts);
        }
        function assertImportDefaultSpecifier(node, opts) {
            assert("ImportDefaultSpecifier", node, opts);
        }
        function assertImportNamespaceSpecifier(node, opts) {
            assert("ImportNamespaceSpecifier", node, opts);
        }
        function assertImportSpecifier(node, opts) {
            assert("ImportSpecifier", node, opts);
        }
        function assertImportExpression(node, opts) {
            assert("ImportExpression", node, opts);
        }
        function assertMetaProperty(node, opts) {
            assert("MetaProperty", node, opts);
        }
        function assertClassMethod(node, opts) {
            assert("ClassMethod", node, opts);
        }
        function assertObjectPattern(node, opts) {
            assert("ObjectPattern", node, opts);
        }
        function assertSpreadElement(node, opts) {
            assert("SpreadElement", node, opts);
        }
        function assertSuper(node, opts) {
            assert("Super", node, opts);
        }
        function assertTaggedTemplateExpression(node, opts) {
            assert("TaggedTemplateExpression", node, opts);
        }
        function assertTemplateElement(node, opts) {
            assert("TemplateElement", node, opts);
        }
        function assertTemplateLiteral(node, opts) {
            assert("TemplateLiteral", node, opts);
        }
        function assertYieldExpression(node, opts) {
            assert("YieldExpression", node, opts);
        }
        function assertAwaitExpression(node, opts) {
            assert("AwaitExpression", node, opts);
        }
        function assertImport(node, opts) {
            assert("Import", node, opts);
        }
        function assertBigIntLiteral(node, opts) {
            assert("BigIntLiteral", node, opts);
        }
        function assertExportNamespaceSpecifier(node, opts) {
            assert("ExportNamespaceSpecifier", node, opts);
        }
        function assertOptionalMemberExpression(node, opts) {
            assert("OptionalMemberExpression", node, opts);
        }
        function assertOptionalCallExpression(node, opts) {
            assert("OptionalCallExpression", node, opts);
        }
        function assertClassProperty(node, opts) {
            assert("ClassProperty", node, opts);
        }
        function assertClassAccessorProperty(node, opts) {
            assert("ClassAccessorProperty", node, opts);
        }
        function assertClassPrivateProperty(node, opts) {
            assert("ClassPrivateProperty", node, opts);
        }
        function assertClassPrivateMethod(node, opts) {
            assert("ClassPrivateMethod", node, opts);
        }
        function assertPrivateName(node, opts) {
            assert("PrivateName", node, opts);
        }
        function assertStaticBlock(node, opts) {
            assert("StaticBlock", node, opts);
        }
        function assertAnyTypeAnnotation(node, opts) {
            assert("AnyTypeAnnotation", node, opts);
        }
        function assertArrayTypeAnnotation(node, opts) {
            assert("ArrayTypeAnnotation", node, opts);
        }
        function assertBooleanTypeAnnotation(node, opts) {
            assert("BooleanTypeAnnotation", node, opts);
        }
        function assertBooleanLiteralTypeAnnotation(node, opts) {
            assert("BooleanLiteralTypeAnnotation", node, opts);
        }
        function assertNullLiteralTypeAnnotation(node, opts) {
            assert("NullLiteralTypeAnnotation", node, opts);
        }
        function assertClassImplements(node, opts) {
            assert("ClassImplements", node, opts);
        }
        function assertDeclareClass(node, opts) {
            assert("DeclareClass", node, opts);
        }
        function assertDeclareFunction(node, opts) {
            assert("DeclareFunction", node, opts);
        }
        function assertDeclareInterface(node, opts) {
            assert("DeclareInterface", node, opts);
        }
        function assertDeclareModule(node, opts) {
            assert("DeclareModule", node, opts);
        }
        function assertDeclareModuleExports(node, opts) {
            assert("DeclareModuleExports", node, opts);
        }
        function assertDeclareTypeAlias(node, opts) {
            assert("DeclareTypeAlias", node, opts);
        }
        function assertDeclareOpaqueType(node, opts) {
            assert("DeclareOpaqueType", node, opts);
        }
        function assertDeclareVariable(node, opts) {
            assert("DeclareVariable", node, opts);
        }
        function assertDeclareExportDeclaration(node, opts) {
            assert("DeclareExportDeclaration", node, opts);
        }
        function assertDeclareExportAllDeclaration(node, opts) {
            assert("DeclareExportAllDeclaration", node, opts);
        }
        function assertDeclaredPredicate(node, opts) {
            assert("DeclaredPredicate", node, opts);
        }
        function assertExistsTypeAnnotation(node, opts) {
            assert("ExistsTypeAnnotation", node, opts);
        }
        function assertFunctionTypeAnnotation(node, opts) {
            assert("FunctionTypeAnnotation", node, opts);
        }
        function assertFunctionTypeParam(node, opts) {
            assert("FunctionTypeParam", node, opts);
        }
        function assertGenericTypeAnnotation(node, opts) {
            assert("GenericTypeAnnotation", node, opts);
        }
        function assertInferredPredicate(node, opts) {
            assert("InferredPredicate", node, opts);
        }
        function assertInterfaceExtends(node, opts) {
            assert("InterfaceExtends", node, opts);
        }
        function assertInterfaceDeclaration(node, opts) {
            assert("InterfaceDeclaration", node, opts);
        }
        function assertInterfaceTypeAnnotation(node, opts) {
            assert("InterfaceTypeAnnotation", node, opts);
        }
        function assertIntersectionTypeAnnotation(node, opts) {
            assert("IntersectionTypeAnnotation", node, opts);
        }
        function assertMixedTypeAnnotation(node, opts) {
            assert("MixedTypeAnnotation", node, opts);
        }
        function assertEmptyTypeAnnotation(node, opts) {
            assert("EmptyTypeAnnotation", node, opts);
        }
        function assertNullableTypeAnnotation(node, opts) {
            assert("NullableTypeAnnotation", node, opts);
        }
        function assertNumberLiteralTypeAnnotation(node, opts) {
            assert("NumberLiteralTypeAnnotation", node, opts);
        }
        function assertNumberTypeAnnotation(node, opts) {
            assert("NumberTypeAnnotation", node, opts);
        }
        function assertObjectTypeAnnotation(node, opts) {
            assert("ObjectTypeAnnotation", node, opts);
        }
        function assertObjectTypeInternalSlot(node, opts) {
            assert("ObjectTypeInternalSlot", node, opts);
        }
        function assertObjectTypeCallProperty(node, opts) {
            assert("ObjectTypeCallProperty", node, opts);
        }
        function assertObjectTypeIndexer(node, opts) {
            assert("ObjectTypeIndexer", node, opts);
        }
        function assertObjectTypeProperty(node, opts) {
            assert("ObjectTypeProperty", node, opts);
        }
        function assertObjectTypeSpreadProperty(node, opts) {
            assert("ObjectTypeSpreadProperty", node, opts);
        }
        function assertOpaqueType(node, opts) {
            assert("OpaqueType", node, opts);
        }
        function assertQualifiedTypeIdentifier(node, opts) {
            assert("QualifiedTypeIdentifier", node, opts);
        }
        function assertStringLiteralTypeAnnotation(node, opts) {
            assert("StringLiteralTypeAnnotation", node, opts);
        }
        function assertStringTypeAnnotation(node, opts) {
            assert("StringTypeAnnotation", node, opts);
        }
        function assertSymbolTypeAnnotation(node, opts) {
            assert("SymbolTypeAnnotation", node, opts);
        }
        function assertThisTypeAnnotation(node, opts) {
            assert("ThisTypeAnnotation", node, opts);
        }
        function assertTupleTypeAnnotation(node, opts) {
            assert("TupleTypeAnnotation", node, opts);
        }
        function assertTypeofTypeAnnotation(node, opts) {
            assert("TypeofTypeAnnotation", node, opts);
        }
        function assertTypeAlias(node, opts) {
            assert("TypeAlias", node, opts);
        }
        function assertTypeAnnotation(node, opts) {
            assert("TypeAnnotation", node, opts);
        }
        function assertTypeCastExpression(node, opts) {
            assert("TypeCastExpression", node, opts);
        }
        function assertTypeParameter(node, opts) {
            assert("TypeParameter", node, opts);
        }
        function assertTypeParameterDeclaration(node, opts) {
            assert("TypeParameterDeclaration", node, opts);
        }
        function assertTypeParameterInstantiation(node, opts) {
            assert("TypeParameterInstantiation", node, opts);
        }
        function assertUnionTypeAnnotation(node, opts) {
            assert("UnionTypeAnnotation", node, opts);
        }
        function assertVariance(node, opts) {
            assert("Variance", node, opts);
        }
        function assertVoidTypeAnnotation(node, opts) {
            assert("VoidTypeAnnotation", node, opts);
        }
        function assertEnumDeclaration(node, opts) {
            assert("EnumDeclaration", node, opts);
        }
        function assertEnumBooleanBody(node, opts) {
            assert("EnumBooleanBody", node, opts);
        }
        function assertEnumNumberBody(node, opts) {
            assert("EnumNumberBody", node, opts);
        }
        function assertEnumStringBody(node, opts) {
            assert("EnumStringBody", node, opts);
        }
        function assertEnumSymbolBody(node, opts) {
            assert("EnumSymbolBody", node, opts);
        }
        function assertEnumBooleanMember(node, opts) {
            assert("EnumBooleanMember", node, opts);
        }
        function assertEnumNumberMember(node, opts) {
            assert("EnumNumberMember", node, opts);
        }
        function assertEnumStringMember(node, opts) {
            assert("EnumStringMember", node, opts);
        }
        function assertEnumDefaultedMember(node, opts) {
            assert("EnumDefaultedMember", node, opts);
        }
        function assertIndexedAccessType(node, opts) {
            assert("IndexedAccessType", node, opts);
        }
        function assertOptionalIndexedAccessType(node, opts) {
            assert("OptionalIndexedAccessType", node, opts);
        }
        function assertJSXAttribute(node, opts) {
            assert("JSXAttribute", node, opts);
        }
        function assertJSXClosingElement(node, opts) {
            assert("JSXClosingElement", node, opts);
        }
        function assertJSXElement(node, opts) {
            assert("JSXElement", node, opts);
        }
        function assertJSXEmptyExpression(node, opts) {
            assert("JSXEmptyExpression", node, opts);
        }
        function assertJSXExpressionContainer(node, opts) {
            assert("JSXExpressionContainer", node, opts);
        }
        function assertJSXSpreadChild(node, opts) {
            assert("JSXSpreadChild", node, opts);
        }
        function assertJSXIdentifier(node, opts) {
            assert("JSXIdentifier", node, opts);
        }
        function assertJSXMemberExpression(node, opts) {
            assert("JSXMemberExpression", node, opts);
        }
        function assertJSXNamespacedName(node, opts) {
            assert("JSXNamespacedName", node, opts);
        }
        function assertJSXOpeningElement(node, opts) {
            assert("JSXOpeningElement", node, opts);
        }
        function assertJSXSpreadAttribute(node, opts) {
            assert("JSXSpreadAttribute", node, opts);
        }
        function assertJSXText(node, opts) {
            assert("JSXText", node, opts);
        }
        function assertJSXFragment(node, opts) {
            assert("JSXFragment", node, opts);
        }
        function assertJSXOpeningFragment(node, opts) {
            assert("JSXOpeningFragment", node, opts);
        }
        function assertJSXClosingFragment(node, opts) {
            assert("JSXClosingFragment", node, opts);
        }
        function assertNoop(node, opts) {
            assert("Noop", node, opts);
        }
        function assertPlaceholder(node, opts) {
            assert("Placeholder", node, opts);
        }
        function assertV8IntrinsicIdentifier(node, opts) {
            assert("V8IntrinsicIdentifier", node, opts);
        }
        function assertArgumentPlaceholder(node, opts) {
            assert("ArgumentPlaceholder", node, opts);
        }
        function assertBindExpression(node, opts) {
            assert("BindExpression", node, opts);
        }
        function assertImportAttribute(node, opts) {
            assert("ImportAttribute", node, opts);
        }
        function assertDecorator(node, opts) {
            assert("Decorator", node, opts);
        }
        function assertDoExpression(node, opts) {
            assert("DoExpression", node, opts);
        }
        function assertExportDefaultSpecifier(node, opts) {
            assert("ExportDefaultSpecifier", node, opts);
        }
        function assertRecordExpression(node, opts) {
            assert("RecordExpression", node, opts);
        }
        function assertTupleExpression(node, opts) {
            assert("TupleExpression", node, opts);
        }
        function assertDecimalLiteral(node, opts) {
            assert("DecimalLiteral", node, opts);
        }
        function assertModuleExpression(node, opts) {
            assert("ModuleExpression", node, opts);
        }
        function assertTopicReference(node, opts) {
            assert("TopicReference", node, opts);
        }
        function assertPipelineTopicExpression(node, opts) {
            assert("PipelineTopicExpression", node, opts);
        }
        function assertPipelineBareFunction(node, opts) {
            assert("PipelineBareFunction", node, opts);
        }
        function assertPipelinePrimaryTopicReference(node, opts) {
            assert("PipelinePrimaryTopicReference", node, opts);
        }
        function assertTSParameterProperty(node, opts) {
            assert("TSParameterProperty", node, opts);
        }
        function assertTSDeclareFunction(node, opts) {
            assert("TSDeclareFunction", node, opts);
        }
        function assertTSDeclareMethod(node, opts) {
            assert("TSDeclareMethod", node, opts);
        }
        function assertTSQualifiedName(node, opts) {
            assert("TSQualifiedName", node, opts);
        }
        function assertTSCallSignatureDeclaration(node, opts) {
            assert("TSCallSignatureDeclaration", node, opts);
        }
        function assertTSConstructSignatureDeclaration(node, opts) {
            assert("TSConstructSignatureDeclaration", node, opts);
        }
        function assertTSPropertySignature(node, opts) {
            assert("TSPropertySignature", node, opts);
        }
        function assertTSMethodSignature(node, opts) {
            assert("TSMethodSignature", node, opts);
        }
        function assertTSIndexSignature(node, opts) {
            assert("TSIndexSignature", node, opts);
        }
        function assertTSAnyKeyword(node, opts) {
            assert("TSAnyKeyword", node, opts);
        }
        function assertTSBooleanKeyword(node, opts) {
            assert("TSBooleanKeyword", node, opts);
        }
        function assertTSBigIntKeyword(node, opts) {
            assert("TSBigIntKeyword", node, opts);
        }
        function assertTSIntrinsicKeyword(node, opts) {
            assert("TSIntrinsicKeyword", node, opts);
        }
        function assertTSNeverKeyword(node, opts) {
            assert("TSNeverKeyword", node, opts);
        }
        function assertTSNullKeyword(node, opts) {
            assert("TSNullKeyword", node, opts);
        }
        function assertTSNumberKeyword(node, opts) {
            assert("TSNumberKeyword", node, opts);
        }
        function assertTSObjectKeyword(node, opts) {
            assert("TSObjectKeyword", node, opts);
        }
        function assertTSStringKeyword(node, opts) {
            assert("TSStringKeyword", node, opts);
        }
        function assertTSSymbolKeyword(node, opts) {
            assert("TSSymbolKeyword", node, opts);
        }
        function assertTSUndefinedKeyword(node, opts) {
            assert("TSUndefinedKeyword", node, opts);
        }
        function assertTSUnknownKeyword(node, opts) {
            assert("TSUnknownKeyword", node, opts);
        }
        function assertTSVoidKeyword(node, opts) {
            assert("TSVoidKeyword", node, opts);
        }
        function assertTSThisType(node, opts) {
            assert("TSThisType", node, opts);
        }
        function assertTSFunctionType(node, opts) {
            assert("TSFunctionType", node, opts);
        }
        function assertTSConstructorType(node, opts) {
            assert("TSConstructorType", node, opts);
        }
        function assertTSTypeReference(node, opts) {
            assert("TSTypeReference", node, opts);
        }
        function assertTSTypePredicate(node, opts) {
            assert("TSTypePredicate", node, opts);
        }
        function assertTSTypeQuery(node, opts) {
            assert("TSTypeQuery", node, opts);
        }
        function assertTSTypeLiteral(node, opts) {
            assert("TSTypeLiteral", node, opts);
        }
        function assertTSArrayType(node, opts) {
            assert("TSArrayType", node, opts);
        }
        function assertTSTupleType(node, opts) {
            assert("TSTupleType", node, opts);
        }
        function assertTSOptionalType(node, opts) {
            assert("TSOptionalType", node, opts);
        }
        function assertTSRestType(node, opts) {
            assert("TSRestType", node, opts);
        }
        function assertTSNamedTupleMember(node, opts) {
            assert("TSNamedTupleMember", node, opts);
        }
        function assertTSUnionType(node, opts) {
            assert("TSUnionType", node, opts);
        }
        function assertTSIntersectionType(node, opts) {
            assert("TSIntersectionType", node, opts);
        }
        function assertTSConditionalType(node, opts) {
            assert("TSConditionalType", node, opts);
        }
        function assertTSInferType(node, opts) {
            assert("TSInferType", node, opts);
        }
        function assertTSParenthesizedType(node, opts) {
            assert("TSParenthesizedType", node, opts);
        }
        function assertTSTypeOperator(node, opts) {
            assert("TSTypeOperator", node, opts);
        }
        function assertTSIndexedAccessType(node, opts) {
            assert("TSIndexedAccessType", node, opts);
        }
        function assertTSMappedType(node, opts) {
            assert("TSMappedType", node, opts);
        }
        function assertTSLiteralType(node, opts) {
            assert("TSLiteralType", node, opts);
        }
        function assertTSExpressionWithTypeArguments(node, opts) {
            assert("TSExpressionWithTypeArguments", node, opts);
        }
        function assertTSInterfaceDeclaration(node, opts) {
            assert("TSInterfaceDeclaration", node, opts);
        }
        function assertTSInterfaceBody(node, opts) {
            assert("TSInterfaceBody", node, opts);
        }
        function assertTSTypeAliasDeclaration(node, opts) {
            assert("TSTypeAliasDeclaration", node, opts);
        }
        function assertTSInstantiationExpression(node, opts) {
            assert("TSInstantiationExpression", node, opts);
        }
        function assertTSAsExpression(node, opts) {
            assert("TSAsExpression", node, opts);
        }
        function assertTSSatisfiesExpression(node, opts) {
            assert("TSSatisfiesExpression", node, opts);
        }
        function assertTSTypeAssertion(node, opts) {
            assert("TSTypeAssertion", node, opts);
        }
        function assertTSEnumDeclaration(node, opts) {
            assert("TSEnumDeclaration", node, opts);
        }
        function assertTSEnumMember(node, opts) {
            assert("TSEnumMember", node, opts);
        }
        function assertTSModuleDeclaration(node, opts) {
            assert("TSModuleDeclaration", node, opts);
        }
        function assertTSModuleBlock(node, opts) {
            assert("TSModuleBlock", node, opts);
        }
        function assertTSImportType(node, opts) {
            assert("TSImportType", node, opts);
        }
        function assertTSImportEqualsDeclaration(node, opts) {
            assert("TSImportEqualsDeclaration", node, opts);
        }
        function assertTSExternalModuleReference(node, opts) {
            assert("TSExternalModuleReference", node, opts);
        }
        function assertTSNonNullExpression(node, opts) {
            assert("TSNonNullExpression", node, opts);
        }
        function assertTSExportAssignment(node, opts) {
            assert("TSExportAssignment", node, opts);
        }
        function assertTSNamespaceExportDeclaration(node, opts) {
            assert("TSNamespaceExportDeclaration", node, opts);
        }
        function assertTSTypeAnnotation(node, opts) {
            assert("TSTypeAnnotation", node, opts);
        }
        function assertTSTypeParameterInstantiation(node, opts) {
            assert("TSTypeParameterInstantiation", node, opts);
        }
        function assertTSTypeParameterDeclaration(node, opts) {
            assert("TSTypeParameterDeclaration", node, opts);
        }
        function assertTSTypeParameter(node, opts) {
            assert("TSTypeParameter", node, opts);
        }
        function assertStandardized(node, opts) {
            assert("Standardized", node, opts);
        }
        function assertExpression(node, opts) {
            assert("Expression", node, opts);
        }
        function assertBinary(node, opts) {
            assert("Binary", node, opts);
        }
        function assertScopable(node, opts) {
            assert("Scopable", node, opts);
        }
        function assertBlockParent(node, opts) {
            assert("BlockParent", node, opts);
        }
        function assertBlock(node, opts) {
            assert("Block", node, opts);
        }
        function assertStatement(node, opts) {
            assert("Statement", node, opts);
        }
        function assertTerminatorless(node, opts) {
            assert("Terminatorless", node, opts);
        }
        function assertCompletionStatement(node, opts) {
            assert("CompletionStatement", node, opts);
        }
        function assertConditional(node, opts) {
            assert("Conditional", node, opts);
        }
        function assertLoop(node, opts) {
            assert("Loop", node, opts);
        }
        function assertWhile(node, opts) {
            assert("While", node, opts);
        }
        function assertExpressionWrapper(node, opts) {
            assert("ExpressionWrapper", node, opts);
        }
        function assertFor(node, opts) {
            assert("For", node, opts);
        }
        function assertForXStatement(node, opts) {
            assert("ForXStatement", node, opts);
        }
        function assertFunction(node, opts) {
            assert("Function", node, opts);
        }
        function assertFunctionParent(node, opts) {
            assert("FunctionParent", node, opts);
        }
        function assertPureish(node, opts) {
            assert("Pureish", node, opts);
        }
        function assertDeclaration(node, opts) {
            assert("Declaration", node, opts);
        }
        function assertPatternLike(node, opts) {
            assert("PatternLike", node, opts);
        }
        function assertLVal(node, opts) {
            assert("LVal", node, opts);
        }
        function assertTSEntityName(node, opts) {
            assert("TSEntityName", node, opts);
        }
        function assertLiteral(node, opts) {
            assert("Literal", node, opts);
        }
        function assertImmutable(node, opts) {
            assert("Immutable", node, opts);
        }
        function assertUserWhitespacable(node, opts) {
            assert("UserWhitespacable", node, opts);
        }
        function assertMethod(node, opts) {
            assert("Method", node, opts);
        }
        function assertObjectMember(node, opts) {
            assert("ObjectMember", node, opts);
        }
        function assertProperty(node, opts) {
            assert("Property", node, opts);
        }
        function assertUnaryLike(node, opts) {
            assert("UnaryLike", node, opts);
        }
        function assertPattern(node, opts) {
            assert("Pattern", node, opts);
        }
        function assertClass(node, opts) {
            assert("Class", node, opts);
        }
        function assertImportOrExportDeclaration(node, opts) {
            assert("ImportOrExportDeclaration", node, opts);
        }
        function assertExportDeclaration(node, opts) {
            assert("ExportDeclaration", node, opts);
        }
        function assertModuleSpecifier(node, opts) {
            assert("ModuleSpecifier", node, opts);
        }
        function assertAccessor(node, opts) {
            assert("Accessor", node, opts);
        }
        function assertPrivate(node, opts) {
            assert("Private", node, opts);
        }
        function assertFlow(node, opts) {
            assert("Flow", node, opts);
        }
        function assertFlowType(node, opts) {
            assert("FlowType", node, opts);
        }
        function assertFlowBaseAnnotation(node, opts) {
            assert("FlowBaseAnnotation", node, opts);
        }
        function assertFlowDeclaration(node, opts) {
            assert("FlowDeclaration", node, opts);
        }
        function assertFlowPredicate(node, opts) {
            assert("FlowPredicate", node, opts);
        }
        function assertEnumBody(node, opts) {
            assert("EnumBody", node, opts);
        }
        function assertEnumMember(node, opts) {
            assert("EnumMember", node, opts);
        }
        function assertJSX(node, opts) {
            assert("JSX", node, opts);
        }
        function assertMiscellaneous(node, opts) {
            assert("Miscellaneous", node, opts);
        }
        function assertTypeScript(node, opts) {
            assert("TypeScript", node, opts);
        }
        function assertTSTypeElement(node, opts) {
            assert("TSTypeElement", node, opts);
        }
        function assertTSType(node, opts) {
            assert("TSType", node, opts);
        }
        function assertTSBaseType(node, opts) {
            assert("TSBaseType", node, opts);
        }
        function assertNumberLiteral(node, opts) {
            (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
            assert("NumberLiteral", node, opts);
        }
        function assertRegexLiteral(node, opts) {
            (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
            assert("RegexLiteral", node, opts);
        }
        function assertRestProperty(node, opts) {
            (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
            assert("RestProperty", node, opts);
        }
        function assertSpreadProperty(node, opts) {
            (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
            assert("SpreadProperty", node, opts);
        }
        function assertModuleDeclaration(node, opts) {
            (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
            assert("ModuleDeclaration", node, opts);
        }
    }
});
// ../../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
    "../../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _index = require_generated2();
        var _default = exports.default = createTypeAnnotationBasedOnTypeof;
        function createTypeAnnotationBasedOnTypeof(type) {
            switch(type){
                case "string":
                    return (0, _index.stringTypeAnnotation)();
                case "number":
                    return (0, _index.numberTypeAnnotation)();
                case "undefined":
                    return (0, _index.voidTypeAnnotation)();
                case "boolean":
                    return (0, _index.booleanTypeAnnotation)();
                case "function":
                    return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
                case "object":
                    return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
                case "symbol":
                    return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
                case "bigint":
                    return (0, _index.anyTypeAnnotation)();
            }
            throw new Error("Invalid typeof value: " + type);
        }
    }
});
// ../../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
    "../../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = removeTypeDuplicates;
        var _index = require_generated();
        function getQualifiedName(node) {
            return (0, _index.isIdentifier)(node) ? node.name : "".concat(node.id.name, ".").concat(getQualifiedName(node.qualification));
        }
        function removeTypeDuplicates(nodesIn) {
            var nodes = Array.from(nodesIn);
            var generics = /* @__PURE__ */ new Map();
            var bases = /* @__PURE__ */ new Map();
            var typeGroups = /* @__PURE__ */ new Set();
            var types = [];
            for(var i = 0; i < nodes.length; i++){
                var node = nodes[i];
                if (!node) continue;
                if (types.includes(node)) {
                    continue;
                }
                if ((0, _index.isAnyTypeAnnotation)(node)) {
                    return [
                        node
                    ];
                }
                if ((0, _index.isFlowBaseAnnotation)(node)) {
                    bases.set(node.type, node);
                    continue;
                }
                if ((0, _index.isUnionTypeAnnotation)(node)) {
                    if (!typeGroups.has(node.types)) {
                        var _nodes;
                        (_nodes = nodes).push.apply(_nodes, _to_consumable_array(node.types));
                        typeGroups.add(node.types);
                    }
                    continue;
                }
                if ((0, _index.isGenericTypeAnnotation)(node)) {
                    var name = getQualifiedName(node.id);
                    if (generics.has(name)) {
                        var existing = generics.get(name);
                        if (existing.typeParameters) {
                            if (node.typeParameters) {
                                var _existing_typeParameters_params;
                                (_existing_typeParameters_params = existing.typeParameters.params).push.apply(_existing_typeParameters_params, _to_consumable_array(node.typeParameters.params));
                                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
                            }
                        } else {
                            existing = node.typeParameters;
                        }
                    } else {
                        generics.set(name, node);
                    }
                    continue;
                }
                types.push(node);
            }
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = bases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _sliced_to_array(_step.value, 2), baseType = _step_value[1];
                    types.push(baseType);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = generics[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var _step_value1 = _sliced_to_array(_step1.value, 2), genericName = _step_value1[1];
                    types.push(genericName);
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
            return types;
        }
    }
});
// ../../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
    "../../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = createFlowUnionType;
        var _index = require_generated2();
        var _removeTypeDuplicates = require_removeTypeDuplicates();
        function createFlowUnionType(types) {
            var flattened = (0, _removeTypeDuplicates.default)(types);
            if (flattened.length === 1) {
                return flattened[0];
            } else {
                return (0, _index.unionTypeAnnotation)(flattened);
            }
        }
    }
});
// ../../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
    "../../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = removeTypeDuplicates;
        var _index = require_generated();
        function getQualifiedName(node) {
            return (0, _index.isIdentifier)(node) ? node.name : "".concat(node.right.name, ".").concat(getQualifiedName(node.left));
        }
        function removeTypeDuplicates(nodesIn) {
            var nodes = Array.from(nodesIn);
            var generics = /* @__PURE__ */ new Map();
            var bases = /* @__PURE__ */ new Map();
            var typeGroups = /* @__PURE__ */ new Set();
            var types = [];
            for(var i = 0; i < nodes.length; i++){
                var node = nodes[i];
                if (!node) continue;
                if (types.includes(node)) {
                    continue;
                }
                if ((0, _index.isTSAnyKeyword)(node)) {
                    return [
                        node
                    ];
                }
                if ((0, _index.isTSBaseType)(node)) {
                    bases.set(node.type, node);
                    continue;
                }
                if ((0, _index.isTSUnionType)(node)) {
                    if (!typeGroups.has(node.types)) {
                        var _nodes;
                        (_nodes = nodes).push.apply(_nodes, _to_consumable_array(node.types));
                        typeGroups.add(node.types);
                    }
                    continue;
                }
                if ((0, _index.isTSTypeReference)(node) && node.typeParameters) {
                    var name = getQualifiedName(node.typeName);
                    if (generics.has(name)) {
                        var existing = generics.get(name);
                        if (existing.typeParameters) {
                            if (node.typeParameters) {
                                var _existing_typeParameters_params;
                                (_existing_typeParameters_params = existing.typeParameters.params).push.apply(_existing_typeParameters_params, _to_consumable_array(node.typeParameters.params));
                                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
                            }
                        } else {
                            existing = node.typeParameters;
                        }
                    } else {
                        generics.set(name, node);
                    }
                    continue;
                }
                types.push(node);
            }
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = bases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _sliced_to_array(_step.value, 2), baseType = _step_value[1];
                    types.push(baseType);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = generics[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var _step_value1 = _sliced_to_array(_step1.value, 2), genericName = _step_value1[1];
                    types.push(genericName);
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
            return types;
        }
    }
});
// ../../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
    "../../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = createTSUnionType;
        var _index = require_generated2();
        var _removeTypeDuplicates = require_removeTypeDuplicates2();
        var _index2 = require_generated();
        function createTSUnionType(typeAnnotations) {
            var types = typeAnnotations.map(function(type) {
                return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
            });
            var flattened = (0, _removeTypeDuplicates.default)(types);
            if (flattened.length === 1) {
                return flattened[0];
            } else {
                return (0, _index.tsUnionType)(flattened);
            }
        }
    }
});
// ../../node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
    "../../node_modules/@babel/types/lib/builders/generated/uppercase.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        Object.defineProperty(exports, "AnyTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.anyTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "ArgumentPlaceholder", {
            enumerable: true,
            get: function get3() {
                return _index.argumentPlaceholder;
            }
        });
        Object.defineProperty(exports, "ArrayExpression", {
            enumerable: true,
            get: function get3() {
                return _index.arrayExpression;
            }
        });
        Object.defineProperty(exports, "ArrayPattern", {
            enumerable: true,
            get: function get3() {
                return _index.arrayPattern;
            }
        });
        Object.defineProperty(exports, "ArrayTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.arrayTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "ArrowFunctionExpression", {
            enumerable: true,
            get: function get3() {
                return _index.arrowFunctionExpression;
            }
        });
        Object.defineProperty(exports, "AssignmentExpression", {
            enumerable: true,
            get: function get3() {
                return _index.assignmentExpression;
            }
        });
        Object.defineProperty(exports, "AssignmentPattern", {
            enumerable: true,
            get: function get3() {
                return _index.assignmentPattern;
            }
        });
        Object.defineProperty(exports, "AwaitExpression", {
            enumerable: true,
            get: function get3() {
                return _index.awaitExpression;
            }
        });
        Object.defineProperty(exports, "BigIntLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.bigIntLiteral;
            }
        });
        Object.defineProperty(exports, "BinaryExpression", {
            enumerable: true,
            get: function get3() {
                return _index.binaryExpression;
            }
        });
        Object.defineProperty(exports, "BindExpression", {
            enumerable: true,
            get: function get3() {
                return _index.bindExpression;
            }
        });
        Object.defineProperty(exports, "BlockStatement", {
            enumerable: true,
            get: function get3() {
                return _index.blockStatement;
            }
        });
        Object.defineProperty(exports, "BooleanLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.booleanLiteral;
            }
        });
        Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.booleanLiteralTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "BooleanTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.booleanTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "BreakStatement", {
            enumerable: true,
            get: function get3() {
                return _index.breakStatement;
            }
        });
        Object.defineProperty(exports, "CallExpression", {
            enumerable: true,
            get: function get3() {
                return _index.callExpression;
            }
        });
        Object.defineProperty(exports, "CatchClause", {
            enumerable: true,
            get: function get3() {
                return _index.catchClause;
            }
        });
        Object.defineProperty(exports, "ClassAccessorProperty", {
            enumerable: true,
            get: function get3() {
                return _index.classAccessorProperty;
            }
        });
        Object.defineProperty(exports, "ClassBody", {
            enumerable: true,
            get: function get3() {
                return _index.classBody;
            }
        });
        Object.defineProperty(exports, "ClassDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.classDeclaration;
            }
        });
        Object.defineProperty(exports, "ClassExpression", {
            enumerable: true,
            get: function get3() {
                return _index.classExpression;
            }
        });
        Object.defineProperty(exports, "ClassImplements", {
            enumerable: true,
            get: function get3() {
                return _index.classImplements;
            }
        });
        Object.defineProperty(exports, "ClassMethod", {
            enumerable: true,
            get: function get3() {
                return _index.classMethod;
            }
        });
        Object.defineProperty(exports, "ClassPrivateMethod", {
            enumerable: true,
            get: function get3() {
                return _index.classPrivateMethod;
            }
        });
        Object.defineProperty(exports, "ClassPrivateProperty", {
            enumerable: true,
            get: function get3() {
                return _index.classPrivateProperty;
            }
        });
        Object.defineProperty(exports, "ClassProperty", {
            enumerable: true,
            get: function get3() {
                return _index.classProperty;
            }
        });
        Object.defineProperty(exports, "ConditionalExpression", {
            enumerable: true,
            get: function get3() {
                return _index.conditionalExpression;
            }
        });
        Object.defineProperty(exports, "ContinueStatement", {
            enumerable: true,
            get: function get3() {
                return _index.continueStatement;
            }
        });
        Object.defineProperty(exports, "DebuggerStatement", {
            enumerable: true,
            get: function get3() {
                return _index.debuggerStatement;
            }
        });
        Object.defineProperty(exports, "DecimalLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.decimalLiteral;
            }
        });
        Object.defineProperty(exports, "DeclareClass", {
            enumerable: true,
            get: function get3() {
                return _index.declareClass;
            }
        });
        Object.defineProperty(exports, "DeclareExportAllDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.declareExportAllDeclaration;
            }
        });
        Object.defineProperty(exports, "DeclareExportDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.declareExportDeclaration;
            }
        });
        Object.defineProperty(exports, "DeclareFunction", {
            enumerable: true,
            get: function get3() {
                return _index.declareFunction;
            }
        });
        Object.defineProperty(exports, "DeclareInterface", {
            enumerable: true,
            get: function get3() {
                return _index.declareInterface;
            }
        });
        Object.defineProperty(exports, "DeclareModule", {
            enumerable: true,
            get: function get3() {
                return _index.declareModule;
            }
        });
        Object.defineProperty(exports, "DeclareModuleExports", {
            enumerable: true,
            get: function get3() {
                return _index.declareModuleExports;
            }
        });
        Object.defineProperty(exports, "DeclareOpaqueType", {
            enumerable: true,
            get: function get3() {
                return _index.declareOpaqueType;
            }
        });
        Object.defineProperty(exports, "DeclareTypeAlias", {
            enumerable: true,
            get: function get3() {
                return _index.declareTypeAlias;
            }
        });
        Object.defineProperty(exports, "DeclareVariable", {
            enumerable: true,
            get: function get3() {
                return _index.declareVariable;
            }
        });
        Object.defineProperty(exports, "DeclaredPredicate", {
            enumerable: true,
            get: function get3() {
                return _index.declaredPredicate;
            }
        });
        Object.defineProperty(exports, "Decorator", {
            enumerable: true,
            get: function get3() {
                return _index.decorator;
            }
        });
        Object.defineProperty(exports, "Directive", {
            enumerable: true,
            get: function get3() {
                return _index.directive;
            }
        });
        Object.defineProperty(exports, "DirectiveLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.directiveLiteral;
            }
        });
        Object.defineProperty(exports, "DoExpression", {
            enumerable: true,
            get: function get3() {
                return _index.doExpression;
            }
        });
        Object.defineProperty(exports, "DoWhileStatement", {
            enumerable: true,
            get: function get3() {
                return _index.doWhileStatement;
            }
        });
        Object.defineProperty(exports, "EmptyStatement", {
            enumerable: true,
            get: function get3() {
                return _index.emptyStatement;
            }
        });
        Object.defineProperty(exports, "EmptyTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.emptyTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "EnumBooleanBody", {
            enumerable: true,
            get: function get3() {
                return _index.enumBooleanBody;
            }
        });
        Object.defineProperty(exports, "EnumBooleanMember", {
            enumerable: true,
            get: function get3() {
                return _index.enumBooleanMember;
            }
        });
        Object.defineProperty(exports, "EnumDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.enumDeclaration;
            }
        });
        Object.defineProperty(exports, "EnumDefaultedMember", {
            enumerable: true,
            get: function get3() {
                return _index.enumDefaultedMember;
            }
        });
        Object.defineProperty(exports, "EnumNumberBody", {
            enumerable: true,
            get: function get3() {
                return _index.enumNumberBody;
            }
        });
        Object.defineProperty(exports, "EnumNumberMember", {
            enumerable: true,
            get: function get3() {
                return _index.enumNumberMember;
            }
        });
        Object.defineProperty(exports, "EnumStringBody", {
            enumerable: true,
            get: function get3() {
                return _index.enumStringBody;
            }
        });
        Object.defineProperty(exports, "EnumStringMember", {
            enumerable: true,
            get: function get3() {
                return _index.enumStringMember;
            }
        });
        Object.defineProperty(exports, "EnumSymbolBody", {
            enumerable: true,
            get: function get3() {
                return _index.enumSymbolBody;
            }
        });
        Object.defineProperty(exports, "ExistsTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.existsTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "ExportAllDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.exportAllDeclaration;
            }
        });
        Object.defineProperty(exports, "ExportDefaultDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.exportDefaultDeclaration;
            }
        });
        Object.defineProperty(exports, "ExportDefaultSpecifier", {
            enumerable: true,
            get: function get3() {
                return _index.exportDefaultSpecifier;
            }
        });
        Object.defineProperty(exports, "ExportNamedDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.exportNamedDeclaration;
            }
        });
        Object.defineProperty(exports, "ExportNamespaceSpecifier", {
            enumerable: true,
            get: function get3() {
                return _index.exportNamespaceSpecifier;
            }
        });
        Object.defineProperty(exports, "ExportSpecifier", {
            enumerable: true,
            get: function get3() {
                return _index.exportSpecifier;
            }
        });
        Object.defineProperty(exports, "ExpressionStatement", {
            enumerable: true,
            get: function get3() {
                return _index.expressionStatement;
            }
        });
        Object.defineProperty(exports, "File", {
            enumerable: true,
            get: function get3() {
                return _index.file;
            }
        });
        Object.defineProperty(exports, "ForInStatement", {
            enumerable: true,
            get: function get3() {
                return _index.forInStatement;
            }
        });
        Object.defineProperty(exports, "ForOfStatement", {
            enumerable: true,
            get: function get3() {
                return _index.forOfStatement;
            }
        });
        Object.defineProperty(exports, "ForStatement", {
            enumerable: true,
            get: function get3() {
                return _index.forStatement;
            }
        });
        Object.defineProperty(exports, "FunctionDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.functionDeclaration;
            }
        });
        Object.defineProperty(exports, "FunctionExpression", {
            enumerable: true,
            get: function get3() {
                return _index.functionExpression;
            }
        });
        Object.defineProperty(exports, "FunctionTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.functionTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "FunctionTypeParam", {
            enumerable: true,
            get: function get3() {
                return _index.functionTypeParam;
            }
        });
        Object.defineProperty(exports, "GenericTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.genericTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "Identifier", {
            enumerable: true,
            get: function get3() {
                return _index.identifier;
            }
        });
        Object.defineProperty(exports, "IfStatement", {
            enumerable: true,
            get: function get3() {
                return _index.ifStatement;
            }
        });
        Object.defineProperty(exports, "Import", {
            enumerable: true,
            get: function get3() {
                return _index.import;
            }
        });
        Object.defineProperty(exports, "ImportAttribute", {
            enumerable: true,
            get: function get3() {
                return _index.importAttribute;
            }
        });
        Object.defineProperty(exports, "ImportDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.importDeclaration;
            }
        });
        Object.defineProperty(exports, "ImportDefaultSpecifier", {
            enumerable: true,
            get: function get3() {
                return _index.importDefaultSpecifier;
            }
        });
        Object.defineProperty(exports, "ImportExpression", {
            enumerable: true,
            get: function get3() {
                return _index.importExpression;
            }
        });
        Object.defineProperty(exports, "ImportNamespaceSpecifier", {
            enumerable: true,
            get: function get3() {
                return _index.importNamespaceSpecifier;
            }
        });
        Object.defineProperty(exports, "ImportSpecifier", {
            enumerable: true,
            get: function get3() {
                return _index.importSpecifier;
            }
        });
        Object.defineProperty(exports, "IndexedAccessType", {
            enumerable: true,
            get: function get3() {
                return _index.indexedAccessType;
            }
        });
        Object.defineProperty(exports, "InferredPredicate", {
            enumerable: true,
            get: function get3() {
                return _index.inferredPredicate;
            }
        });
        Object.defineProperty(exports, "InterfaceDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.interfaceDeclaration;
            }
        });
        Object.defineProperty(exports, "InterfaceExtends", {
            enumerable: true,
            get: function get3() {
                return _index.interfaceExtends;
            }
        });
        Object.defineProperty(exports, "InterfaceTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.interfaceTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "InterpreterDirective", {
            enumerable: true,
            get: function get3() {
                return _index.interpreterDirective;
            }
        });
        Object.defineProperty(exports, "IntersectionTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.intersectionTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "JSXAttribute", {
            enumerable: true,
            get: function get3() {
                return _index.jsxAttribute;
            }
        });
        Object.defineProperty(exports, "JSXClosingElement", {
            enumerable: true,
            get: function get3() {
                return _index.jsxClosingElement;
            }
        });
        Object.defineProperty(exports, "JSXClosingFragment", {
            enumerable: true,
            get: function get3() {
                return _index.jsxClosingFragment;
            }
        });
        Object.defineProperty(exports, "JSXElement", {
            enumerable: true,
            get: function get3() {
                return _index.jsxElement;
            }
        });
        Object.defineProperty(exports, "JSXEmptyExpression", {
            enumerable: true,
            get: function get3() {
                return _index.jsxEmptyExpression;
            }
        });
        Object.defineProperty(exports, "JSXExpressionContainer", {
            enumerable: true,
            get: function get3() {
                return _index.jsxExpressionContainer;
            }
        });
        Object.defineProperty(exports, "JSXFragment", {
            enumerable: true,
            get: function get3() {
                return _index.jsxFragment;
            }
        });
        Object.defineProperty(exports, "JSXIdentifier", {
            enumerable: true,
            get: function get3() {
                return _index.jsxIdentifier;
            }
        });
        Object.defineProperty(exports, "JSXMemberExpression", {
            enumerable: true,
            get: function get3() {
                return _index.jsxMemberExpression;
            }
        });
        Object.defineProperty(exports, "JSXNamespacedName", {
            enumerable: true,
            get: function get3() {
                return _index.jsxNamespacedName;
            }
        });
        Object.defineProperty(exports, "JSXOpeningElement", {
            enumerable: true,
            get: function get3() {
                return _index.jsxOpeningElement;
            }
        });
        Object.defineProperty(exports, "JSXOpeningFragment", {
            enumerable: true,
            get: function get3() {
                return _index.jsxOpeningFragment;
            }
        });
        Object.defineProperty(exports, "JSXSpreadAttribute", {
            enumerable: true,
            get: function get3() {
                return _index.jsxSpreadAttribute;
            }
        });
        Object.defineProperty(exports, "JSXSpreadChild", {
            enumerable: true,
            get: function get3() {
                return _index.jsxSpreadChild;
            }
        });
        Object.defineProperty(exports, "JSXText", {
            enumerable: true,
            get: function get3() {
                return _index.jsxText;
            }
        });
        Object.defineProperty(exports, "LabeledStatement", {
            enumerable: true,
            get: function get3() {
                return _index.labeledStatement;
            }
        });
        Object.defineProperty(exports, "LogicalExpression", {
            enumerable: true,
            get: function get3() {
                return _index.logicalExpression;
            }
        });
        Object.defineProperty(exports, "MemberExpression", {
            enumerable: true,
            get: function get3() {
                return _index.memberExpression;
            }
        });
        Object.defineProperty(exports, "MetaProperty", {
            enumerable: true,
            get: function get3() {
                return _index.metaProperty;
            }
        });
        Object.defineProperty(exports, "MixedTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.mixedTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "ModuleExpression", {
            enumerable: true,
            get: function get3() {
                return _index.moduleExpression;
            }
        });
        Object.defineProperty(exports, "NewExpression", {
            enumerable: true,
            get: function get3() {
                return _index.newExpression;
            }
        });
        Object.defineProperty(exports, "Noop", {
            enumerable: true,
            get: function get3() {
                return _index.noop;
            }
        });
        Object.defineProperty(exports, "NullLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.nullLiteral;
            }
        });
        Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.nullLiteralTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "NullableTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.nullableTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "NumberLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.numberLiteral;
            }
        });
        Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.numberLiteralTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "NumberTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.numberTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "NumericLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.numericLiteral;
            }
        });
        Object.defineProperty(exports, "ObjectExpression", {
            enumerable: true,
            get: function get3() {
                return _index.objectExpression;
            }
        });
        Object.defineProperty(exports, "ObjectMethod", {
            enumerable: true,
            get: function get3() {
                return _index.objectMethod;
            }
        });
        Object.defineProperty(exports, "ObjectPattern", {
            enumerable: true,
            get: function get3() {
                return _index.objectPattern;
            }
        });
        Object.defineProperty(exports, "ObjectProperty", {
            enumerable: true,
            get: function get3() {
                return _index.objectProperty;
            }
        });
        Object.defineProperty(exports, "ObjectTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.objectTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "ObjectTypeCallProperty", {
            enumerable: true,
            get: function get3() {
                return _index.objectTypeCallProperty;
            }
        });
        Object.defineProperty(exports, "ObjectTypeIndexer", {
            enumerable: true,
            get: function get3() {
                return _index.objectTypeIndexer;
            }
        });
        Object.defineProperty(exports, "ObjectTypeInternalSlot", {
            enumerable: true,
            get: function get3() {
                return _index.objectTypeInternalSlot;
            }
        });
        Object.defineProperty(exports, "ObjectTypeProperty", {
            enumerable: true,
            get: function get3() {
                return _index.objectTypeProperty;
            }
        });
        Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
            enumerable: true,
            get: function get3() {
                return _index.objectTypeSpreadProperty;
            }
        });
        Object.defineProperty(exports, "OpaqueType", {
            enumerable: true,
            get: function get3() {
                return _index.opaqueType;
            }
        });
        Object.defineProperty(exports, "OptionalCallExpression", {
            enumerable: true,
            get: function get3() {
                return _index.optionalCallExpression;
            }
        });
        Object.defineProperty(exports, "OptionalIndexedAccessType", {
            enumerable: true,
            get: function get3() {
                return _index.optionalIndexedAccessType;
            }
        });
        Object.defineProperty(exports, "OptionalMemberExpression", {
            enumerable: true,
            get: function get3() {
                return _index.optionalMemberExpression;
            }
        });
        Object.defineProperty(exports, "ParenthesizedExpression", {
            enumerable: true,
            get: function get3() {
                return _index.parenthesizedExpression;
            }
        });
        Object.defineProperty(exports, "PipelineBareFunction", {
            enumerable: true,
            get: function get3() {
                return _index.pipelineBareFunction;
            }
        });
        Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
            enumerable: true,
            get: function get3() {
                return _index.pipelinePrimaryTopicReference;
            }
        });
        Object.defineProperty(exports, "PipelineTopicExpression", {
            enumerable: true,
            get: function get3() {
                return _index.pipelineTopicExpression;
            }
        });
        Object.defineProperty(exports, "Placeholder", {
            enumerable: true,
            get: function get3() {
                return _index.placeholder;
            }
        });
        Object.defineProperty(exports, "PrivateName", {
            enumerable: true,
            get: function get3() {
                return _index.privateName;
            }
        });
        Object.defineProperty(exports, "Program", {
            enumerable: true,
            get: function get3() {
                return _index.program;
            }
        });
        Object.defineProperty(exports, "QualifiedTypeIdentifier", {
            enumerable: true,
            get: function get3() {
                return _index.qualifiedTypeIdentifier;
            }
        });
        Object.defineProperty(exports, "RecordExpression", {
            enumerable: true,
            get: function get3() {
                return _index.recordExpression;
            }
        });
        Object.defineProperty(exports, "RegExpLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.regExpLiteral;
            }
        });
        Object.defineProperty(exports, "RegexLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.regexLiteral;
            }
        });
        Object.defineProperty(exports, "RestElement", {
            enumerable: true,
            get: function get3() {
                return _index.restElement;
            }
        });
        Object.defineProperty(exports, "RestProperty", {
            enumerable: true,
            get: function get3() {
                return _index.restProperty;
            }
        });
        Object.defineProperty(exports, "ReturnStatement", {
            enumerable: true,
            get: function get3() {
                return _index.returnStatement;
            }
        });
        Object.defineProperty(exports, "SequenceExpression", {
            enumerable: true,
            get: function get3() {
                return _index.sequenceExpression;
            }
        });
        Object.defineProperty(exports, "SpreadElement", {
            enumerable: true,
            get: function get3() {
                return _index.spreadElement;
            }
        });
        Object.defineProperty(exports, "SpreadProperty", {
            enumerable: true,
            get: function get3() {
                return _index.spreadProperty;
            }
        });
        Object.defineProperty(exports, "StaticBlock", {
            enumerable: true,
            get: function get3() {
                return _index.staticBlock;
            }
        });
        Object.defineProperty(exports, "StringLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.stringLiteral;
            }
        });
        Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.stringLiteralTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "StringTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.stringTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "Super", {
            enumerable: true,
            get: function get3() {
                return _index.super;
            }
        });
        Object.defineProperty(exports, "SwitchCase", {
            enumerable: true,
            get: function get3() {
                return _index.switchCase;
            }
        });
        Object.defineProperty(exports, "SwitchStatement", {
            enumerable: true,
            get: function get3() {
                return _index.switchStatement;
            }
        });
        Object.defineProperty(exports, "SymbolTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.symbolTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "TSAnyKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsAnyKeyword;
            }
        });
        Object.defineProperty(exports, "TSArrayType", {
            enumerable: true,
            get: function get3() {
                return _index.tsArrayType;
            }
        });
        Object.defineProperty(exports, "TSAsExpression", {
            enumerable: true,
            get: function get3() {
                return _index.tsAsExpression;
            }
        });
        Object.defineProperty(exports, "TSBigIntKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsBigIntKeyword;
            }
        });
        Object.defineProperty(exports, "TSBooleanKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsBooleanKeyword;
            }
        });
        Object.defineProperty(exports, "TSCallSignatureDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsCallSignatureDeclaration;
            }
        });
        Object.defineProperty(exports, "TSConditionalType", {
            enumerable: true,
            get: function get3() {
                return _index.tsConditionalType;
            }
        });
        Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsConstructSignatureDeclaration;
            }
        });
        Object.defineProperty(exports, "TSConstructorType", {
            enumerable: true,
            get: function get3() {
                return _index.tsConstructorType;
            }
        });
        Object.defineProperty(exports, "TSDeclareFunction", {
            enumerable: true,
            get: function get3() {
                return _index.tsDeclareFunction;
            }
        });
        Object.defineProperty(exports, "TSDeclareMethod", {
            enumerable: true,
            get: function get3() {
                return _index.tsDeclareMethod;
            }
        });
        Object.defineProperty(exports, "TSEnumDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsEnumDeclaration;
            }
        });
        Object.defineProperty(exports, "TSEnumMember", {
            enumerable: true,
            get: function get3() {
                return _index.tsEnumMember;
            }
        });
        Object.defineProperty(exports, "TSExportAssignment", {
            enumerable: true,
            get: function get3() {
                return _index.tsExportAssignment;
            }
        });
        Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
            enumerable: true,
            get: function get3() {
                return _index.tsExpressionWithTypeArguments;
            }
        });
        Object.defineProperty(exports, "TSExternalModuleReference", {
            enumerable: true,
            get: function get3() {
                return _index.tsExternalModuleReference;
            }
        });
        Object.defineProperty(exports, "TSFunctionType", {
            enumerable: true,
            get: function get3() {
                return _index.tsFunctionType;
            }
        });
        Object.defineProperty(exports, "TSImportEqualsDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsImportEqualsDeclaration;
            }
        });
        Object.defineProperty(exports, "TSImportType", {
            enumerable: true,
            get: function get3() {
                return _index.tsImportType;
            }
        });
        Object.defineProperty(exports, "TSIndexSignature", {
            enumerable: true,
            get: function get3() {
                return _index.tsIndexSignature;
            }
        });
        Object.defineProperty(exports, "TSIndexedAccessType", {
            enumerable: true,
            get: function get3() {
                return _index.tsIndexedAccessType;
            }
        });
        Object.defineProperty(exports, "TSInferType", {
            enumerable: true,
            get: function get3() {
                return _index.tsInferType;
            }
        });
        Object.defineProperty(exports, "TSInstantiationExpression", {
            enumerable: true,
            get: function get3() {
                return _index.tsInstantiationExpression;
            }
        });
        Object.defineProperty(exports, "TSInterfaceBody", {
            enumerable: true,
            get: function get3() {
                return _index.tsInterfaceBody;
            }
        });
        Object.defineProperty(exports, "TSInterfaceDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsInterfaceDeclaration;
            }
        });
        Object.defineProperty(exports, "TSIntersectionType", {
            enumerable: true,
            get: function get3() {
                return _index.tsIntersectionType;
            }
        });
        Object.defineProperty(exports, "TSIntrinsicKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsIntrinsicKeyword;
            }
        });
        Object.defineProperty(exports, "TSLiteralType", {
            enumerable: true,
            get: function get3() {
                return _index.tsLiteralType;
            }
        });
        Object.defineProperty(exports, "TSMappedType", {
            enumerable: true,
            get: function get3() {
                return _index.tsMappedType;
            }
        });
        Object.defineProperty(exports, "TSMethodSignature", {
            enumerable: true,
            get: function get3() {
                return _index.tsMethodSignature;
            }
        });
        Object.defineProperty(exports, "TSModuleBlock", {
            enumerable: true,
            get: function get3() {
                return _index.tsModuleBlock;
            }
        });
        Object.defineProperty(exports, "TSModuleDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsModuleDeclaration;
            }
        });
        Object.defineProperty(exports, "TSNamedTupleMember", {
            enumerable: true,
            get: function get3() {
                return _index.tsNamedTupleMember;
            }
        });
        Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsNamespaceExportDeclaration;
            }
        });
        Object.defineProperty(exports, "TSNeverKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsNeverKeyword;
            }
        });
        Object.defineProperty(exports, "TSNonNullExpression", {
            enumerable: true,
            get: function get3() {
                return _index.tsNonNullExpression;
            }
        });
        Object.defineProperty(exports, "TSNullKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsNullKeyword;
            }
        });
        Object.defineProperty(exports, "TSNumberKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsNumberKeyword;
            }
        });
        Object.defineProperty(exports, "TSObjectKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsObjectKeyword;
            }
        });
        Object.defineProperty(exports, "TSOptionalType", {
            enumerable: true,
            get: function get3() {
                return _index.tsOptionalType;
            }
        });
        Object.defineProperty(exports, "TSParameterProperty", {
            enumerable: true,
            get: function get3() {
                return _index.tsParameterProperty;
            }
        });
        Object.defineProperty(exports, "TSParenthesizedType", {
            enumerable: true,
            get: function get3() {
                return _index.tsParenthesizedType;
            }
        });
        Object.defineProperty(exports, "TSPropertySignature", {
            enumerable: true,
            get: function get3() {
                return _index.tsPropertySignature;
            }
        });
        Object.defineProperty(exports, "TSQualifiedName", {
            enumerable: true,
            get: function get3() {
                return _index.tsQualifiedName;
            }
        });
        Object.defineProperty(exports, "TSRestType", {
            enumerable: true,
            get: function get3() {
                return _index.tsRestType;
            }
        });
        Object.defineProperty(exports, "TSSatisfiesExpression", {
            enumerable: true,
            get: function get3() {
                return _index.tsSatisfiesExpression;
            }
        });
        Object.defineProperty(exports, "TSStringKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsStringKeyword;
            }
        });
        Object.defineProperty(exports, "TSSymbolKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsSymbolKeyword;
            }
        });
        Object.defineProperty(exports, "TSThisType", {
            enumerable: true,
            get: function get3() {
                return _index.tsThisType;
            }
        });
        Object.defineProperty(exports, "TSTupleType", {
            enumerable: true,
            get: function get3() {
                return _index.tsTupleType;
            }
        });
        Object.defineProperty(exports, "TSTypeAliasDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeAliasDeclaration;
            }
        });
        Object.defineProperty(exports, "TSTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "TSTypeAssertion", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeAssertion;
            }
        });
        Object.defineProperty(exports, "TSTypeLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeLiteral;
            }
        });
        Object.defineProperty(exports, "TSTypeOperator", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeOperator;
            }
        });
        Object.defineProperty(exports, "TSTypeParameter", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeParameter;
            }
        });
        Object.defineProperty(exports, "TSTypeParameterDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeParameterDeclaration;
            }
        });
        Object.defineProperty(exports, "TSTypeParameterInstantiation", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeParameterInstantiation;
            }
        });
        Object.defineProperty(exports, "TSTypePredicate", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypePredicate;
            }
        });
        Object.defineProperty(exports, "TSTypeQuery", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeQuery;
            }
        });
        Object.defineProperty(exports, "TSTypeReference", {
            enumerable: true,
            get: function get3() {
                return _index.tsTypeReference;
            }
        });
        Object.defineProperty(exports, "TSUndefinedKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsUndefinedKeyword;
            }
        });
        Object.defineProperty(exports, "TSUnionType", {
            enumerable: true,
            get: function get3() {
                return _index.tsUnionType;
            }
        });
        Object.defineProperty(exports, "TSUnknownKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsUnknownKeyword;
            }
        });
        Object.defineProperty(exports, "TSVoidKeyword", {
            enumerable: true,
            get: function get3() {
                return _index.tsVoidKeyword;
            }
        });
        Object.defineProperty(exports, "TaggedTemplateExpression", {
            enumerable: true,
            get: function get3() {
                return _index.taggedTemplateExpression;
            }
        });
        Object.defineProperty(exports, "TemplateElement", {
            enumerable: true,
            get: function get3() {
                return _index.templateElement;
            }
        });
        Object.defineProperty(exports, "TemplateLiteral", {
            enumerable: true,
            get: function get3() {
                return _index.templateLiteral;
            }
        });
        Object.defineProperty(exports, "ThisExpression", {
            enumerable: true,
            get: function get3() {
                return _index.thisExpression;
            }
        });
        Object.defineProperty(exports, "ThisTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.thisTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "ThrowStatement", {
            enumerable: true,
            get: function get3() {
                return _index.throwStatement;
            }
        });
        Object.defineProperty(exports, "TopicReference", {
            enumerable: true,
            get: function get3() {
                return _index.topicReference;
            }
        });
        Object.defineProperty(exports, "TryStatement", {
            enumerable: true,
            get: function get3() {
                return _index.tryStatement;
            }
        });
        Object.defineProperty(exports, "TupleExpression", {
            enumerable: true,
            get: function get3() {
                return _index.tupleExpression;
            }
        });
        Object.defineProperty(exports, "TupleTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.tupleTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "TypeAlias", {
            enumerable: true,
            get: function get3() {
                return _index.typeAlias;
            }
        });
        Object.defineProperty(exports, "TypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.typeAnnotation;
            }
        });
        Object.defineProperty(exports, "TypeCastExpression", {
            enumerable: true,
            get: function get3() {
                return _index.typeCastExpression;
            }
        });
        Object.defineProperty(exports, "TypeParameter", {
            enumerable: true,
            get: function get3() {
                return _index.typeParameter;
            }
        });
        Object.defineProperty(exports, "TypeParameterDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.typeParameterDeclaration;
            }
        });
        Object.defineProperty(exports, "TypeParameterInstantiation", {
            enumerable: true,
            get: function get3() {
                return _index.typeParameterInstantiation;
            }
        });
        Object.defineProperty(exports, "TypeofTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.typeofTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "UnaryExpression", {
            enumerable: true,
            get: function get3() {
                return _index.unaryExpression;
            }
        });
        Object.defineProperty(exports, "UnionTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.unionTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "UpdateExpression", {
            enumerable: true,
            get: function get3() {
                return _index.updateExpression;
            }
        });
        Object.defineProperty(exports, "V8IntrinsicIdentifier", {
            enumerable: true,
            get: function get3() {
                return _index.v8IntrinsicIdentifier;
            }
        });
        Object.defineProperty(exports, "VariableDeclaration", {
            enumerable: true,
            get: function get3() {
                return _index.variableDeclaration;
            }
        });
        Object.defineProperty(exports, "VariableDeclarator", {
            enumerable: true,
            get: function get3() {
                return _index.variableDeclarator;
            }
        });
        Object.defineProperty(exports, "Variance", {
            enumerable: true,
            get: function get3() {
                return _index.variance;
            }
        });
        Object.defineProperty(exports, "VoidTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _index.voidTypeAnnotation;
            }
        });
        Object.defineProperty(exports, "WhileStatement", {
            enumerable: true,
            get: function get3() {
                return _index.whileStatement;
            }
        });
        Object.defineProperty(exports, "WithStatement", {
            enumerable: true,
            get: function get3() {
                return _index.withStatement;
            }
        });
        Object.defineProperty(exports, "YieldExpression", {
            enumerable: true,
            get: function get3() {
                return _index.yieldExpression;
            }
        });
        var _index = require_generated2();
    }
});
// ../../node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS({
    "../../node_modules/@babel/types/lib/builders/productions.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.buildUndefinedNode = buildUndefinedNode;
        var _index = require_generated2();
        function buildUndefinedNode() {
            return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
        }
    }
});
// ../../node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
    "../../node_modules/@babel/types/lib/clone/cloneNode.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = cloneNode;
        var _index = require_definitions();
        var _index2 = require_generated();
        var hasOwn = {
            hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
        }.hasOwn;
        function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
            if (obj && typeof obj.type === "string") {
                return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
            }
            return obj;
        }
        function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
            if (Array.isArray(obj)) {
                return obj.map(function(node) {
                    return cloneIfNode(node, deep, withoutLoc, commentsCache);
                });
            }
            return cloneIfNode(obj, deep, withoutLoc, commentsCache);
        }
        function cloneNode(node) {
            var deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var withoutLoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
        }
        function cloneNodeInternal(node) {
            var deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var withoutLoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var commentsCache = arguments.length > 3 ? arguments[3] : void 0;
            if (!node) return node;
            var type = node.type;
            var newNode = {
                type: node.type
            };
            if ((0, _index2.isIdentifier)(node)) {
                newNode.name = node.name;
                if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
                    newNode.optional = node.optional;
                }
                if (hasOwn(node, "typeAnnotation")) {
                    newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
                }
                if (hasOwn(node, "decorators")) {
                    newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
                }
            } else if (!hasOwn(_index.NODE_FIELDS, type)) {
                throw new Error('Unknown node type: "'.concat(type, '"'));
            } else {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = Object.keys(_index.NODE_FIELDS[type])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var field = _step.value;
                        if (hasOwn(node, field)) {
                            if (deep) {
                                newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
                            } else {
                                newNode[field] = node[field];
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            if (hasOwn(node, "loc")) {
                if (withoutLoc) {
                    newNode.loc = null;
                } else {
                    newNode.loc = node.loc;
                }
            }
            if (hasOwn(node, "leadingComments")) {
                newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
            }
            if (hasOwn(node, "innerComments")) {
                newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
            }
            if (hasOwn(node, "trailingComments")) {
                newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
            }
            if (hasOwn(node, "extra")) {
                newNode.extra = Object.assign({}, node.extra);
            }
            return newNode;
        }
        function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
            if (!comments || !deep) {
                return comments;
            }
            return comments.map(function(comment) {
                var cache = commentsCache.get(comment);
                if (cache) return cache;
                var type = comment.type, value = comment.value, loc = comment.loc;
                var ret = {
                    type: type,
                    value: value,
                    loc: loc
                };
                if (withoutLoc) {
                    ret.loc = null;
                }
                commentsCache.set(comment, ret);
                return ret;
            });
        }
    }
});
// ../../node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
    "../../node_modules/@babel/types/lib/clone/clone.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = clone;
        var _cloneNode = require_cloneNode();
        function clone(node) {
            return (0, _cloneNode.default)(node, false);
        }
    }
});
// ../../node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
    "../../node_modules/@babel/types/lib/clone/cloneDeep.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = cloneDeep;
        var _cloneNode = require_cloneNode();
        function cloneDeep(node) {
            return (0, _cloneNode.default)(node);
        }
    }
});
// ../../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
    "../../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = cloneDeepWithoutLoc;
        var _cloneNode = require_cloneNode();
        function cloneDeepWithoutLoc(node) {
            return (0, _cloneNode.default)(node, true, true);
        }
    }
});
// ../../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
    "../../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = cloneWithoutLoc;
        var _cloneNode = require_cloneNode();
        function cloneWithoutLoc(node) {
            return (0, _cloneNode.default)(node, false, true);
        }
    }
});
// ../../node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
    "../../node_modules/@babel/types/lib/comments/addComments.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = addComments;
        function addComments(node, type, comments) {
            if (!comments || !node) return node;
            var key2 = "".concat(type, "Comments");
            if (node[key2]) {
                if (type === "leading") {
                    node[key2] = comments.concat(node[key2]);
                } else {
                    var _node_key2;
                    (_node_key2 = node[key2]).push.apply(_node_key2, _to_consumable_array(comments));
                }
            } else {
                node[key2] = comments;
            }
            return node;
        }
    }
});
// ../../node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
    "../../node_modules/@babel/types/lib/comments/addComment.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = addComment;
        var _addComments = require_addComments();
        function addComment(node, type, content2, line) {
            return (0, _addComments.default)(node, type, [
                {
                    type: line ? "CommentLine" : "CommentBlock",
                    value: content2
                }
            ]);
        }
    }
});
// ../../node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
    "../../node_modules/@babel/types/lib/utils/inherit.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = inherit;
        function inherit(key2, child, parent) {
            if (child && parent) {
                child[key2] = Array.from(new Set([].concat(child[key2], parent[key2]).filter(Boolean)));
            }
        }
    }
});
// ../../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
    "../../node_modules/@babel/types/lib/comments/inheritInnerComments.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = inheritInnerComments;
        var _inherit = require_inherit();
        function inheritInnerComments(child, parent) {
            (0, _inherit.default)("innerComments", child, parent);
        }
    }
});
// ../../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
    "../../node_modules/@babel/types/lib/comments/inheritLeadingComments.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = inheritLeadingComments;
        var _inherit = require_inherit();
        function inheritLeadingComments(child, parent) {
            (0, _inherit.default)("leadingComments", child, parent);
        }
    }
});
// ../../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
    "../../node_modules/@babel/types/lib/comments/inheritTrailingComments.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = inheritTrailingComments;
        var _inherit = require_inherit();
        function inheritTrailingComments(child, parent) {
            (0, _inherit.default)("trailingComments", child, parent);
        }
    }
});
// ../../node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
    "../../node_modules/@babel/types/lib/comments/inheritsComments.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = inheritsComments;
        var _inheritTrailingComments = require_inheritTrailingComments();
        var _inheritLeadingComments = require_inheritLeadingComments();
        var _inheritInnerComments = require_inheritInnerComments();
        function inheritsComments(child, parent) {
            (0, _inheritTrailingComments.default)(child, parent);
            (0, _inheritLeadingComments.default)(child, parent);
            (0, _inheritInnerComments.default)(child, parent);
            return child;
        }
    }
});
// ../../node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
    "../../node_modules/@babel/types/lib/comments/removeComments.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = removeComments;
        var _index = require_constants();
        function removeComments(node) {
            _index.COMMENT_KEYS.forEach(function(key2) {
                node[key2] = null;
            });
            return node;
        }
    }
});
// ../../node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
    "../../node_modules/@babel/types/lib/constants/generated/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
        var _index = require_definitions();
        var STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
        var EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
        var BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
        var SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
        var BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
        var BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
        var STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
        var TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
        var COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
        var CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
        var LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
        var WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
        var EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
        var FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
        var FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
        var FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
        var FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
        var PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
        var DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
        var PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
        var LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
        var TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
        var LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
        var IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
        var USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
        var METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
        var OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
        var PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
        var UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
        var PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
        var CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
        var IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
        var EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
        var MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
        var ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
        var PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
        var FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
        var FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
        var FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
        var FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
        var FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
        var ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
        var ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
        var JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
        var MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
        var TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
        var TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
        var TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
        var TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
        var MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    }
});
// ../../node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toBlock.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = toBlock;
        var _index = require_generated();
        var _index2 = require_generated2();
        function toBlock(node, parent) {
            if ((0, _index.isBlockStatement)(node)) {
                return node;
            }
            var blockNodes = [];
            if ((0, _index.isEmptyStatement)(node)) {
                blockNodes = [];
            } else {
                if (!(0, _index.isStatement)(node)) {
                    if ((0, _index.isFunction)(parent)) {
                        node = (0, _index2.returnStatement)(node);
                    } else {
                        node = (0, _index2.expressionStatement)(node);
                    }
                }
                blockNodes = [
                    node
                ];
            }
            return (0, _index2.blockStatement)(blockNodes);
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
    "../../node_modules/@babel/types/lib/converters/ensureBlock.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = ensureBlock;
        var _toBlock = require_toBlock();
        function ensureBlock(node) {
            var key2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "body";
            var result = (0, _toBlock.default)(node[key2], node);
            node[key2] = result;
            return result;
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toIdentifier.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = toIdentifier;
        var _isValidIdentifier = require_isValidIdentifier();
        var _helperValidatorIdentifier = require_lib2();
        function toIdentifier(input2) {
            input2 = input2 + "";
            var name = "";
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = input2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var c = _step.value;
                    name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            name = name.replace(/^[-0-9]+/, "");
            name = name.replace(/[-\s]+(.)?/g, function(match, c2) {
                return c2 ? c2.toUpperCase() : "";
            });
            if (!(0, _isValidIdentifier.default)(name)) {
                name = "_".concat(name);
            }
            return name || "_";
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = toBindingIdentifierName;
        var _toIdentifier = require_toIdentifier();
        function toBindingIdentifierName(name) {
            name = (0, _toIdentifier.default)(name);
            if (name === "eval" || name === "arguments") name = "_" + name;
            return name;
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toComputedKey.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = toComputedKey;
        var _index = require_generated();
        var _index2 = require_generated2();
        function toComputedKey(node) {
            var key2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node.key || node.property;
            if (!node.computed && (0, _index.isIdentifier)(key2)) key2 = (0, _index2.stringLiteral)(key2.name);
            return key2;
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toExpression.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _index = require_generated();
        var _default = exports.default = toExpression;
        function toExpression(node) {
            if ((0, _index.isExpressionStatement)(node)) {
                node = node.expression;
            }
            if ((0, _index.isExpression)(node)) {
                return node;
            }
            if ((0, _index.isClass)(node)) {
                node.type = "ClassExpression";
            } else if ((0, _index.isFunction)(node)) {
                node.type = "FunctionExpression";
            }
            if (!(0, _index.isExpression)(node)) {
                throw new Error("cannot turn ".concat(node.type, " to an expression"));
            }
            return node;
        }
    }
});
// ../../node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
    "../../node_modules/@babel/types/lib/traverse/traverseFast.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = traverseFast;
        var _index = require_definitions();
        function traverseFast(node, enter, opts) {
            if (!node) return;
            var keys = _index.VISITOR_KEYS[node.type];
            if (!keys) return;
            opts = opts || {};
            enter(node, opts);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key2 = _step.value;
                    var subNode = node[key2];
                    if (Array.isArray(subNode)) {
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = subNode[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var _node = _step1.value;
                                traverseFast(_node, enter, opts);
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                    } else {
                        traverseFast(subNode, enter, opts);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
});
// ../../node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
    "../../node_modules/@babel/types/lib/modifications/removeProperties.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = removeProperties;
        var _index = require_constants();
        var CLEAR_KEYS = [
            "tokens",
            "start",
            "end",
            "loc",
            "raw",
            "rawValue"
        ];
        var CLEAR_KEYS_PLUS_COMMENTS = _to_consumable_array(_index.COMMENT_KEYS).concat([
            "comments"
        ], _to_consumable_array(CLEAR_KEYS));
        function removeProperties(node) {
            var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var map2 = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = map2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key2 = _step.value;
                    if (node[key2] != null) node[key2] = void 0;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = Object.keys(node)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var _key = _step1.value;
                    if (_key[0] === "_" && node[_key] != null) node[_key] = void 0;
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
            var symbols = Object.getOwnPropertySymbols(node);
            var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
            try {
                for(var _iterator2 = symbols[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var sym = _step2.value;
                    node[sym] = null;
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                        _iterator2.return();
                    }
                } finally{
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    }
});
// ../../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
    "../../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = removePropertiesDeep;
        var _traverseFast = require_traverseFast();
        var _removeProperties = require_removeProperties();
        function removePropertiesDeep(tree, opts) {
            (0, _traverseFast.default)(tree, _removeProperties.default, opts);
            return tree;
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toKeyAlias.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = toKeyAlias;
        var _index = require_generated();
        var _cloneNode = require_cloneNode();
        var _removePropertiesDeep = require_removePropertiesDeep();
        function toKeyAlias(node) {
            var key2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node.key;
            var alias;
            if (node.kind === "method") {
                return toKeyAlias.increment() + "";
            } else if ((0, _index.isIdentifier)(key2)) {
                alias = key2.name;
            } else if ((0, _index.isStringLiteral)(key2)) {
                alias = JSON.stringify(key2.value);
            } else {
                alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key2)));
            }
            if (node.computed) {
                alias = "[".concat(alias, "]");
            }
            if (node.static) {
                alias = "static:".concat(alias);
            }
            return alias;
        }
        toKeyAlias.uid = 0;
        toKeyAlias.increment = function() {
            if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
                return toKeyAlias.uid = 0;
            } else {
                return toKeyAlias.uid++;
            }
        };
    }
});
// ../../node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toStatement.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _index = require_generated();
        var _index2 = require_generated2();
        var _default = exports.default = toStatement;
        function toStatement(node, ignore) {
            if ((0, _index.isStatement)(node)) {
                return node;
            }
            var mustHaveId = false;
            var newType;
            if ((0, _index.isClass)(node)) {
                mustHaveId = true;
                newType = "ClassDeclaration";
            } else if ((0, _index.isFunction)(node)) {
                mustHaveId = true;
                newType = "FunctionDeclaration";
            } else if ((0, _index.isAssignmentExpression)(node)) {
                return (0, _index2.expressionStatement)(node);
            }
            if (mustHaveId && !node.id) {
                newType = false;
            }
            if (!newType) {
                if (ignore) {
                    return false;
                } else {
                    throw new Error("cannot turn ".concat(node.type, " to a statement"));
                }
            }
            node.type = newType;
            return node;
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
    "../../node_modules/@babel/types/lib/converters/valueToNode.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _isValidIdentifier = require_isValidIdentifier();
        var _index = require_generated2();
        var _default = exports.default = valueToNode;
        var objectToString = Function.call.bind(Object.prototype.toString);
        function isRegExp(value) {
            return objectToString(value) === "[object RegExp]";
        }
        function isPlainObject(value) {
            if ((typeof value === "undefined" ? "undefined" : _type_of(value)) !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
                return false;
            }
            var proto = Object.getPrototypeOf(value);
            return proto === null || Object.getPrototypeOf(proto) === null;
        }
        function valueToNode(value) {
            if (value === void 0) {
                return (0, _index.identifier)("undefined");
            }
            if (value === true || value === false) {
                return (0, _index.booleanLiteral)(value);
            }
            if (value === null) {
                return (0, _index.nullLiteral)();
            }
            if (typeof value === "string") {
                return (0, _index.stringLiteral)(value);
            }
            if (typeof value === "number") {
                var result;
                if (Number.isFinite(value)) {
                    result = (0, _index.numericLiteral)(Math.abs(value));
                } else {
                    var numerator;
                    if (Number.isNaN(value)) {
                        numerator = (0, _index.numericLiteral)(0);
                    } else {
                        numerator = (0, _index.numericLiteral)(1);
                    }
                    result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
                }
                if (value < 0 || Object.is(value, -0)) {
                    result = (0, _index.unaryExpression)("-", result);
                }
                return result;
            }
            if (isRegExp(value)) {
                var pattern = value.source;
                var flags = /\/([a-z]*)$/.exec(value.toString())[1];
                return (0, _index.regExpLiteral)(pattern, flags);
            }
            if (Array.isArray(value)) {
                return (0, _index.arrayExpression)(value.map(valueToNode));
            }
            if (isPlainObject(value)) {
                var props = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = Object.keys(value)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var key2 = _step.value;
                        var nodeKey = void 0;
                        if ((0, _isValidIdentifier.default)(key2)) {
                            nodeKey = (0, _index.identifier)(key2);
                        } else {
                            nodeKey = (0, _index.stringLiteral)(key2);
                        }
                        props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key2])));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return (0, _index.objectExpression)(props);
            }
            throw new Error("don't know how to turn this value into a node");
        }
    }
});
// ../../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
    "../../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = appendToMemberExpression;
        var _index = require_generated2();
        function appendToMemberExpression(member, append) {
            var computed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
            member.property = append;
            member.computed = !!computed;
            return member;
        }
    }
});
// ../../node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
    "../../node_modules/@babel/types/lib/modifications/inherits.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = inherits;
        var _index = require_constants();
        var _inheritsComments = require_inheritsComments();
        function inherits(child, parent) {
            if (!child || !parent) return child;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = _index.INHERIT_KEYS.optional[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key2 = _step.value;
                    if (child[key2] == null) {
                        child[key2] = parent[key2];
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = Object.keys(parent)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var _key = _step1.value;
                    if (_key[0] === "_" && _key !== "__clone") {
                        child[_key] = parent[_key];
                    }
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
            var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
            try {
                for(var _iterator2 = _index.INHERIT_KEYS.force[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var _key2 = _step2.value;
                    child[_key2] = parent[_key2];
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                        _iterator2.return();
                    }
                } finally{
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
            (0, _inheritsComments.default)(child, parent);
            return child;
        }
    }
});
// ../../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
    "../../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = prependToMemberExpression;
        var _index = require_generated2();
        var _index2 = require_lib4();
        function prependToMemberExpression(member, prepend) {
            if ((0, _index2.isSuper)(member.object)) {
                throw new Error("Cannot prepend node to super property access (`super.foo`).");
            }
            member.object = (0, _index.memberExpression)(prepend, member.object);
            return member;
        }
    }
});
// ../../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var require_getAssignmentIdentifiers = __commonJS({
    "../../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = getAssignmentIdentifiers;
        function getAssignmentIdentifiers(node) {
            var search = [].concat(node);
            var ids = /* @__PURE__ */ Object.create(null);
            while(search.length){
                var id = search.pop();
                if (!id) continue;
                switch(id.type){
                    case "ArrayPattern":
                        var _search;
                        (_search = search).push.apply(_search, _to_consumable_array(id.elements));
                        break;
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                    case "ForInStatement":
                    case "ForOfStatement":
                        search.push(id.left);
                        break;
                    case "ObjectPattern":
                        var _search1;
                        (_search1 = search).push.apply(_search1, _to_consumable_array(id.properties));
                        break;
                    case "ObjectProperty":
                        search.push(id.value);
                        break;
                    case "RestElement":
                    case "UpdateExpression":
                        search.push(id.argument);
                        break;
                    case "UnaryExpression":
                        if (id.operator === "delete") {
                            search.push(id.argument);
                        }
                        break;
                    case "Identifier":
                        ids[id.name] = id;
                        break;
                    default:
                        break;
                }
            }
            return ids;
        }
    }
});
// ../../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
    "../../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = getBindingIdentifiers;
        var _index = require_generated();
        function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
            var search = [].concat(node);
            var ids = /* @__PURE__ */ Object.create(null);
            while(search.length){
                var id = search.shift();
                if (!id) continue;
                if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {
                    continue;
                }
                if ((0, _index.isIdentifier)(id)) {
                    if (duplicates) {
                        var _ids = ids[id.name] = ids[id.name] || [];
                        _ids.push(id);
                    } else {
                        ids[id.name] = id;
                    }
                    continue;
                }
                if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
                    if ((0, _index.isDeclaration)(id.declaration)) {
                        search.push(id.declaration);
                    }
                    continue;
                }
                if (outerOnly) {
                    if ((0, _index.isFunctionDeclaration)(id)) {
                        search.push(id.id);
                        continue;
                    }
                    if ((0, _index.isFunctionExpression)(id)) {
                        continue;
                    }
                }
                var _keys = getBindingIdentifiers.keys[id.type];
                if (_keys) {
                    for(var i = 0; i < _keys.length; i++){
                        var key2 = _keys[i];
                        var nodes = id[key2];
                        if (nodes) {
                            if (Array.isArray(nodes)) {
                                var _search;
                                (_search = search).push.apply(_search, _to_consumable_array(nodes));
                            } else {
                                search.push(nodes);
                            }
                        }
                    }
                }
            }
            return ids;
        }
        var keys = {
            DeclareClass: [
                "id"
            ],
            DeclareFunction: [
                "id"
            ],
            DeclareModule: [
                "id"
            ],
            DeclareVariable: [
                "id"
            ],
            DeclareInterface: [
                "id"
            ],
            DeclareTypeAlias: [
                "id"
            ],
            DeclareOpaqueType: [
                "id"
            ],
            InterfaceDeclaration: [
                "id"
            ],
            TypeAlias: [
                "id"
            ],
            OpaqueType: [
                "id"
            ],
            CatchClause: [
                "param"
            ],
            LabeledStatement: [
                "label"
            ],
            UnaryExpression: [
                "argument"
            ],
            AssignmentExpression: [
                "left"
            ],
            ImportSpecifier: [
                "local"
            ],
            ImportNamespaceSpecifier: [
                "local"
            ],
            ImportDefaultSpecifier: [
                "local"
            ],
            ImportDeclaration: [
                "specifiers"
            ],
            ExportSpecifier: [
                "exported"
            ],
            ExportNamespaceSpecifier: [
                "exported"
            ],
            ExportDefaultSpecifier: [
                "exported"
            ],
            FunctionDeclaration: [
                "id",
                "params"
            ],
            FunctionExpression: [
                "id",
                "params"
            ],
            ArrowFunctionExpression: [
                "params"
            ],
            ObjectMethod: [
                "params"
            ],
            ClassMethod: [
                "params"
            ],
            ClassPrivateMethod: [
                "params"
            ],
            ForInStatement: [
                "left"
            ],
            ForOfStatement: [
                "left"
            ],
            ClassDeclaration: [
                "id"
            ],
            ClassExpression: [
                "id"
            ],
            RestElement: [
                "argument"
            ],
            UpdateExpression: [
                "argument"
            ],
            ObjectProperty: [
                "value"
            ],
            AssignmentPattern: [
                "left"
            ],
            ArrayPattern: [
                "elements"
            ],
            ObjectPattern: [
                "properties"
            ],
            VariableDeclaration: [
                "declarations"
            ],
            VariableDeclarator: [
                "id"
            ]
        };
        getBindingIdentifiers.keys = keys;
    }
});
// ../../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
    "../../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = void 0;
        var _getBindingIdentifiers = require_getBindingIdentifiers();
        var _default = exports.default = getOuterBindingIdentifiers;
        function getOuterBindingIdentifiers(node, duplicates) {
            return (0, _getBindingIdentifiers.default)(node, duplicates, true);
        }
    }
});
// ../../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var require_getFunctionName = __commonJS({
    "../../node_modules/@babel/types/lib/retrievers/getFunctionName.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = getFunctionName;
        var _index = require_generated();
        function getNameFromLiteralId(id) {
            if ((0, _index.isNullLiteral)(id)) {
                return "null";
            }
            if ((0, _index.isRegExpLiteral)(id)) {
                return "/".concat(id.pattern, "/").concat(id.flags);
            }
            if ((0, _index.isTemplateLiteral)(id)) {
                return id.quasis.map(function(quasi) {
                    return quasi.value.raw;
                }).join("");
            }
            if (id.value !== void 0) {
                return String(id.value);
            }
            return null;
        }
        function getObjectMemberKey(node) {
            if (!node.computed || (0, _index.isLiteral)(node.key)) {
                return node.key;
            }
        }
        function getFunctionName(node, parent) {
            if ("id" in node && node.id) {
                return {
                    name: node.id.name,
                    originalNode: node.id
                };
            }
            var prefix = "";
            var id;
            if ((0, _index.isObjectProperty)(parent, {
                value: node
            })) {
                id = getObjectMemberKey(parent);
            } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {
                id = getObjectMemberKey(node);
                if (node.kind === "get") prefix = "get ";
                else if (node.kind === "set") prefix = "set ";
            } else if ((0, _index.isVariableDeclarator)(parent, {
                init: node
            })) {
                id = parent.id;
            } else if ((0, _index.isAssignmentExpression)(parent, {
                operator: "=",
                right: node
            })) {
                id = parent.left;
            }
            if (!id) return null;
            var name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
            if (name == null) return null;
            return {
                name: prefix + name,
                originalNode: id
            };
        }
    }
});
// ../../node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
    "../../node_modules/@babel/types/lib/traverse/traverse.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = traverse;
        var _index = require_definitions();
        function traverse(node, handlers2, state) {
            if (typeof handlers2 === "function") {
                handlers2 = {
                    enter: handlers2
                };
            }
            var enter = handlers2.enter, exit = handlers2.exit;
            traverseSimpleImpl(node, enter, exit, state, []);
        }
        function traverseSimpleImpl(node, enter, exit, state, ancestors) {
            var keys = _index.VISITOR_KEYS[node.type];
            if (!keys) return;
            if (enter) enter(node, ancestors, state);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key2 = _step.value;
                    var subNode = node[key2];
                    if (Array.isArray(subNode)) {
                        for(var i = 0; i < subNode.length; i++){
                            var child = subNode[i];
                            if (!child) continue;
                            ancestors.push({
                                node: node,
                                key: key2,
                                index: i
                            });
                            traverseSimpleImpl(child, enter, exit, state, ancestors);
                            ancestors.pop();
                        }
                    } else if (subNode) {
                        ancestors.push({
                            node: node,
                            key: key2
                        });
                        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
                        ancestors.pop();
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            if (exit) exit(node, ancestors, state);
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isBinding.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isBinding;
        var _getBindingIdentifiers = require_getBindingIdentifiers();
        function isBinding(node, parent, grandparent) {
            if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
                return false;
            }
            var keys = _getBindingIdentifiers.default.keys[parent.type];
            if (keys) {
                for(var i = 0; i < keys.length; i++){
                    var key2 = keys[i];
                    var val = parent[key2];
                    if (Array.isArray(val)) {
                        if (val.includes(node)) return true;
                    } else {
                        if (val === node) return true;
                    }
                }
            }
            return false;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isLet.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isLet;
        var _index = require_generated();
        var _index2 = require_constants();
        function isLet(node) {
            return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isBlockScoped.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isBlockScoped;
        var _index = require_generated();
        var _isLet = require_isLet();
        function isBlockScoped(node) {
            return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isImmutable.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isImmutable;
        var _isType = require_isType();
        var _index = require_generated();
        function isImmutable(node) {
            if ((0, _isType.default)(node.type, "Immutable")) return true;
            if ((0, _index.isIdentifier)(node)) {
                if (node.name === "undefined") {
                    return true;
                } else {
                    return false;
                }
            }
            return false;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isNodesEquivalent.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isNodesEquivalent;
        var _index = require_definitions();
        function isNodesEquivalent(a, b) {
            if ((typeof a === "undefined" ? "undefined" : _type_of(a)) !== "object" || (typeof b === "undefined" ? "undefined" : _type_of(b)) !== "object" || a == null || b == null) {
                return a === b;
            }
            if (a.type !== b.type) {
                return false;
            }
            var fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
            var visitorKeys = _index.VISITOR_KEYS[a.type];
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var field = _step.value;
                    var val_a = a[field];
                    var val_b = b[field];
                    if ((typeof val_a === "undefined" ? "undefined" : _type_of(val_a)) !== (typeof val_b === "undefined" ? "undefined" : _type_of(val_b))) {
                        return false;
                    }
                    if (val_a == null && val_b == null) {
                        continue;
                    } else if (val_a == null || val_b == null) {
                        return false;
                    }
                    if (Array.isArray(val_a)) {
                        if (!Array.isArray(val_b)) {
                            return false;
                        }
                        if (val_a.length !== val_b.length) {
                            return false;
                        }
                        for(var i = 0; i < val_a.length; i++){
                            if (!isNodesEquivalent(val_a[i], val_b[i])) {
                                return false;
                            }
                        }
                        continue;
                    }
                    if ((typeof val_a === "undefined" ? "undefined" : _type_of(val_a)) === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = Object.keys(val_a)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var key2 = _step1.value;
                                if (val_a[key2] !== val_b[key2]) {
                                    return false;
                                }
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                        continue;
                    }
                    if (!isNodesEquivalent(val_a, val_b)) {
                        return false;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return true;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isReferenced.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isReferenced;
        function isReferenced(node, parent, grandparent) {
            switch(parent.type){
                case "MemberExpression":
                case "OptionalMemberExpression":
                    if (parent.property === node) {
                        return !!parent.computed;
                    }
                    return parent.object === node;
                case "JSXMemberExpression":
                    return parent.object === node;
                case "VariableDeclarator":
                    return parent.init === node;
                case "ArrowFunctionExpression":
                    return parent.body === node;
                case "PrivateName":
                    return false;
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "ObjectMethod":
                    if (parent.key === node) {
                        return !!parent.computed;
                    }
                    return false;
                case "ObjectProperty":
                    if (parent.key === node) {
                        return !!parent.computed;
                    }
                    return !grandparent || grandparent.type !== "ObjectPattern";
                case "ClassProperty":
                case "ClassAccessorProperty":
                    if (parent.key === node) {
                        return !!parent.computed;
                    }
                    return true;
                case "ClassPrivateProperty":
                    return parent.key !== node;
                case "ClassDeclaration":
                case "ClassExpression":
                    return parent.superClass === node;
                case "AssignmentExpression":
                    return parent.right === node;
                case "AssignmentPattern":
                    return parent.right === node;
                case "LabeledStatement":
                    return false;
                case "CatchClause":
                    return false;
                case "RestElement":
                    return false;
                case "BreakStatement":
                case "ContinueStatement":
                    return false;
                case "FunctionDeclaration":
                case "FunctionExpression":
                    return false;
                case "ExportNamespaceSpecifier":
                case "ExportDefaultSpecifier":
                    return false;
                case "ExportSpecifier":
                    if (grandparent != null && grandparent.source) {
                        return false;
                    }
                    return parent.local === node;
                case "ImportDefaultSpecifier":
                case "ImportNamespaceSpecifier":
                case "ImportSpecifier":
                    return false;
                case "ImportAttribute":
                    return false;
                case "JSXAttribute":
                    return false;
                case "ObjectPattern":
                case "ArrayPattern":
                    return false;
                case "MetaProperty":
                    return false;
                case "ObjectTypeProperty":
                    return parent.key !== node;
                case "TSEnumMember":
                    return parent.id !== node;
                case "TSPropertySignature":
                    if (parent.key === node) {
                        return !!parent.computed;
                    }
                    return true;
            }
            return true;
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isScope.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isScope;
        var _index = require_generated();
        function isScope(node, parent) {
            if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
                return false;
            }
            if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
                return true;
            }
            return (0, _index.isScopable)(node);
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isSpecifierDefault.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isSpecifierDefault;
        var _index = require_generated();
        function isSpecifierDefault(specifier) {
            return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
                name: "default"
            });
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isValidES3Identifier.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isValidES3Identifier;
        var _isValidIdentifier = require_isValidIdentifier();
        var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set([
            "abstract",
            "boolean",
            "byte",
            "char",
            "double",
            "enum",
            "final",
            "float",
            "goto",
            "implements",
            "int",
            "interface",
            "long",
            "native",
            "package",
            "private",
            "protected",
            "public",
            "short",
            "static",
            "synchronized",
            "throws",
            "transient",
            "volatile"
        ]);
        function isValidES3Identifier(name) {
            return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
        }
    }
});
// ../../node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
    "../../node_modules/@babel/types/lib/validators/isVar.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = isVar;
        var _index = require_generated();
        var _index2 = require_constants();
        function isVar(node) {
            return (0, _index.isVariableDeclaration)(node, {
                kind: "var"
            }) && !node[_index2.BLOCK_SCOPED_SYMBOL];
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
    "../../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = gatherSequenceExpressions;
        var _getBindingIdentifiers = require_getBindingIdentifiers();
        var _index = require_generated();
        var _index2 = require_generated2();
        var _productions = require_productions();
        var _cloneNode = require_cloneNode();
        function gatherSequenceExpressions(nodes, declars) {
            var exprs = [];
            var ensureLastUndefined = true;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var node = _step.value;
                    if (!(0, _index.isEmptyStatement)(node)) {
                        ensureLastUndefined = false;
                    }
                    if ((0, _index.isExpression)(node)) {
                        exprs.push(node);
                    } else if ((0, _index.isExpressionStatement)(node)) {
                        exprs.push(node.expression);
                    } else if ((0, _index.isVariableDeclaration)(node)) {
                        if (node.kind !== "var") return;
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = node.declarations[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var declar = _step1.value;
                                var bindings = (0, _getBindingIdentifiers.default)(declar);
                                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                                try {
                                    for(var _iterator2 = Object.keys(bindings)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                        var key2 = _step2.value;
                                        declars.push({
                                            kind: node.kind,
                                            id: (0, _cloneNode.default)(bindings[key2])
                                        });
                                    }
                                } catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                            _iterator2.return();
                                        }
                                    } finally{
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }
                                if (declar.init) {
                                    exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
                                }
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                        ensureLastUndefined = true;
                    } else if ((0, _index.isIfStatement)(node)) {
                        var consequent = node.consequent ? gatherSequenceExpressions([
                            node.consequent
                        ], declars) : (0, _productions.buildUndefinedNode)();
                        var alternate = node.alternate ? gatherSequenceExpressions([
                            node.alternate
                        ], declars) : (0, _productions.buildUndefinedNode)();
                        if (!consequent || !alternate) return;
                        exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
                    } else if ((0, _index.isBlockStatement)(node)) {
                        var body3 = gatherSequenceExpressions(node.body, declars);
                        if (!body3) return;
                        exprs.push(body3);
                    } else if ((0, _index.isEmptyStatement)(node)) {
                        if (nodes.indexOf(node) === 0) {
                            ensureLastUndefined = true;
                        }
                    } else {
                        return;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            if (ensureLastUndefined) {
                exprs.push((0, _productions.buildUndefinedNode)());
            }
            if (exprs.length === 1) {
                return exprs[0];
            } else {
                return (0, _index2.sequenceExpression)(exprs);
            }
        }
    }
});
// ../../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
    "../../node_modules/@babel/types/lib/converters/toSequenceExpression.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = toSequenceExpression;
        var _gatherSequenceExpressions = require_gatherSequenceExpressions();
        function toSequenceExpression(nodes, scope) {
            if (!(nodes != null && nodes.length)) return;
            var declars = [];
            var result = (0, _gatherSequenceExpressions.default)(nodes, declars);
            if (!result) return;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = declars[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var declar = _step.value;
                    scope.push(declar);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return result;
        }
    }
});
// ../../node_modules/@babel/types/lib/index.js
var require_lib4 = __commonJS({
    "../../node_modules/@babel/types/lib/index.js": function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _exportNames = {
            react: true,
            assertNode: true,
            createTypeAnnotationBasedOnTypeof: true,
            createUnionTypeAnnotation: true,
            createFlowUnionType: true,
            createTSUnionType: true,
            cloneNode: true,
            clone: true,
            cloneDeep: true,
            cloneDeepWithoutLoc: true,
            cloneWithoutLoc: true,
            addComment: true,
            addComments: true,
            inheritInnerComments: true,
            inheritLeadingComments: true,
            inheritsComments: true,
            inheritTrailingComments: true,
            removeComments: true,
            ensureBlock: true,
            toBindingIdentifierName: true,
            toBlock: true,
            toComputedKey: true,
            toExpression: true,
            toIdentifier: true,
            toKeyAlias: true,
            toStatement: true,
            valueToNode: true,
            appendToMemberExpression: true,
            inherits: true,
            prependToMemberExpression: true,
            removeProperties: true,
            removePropertiesDeep: true,
            removeTypeDuplicates: true,
            getAssignmentIdentifiers: true,
            getBindingIdentifiers: true,
            getOuterBindingIdentifiers: true,
            getFunctionName: true,
            traverse: true,
            traverseFast: true,
            shallowEqual: true,
            is: true,
            isBinding: true,
            isBlockScoped: true,
            isImmutable: true,
            isLet: true,
            isNode: true,
            isNodesEquivalent: true,
            isPlaceholderType: true,
            isReferenced: true,
            isScope: true,
            isSpecifierDefault: true,
            isType: true,
            isValidES3Identifier: true,
            isValidIdentifier: true,
            isVar: true,
            matchesPattern: true,
            validate: true,
            buildMatchMemberExpression: true,
            __internal__deprecationWarning: true
        };
        Object.defineProperty(exports, "__internal__deprecationWarning", {
            enumerable: true,
            get: function get3() {
                return _deprecationWarning.default;
            }
        });
        Object.defineProperty(exports, "addComment", {
            enumerable: true,
            get: function get3() {
                return _addComment.default;
            }
        });
        Object.defineProperty(exports, "addComments", {
            enumerable: true,
            get: function get3() {
                return _addComments.default;
            }
        });
        Object.defineProperty(exports, "appendToMemberExpression", {
            enumerable: true,
            get: function get3() {
                return _appendToMemberExpression.default;
            }
        });
        Object.defineProperty(exports, "assertNode", {
            enumerable: true,
            get: function get3() {
                return _assertNode.default;
            }
        });
        Object.defineProperty(exports, "buildMatchMemberExpression", {
            enumerable: true,
            get: function get3() {
                return _buildMatchMemberExpression.default;
            }
        });
        Object.defineProperty(exports, "clone", {
            enumerable: true,
            get: function get3() {
                return _clone.default;
            }
        });
        Object.defineProperty(exports, "cloneDeep", {
            enumerable: true,
            get: function get3() {
                return _cloneDeep.default;
            }
        });
        Object.defineProperty(exports, "cloneDeepWithoutLoc", {
            enumerable: true,
            get: function get3() {
                return _cloneDeepWithoutLoc.default;
            }
        });
        Object.defineProperty(exports, "cloneNode", {
            enumerable: true,
            get: function get3() {
                return _cloneNode.default;
            }
        });
        Object.defineProperty(exports, "cloneWithoutLoc", {
            enumerable: true,
            get: function get3() {
                return _cloneWithoutLoc.default;
            }
        });
        Object.defineProperty(exports, "createFlowUnionType", {
            enumerable: true,
            get: function get3() {
                return _createFlowUnionType.default;
            }
        });
        Object.defineProperty(exports, "createTSUnionType", {
            enumerable: true,
            get: function get3() {
                return _createTSUnionType.default;
            }
        });
        Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
            enumerable: true,
            get: function get3() {
                return _createTypeAnnotationBasedOnTypeof.default;
            }
        });
        Object.defineProperty(exports, "createUnionTypeAnnotation", {
            enumerable: true,
            get: function get3() {
                return _createFlowUnionType.default;
            }
        });
        Object.defineProperty(exports, "ensureBlock", {
            enumerable: true,
            get: function get3() {
                return _ensureBlock.default;
            }
        });
        Object.defineProperty(exports, "getAssignmentIdentifiers", {
            enumerable: true,
            get: function get3() {
                return _getAssignmentIdentifiers.default;
            }
        });
        Object.defineProperty(exports, "getBindingIdentifiers", {
            enumerable: true,
            get: function get3() {
                return _getBindingIdentifiers.default;
            }
        });
        Object.defineProperty(exports, "getFunctionName", {
            enumerable: true,
            get: function get3() {
                return _getFunctionName.default;
            }
        });
        Object.defineProperty(exports, "getOuterBindingIdentifiers", {
            enumerable: true,
            get: function get3() {
                return _getOuterBindingIdentifiers.default;
            }
        });
        Object.defineProperty(exports, "inheritInnerComments", {
            enumerable: true,
            get: function get3() {
                return _inheritInnerComments.default;
            }
        });
        Object.defineProperty(exports, "inheritLeadingComments", {
            enumerable: true,
            get: function get3() {
                return _inheritLeadingComments.default;
            }
        });
        Object.defineProperty(exports, "inheritTrailingComments", {
            enumerable: true,
            get: function get3() {
                return _inheritTrailingComments.default;
            }
        });
        Object.defineProperty(exports, "inherits", {
            enumerable: true,
            get: function get3() {
                return _inherits.default;
            }
        });
        Object.defineProperty(exports, "inheritsComments", {
            enumerable: true,
            get: function get3() {
                return _inheritsComments.default;
            }
        });
        Object.defineProperty(exports, "is", {
            enumerable: true,
            get: function get3() {
                return _is.default;
            }
        });
        Object.defineProperty(exports, "isBinding", {
            enumerable: true,
            get: function get3() {
                return _isBinding.default;
            }
        });
        Object.defineProperty(exports, "isBlockScoped", {
            enumerable: true,
            get: function get3() {
                return _isBlockScoped.default;
            }
        });
        Object.defineProperty(exports, "isImmutable", {
            enumerable: true,
            get: function get3() {
                return _isImmutable.default;
            }
        });
        Object.defineProperty(exports, "isLet", {
            enumerable: true,
            get: function get3() {
                return _isLet.default;
            }
        });
        Object.defineProperty(exports, "isNode", {
            enumerable: true,
            get: function get3() {
                return _isNode.default;
            }
        });
        Object.defineProperty(exports, "isNodesEquivalent", {
            enumerable: true,
            get: function get3() {
                return _isNodesEquivalent.default;
            }
        });
        Object.defineProperty(exports, "isPlaceholderType", {
            enumerable: true,
            get: function get3() {
                return _isPlaceholderType.default;
            }
        });
        Object.defineProperty(exports, "isReferenced", {
            enumerable: true,
            get: function get3() {
                return _isReferenced.default;
            }
        });
        Object.defineProperty(exports, "isScope", {
            enumerable: true,
            get: function get3() {
                return _isScope.default;
            }
        });
        Object.defineProperty(exports, "isSpecifierDefault", {
            enumerable: true,
            get: function get3() {
                return _isSpecifierDefault.default;
            }
        });
        Object.defineProperty(exports, "isType", {
            enumerable: true,
            get: function get3() {
                return _isType.default;
            }
        });
        Object.defineProperty(exports, "isValidES3Identifier", {
            enumerable: true,
            get: function get3() {
                return _isValidES3Identifier.default;
            }
        });
        Object.defineProperty(exports, "isValidIdentifier", {
            enumerable: true,
            get: function get3() {
                return _isValidIdentifier.default;
            }
        });
        Object.defineProperty(exports, "isVar", {
            enumerable: true,
            get: function get3() {
                return _isVar.default;
            }
        });
        Object.defineProperty(exports, "matchesPattern", {
            enumerable: true,
            get: function get3() {
                return _matchesPattern.default;
            }
        });
        Object.defineProperty(exports, "prependToMemberExpression", {
            enumerable: true,
            get: function get3() {
                return _prependToMemberExpression.default;
            }
        });
        exports.react = void 0;
        Object.defineProperty(exports, "removeComments", {
            enumerable: true,
            get: function get3() {
                return _removeComments.default;
            }
        });
        Object.defineProperty(exports, "removeProperties", {
            enumerable: true,
            get: function get3() {
                return _removeProperties.default;
            }
        });
        Object.defineProperty(exports, "removePropertiesDeep", {
            enumerable: true,
            get: function get3() {
                return _removePropertiesDeep.default;
            }
        });
        Object.defineProperty(exports, "removeTypeDuplicates", {
            enumerable: true,
            get: function get3() {
                return _removeTypeDuplicates.default;
            }
        });
        Object.defineProperty(exports, "shallowEqual", {
            enumerable: true,
            get: function get3() {
                return _shallowEqual.default;
            }
        });
        Object.defineProperty(exports, "toBindingIdentifierName", {
            enumerable: true,
            get: function get3() {
                return _toBindingIdentifierName.default;
            }
        });
        Object.defineProperty(exports, "toBlock", {
            enumerable: true,
            get: function get3() {
                return _toBlock.default;
            }
        });
        Object.defineProperty(exports, "toComputedKey", {
            enumerable: true,
            get: function get3() {
                return _toComputedKey.default;
            }
        });
        Object.defineProperty(exports, "toExpression", {
            enumerable: true,
            get: function get3() {
                return _toExpression.default;
            }
        });
        Object.defineProperty(exports, "toIdentifier", {
            enumerable: true,
            get: function get3() {
                return _toIdentifier.default;
            }
        });
        Object.defineProperty(exports, "toKeyAlias", {
            enumerable: true,
            get: function get3() {
                return _toKeyAlias.default;
            }
        });
        Object.defineProperty(exports, "toStatement", {
            enumerable: true,
            get: function get3() {
                return _toStatement.default;
            }
        });
        Object.defineProperty(exports, "traverse", {
            enumerable: true,
            get: function get3() {
                return _traverse.default;
            }
        });
        Object.defineProperty(exports, "traverseFast", {
            enumerable: true,
            get: function get3() {
                return _traverseFast.default;
            }
        });
        Object.defineProperty(exports, "validate", {
            enumerable: true,
            get: function get3() {
                return _validate.default;
            }
        });
        Object.defineProperty(exports, "valueToNode", {
            enumerable: true,
            get: function get3() {
                return _valueToNode.default;
            }
        });
        var _isReactComponent = require_isReactComponent();
        var _isCompatTag = require_isCompatTag();
        var _buildChildren = require_buildChildren();
        var _assertNode = require_assertNode();
        var _index = require_generated3();
        Object.keys(_index).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _index[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _index[key2];
                }
            });
        });
        var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
        var _createFlowUnionType = require_createFlowUnionType();
        var _createTSUnionType = require_createTSUnionType();
        var _index2 = require_generated2();
        Object.keys(_index2).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _index2[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _index2[key2];
                }
            });
        });
        var _uppercase = require_uppercase();
        Object.keys(_uppercase).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _uppercase[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _uppercase[key2];
                }
            });
        });
        var _productions = require_productions();
        Object.keys(_productions).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _productions[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _productions[key2];
                }
            });
        });
        var _cloneNode = require_cloneNode();
        var _clone = require_clone();
        var _cloneDeep = require_cloneDeep();
        var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
        var _cloneWithoutLoc = require_cloneWithoutLoc();
        var _addComment = require_addComment();
        var _addComments = require_addComments();
        var _inheritInnerComments = require_inheritInnerComments();
        var _inheritLeadingComments = require_inheritLeadingComments();
        var _inheritsComments = require_inheritsComments();
        var _inheritTrailingComments = require_inheritTrailingComments();
        var _removeComments = require_removeComments();
        var _index3 = require_generated4();
        Object.keys(_index3).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _index3[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _index3[key2];
                }
            });
        });
        var _index4 = require_constants();
        Object.keys(_index4).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _index4[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _index4[key2];
                }
            });
        });
        var _ensureBlock = require_ensureBlock();
        var _toBindingIdentifierName = require_toBindingIdentifierName();
        var _toBlock = require_toBlock();
        var _toComputedKey = require_toComputedKey();
        var _toExpression = require_toExpression();
        var _toIdentifier = require_toIdentifier();
        var _toKeyAlias = require_toKeyAlias();
        var _toStatement = require_toStatement();
        var _valueToNode = require_valueToNode();
        var _index5 = require_definitions();
        Object.keys(_index5).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _index5[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _index5[key2];
                }
            });
        });
        var _appendToMemberExpression = require_appendToMemberExpression();
        var _inherits = require_inherits();
        var _prependToMemberExpression = require_prependToMemberExpression();
        var _removeProperties = require_removeProperties();
        var _removePropertiesDeep = require_removePropertiesDeep();
        var _removeTypeDuplicates = require_removeTypeDuplicates();
        var _getAssignmentIdentifiers = require_getAssignmentIdentifiers();
        var _getBindingIdentifiers = require_getBindingIdentifiers();
        var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
        var _getFunctionName = require_getFunctionName();
        var _traverse = require_traverse();
        Object.keys(_traverse).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _traverse[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _traverse[key2];
                }
            });
        });
        var _traverseFast = require_traverseFast();
        var _shallowEqual = require_shallowEqual();
        var _is = require_is();
        var _isBinding = require_isBinding();
        var _isBlockScoped = require_isBlockScoped();
        var _isImmutable = require_isImmutable();
        var _isLet = require_isLet();
        var _isNode = require_isNode();
        var _isNodesEquivalent = require_isNodesEquivalent();
        var _isPlaceholderType = require_isPlaceholderType();
        var _isReferenced = require_isReferenced();
        var _isScope = require_isScope();
        var _isSpecifierDefault = require_isSpecifierDefault();
        var _isType = require_isType();
        var _isValidES3Identifier = require_isValidES3Identifier();
        var _isValidIdentifier = require_isValidIdentifier();
        var _isVar = require_isVar();
        var _matchesPattern = require_matchesPattern();
        var _validate = require_validate();
        var _buildMatchMemberExpression = require_buildMatchMemberExpression();
        var _index6 = require_generated();
        Object.keys(_index6).forEach(function(key2) {
            if (key2 === "default" || key2 === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key2)) return;
            if (key2 in exports && exports[key2] === _index6[key2]) return;
            Object.defineProperty(exports, key2, {
                enumerable: true,
                get: function get3() {
                    return _index6[key2];
                }
            });
        });
        var _deprecationWarning = require_deprecationWarning();
        var react = exports.react = {
            isReactComponent: _isReactComponent.default,
            isCompatTag: _isCompatTag.default,
            buildChildren: _buildChildren.default
        };
        {
            exports.toSequenceExpression = require_toSequenceExpression().default;
        }
        if (process.env.BABEL_TYPES_8_BREAKING) {
            console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
        }
    }
});
// src/components/core/SuperinterfaceProvider/index.tsx
import { useRef } from "react";
// src/lib/misc/merge/index.ts
import _2 from "lodash";
// src/lib/misc/merge/customizer.ts
import _ from "lodash";
var customizer = function(objectValue, srcValue) {
    if (!_.isArray(objectValue)) return;
    return srcValue;
};
// src/lib/misc/merge/index.ts
var merge = function merge2(obj) {
    var _$_2;
    for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        sources[_key - 1] = arguments[_key];
    }
    return (_$_2 = _2).mergeWith.apply(_$_2, [
        _2.cloneDeep(obj)
    ].concat(_to_consumable_array(sources), [
        customizer
    ]));
};
// src/contexts/core/SuperinterfaceContext/index.tsx
import { createContext } from "react";
// src/lib/superinterfaceCloud/baseUrl.ts
var baseUrl = "https://superinterface.ai/api/cloud";
// src/lib/threadIdStorage/cookieOptions/get.ts
import Cookies from "js-cookie";
// src/lib/threadIdStorage/key.ts
var key = function(_ref) {
    var assistantId = _ref.assistantId;
    return "superinterface-".concat(assistantId, "-threadId");
};
// src/lib/threadIdStorage/cookieOptions/get.ts
var get = function(_ref) {
    var _Cookies$get;
    var assistantId = _ref.assistantId;
    return (_Cookies$get = Cookies.get(key({
        assistantId: assistantId
    }))) !== null && _Cookies$get !== void 0 ? _Cookies$get : null;
};
// src/lib/threadIdStorage/cookieOptions/set.ts
import Cookies2 from "js-cookie";
var set = function(_ref) {
    var assistantId = _ref.assistantId, threadId = _ref.threadId;
    return Cookies2.set(key({
        assistantId: assistantId
    }), threadId);
};
// src/lib/threadIdStorage/cookieOptions/remove.ts
import Cookies3 from "js-cookie";
var remove = function(_ref) {
    var assistantId = _ref.assistantId;
    return Cookies3.remove(key({
        assistantId: assistantId
    }));
};
// src/lib/threadIdStorage/cookieOptions/index.ts
var cookieOptions = {
    get: get,
    set: set,
    remove: remove
};
// src/lib/threadIdStorage/localStorageOptions/get.ts
var get2 = function(_ref) {
    var assistantId = _ref.assistantId;
    return window.localStorage.getItem(key({
        assistantId: assistantId
    }));
};
// src/lib/threadIdStorage/localStorageOptions/set.ts
var set2 = function(_ref) {
    var assistantId = _ref.assistantId, threadId = _ref.threadId;
    return window.localStorage.setItem(key({
        assistantId: assistantId
    }), threadId);
};
// src/lib/threadIdStorage/localStorageOptions/remove.ts
var remove2 = function(_ref) {
    var assistantId = _ref.assistantId;
    return window.localStorage.removeItem(key({
        assistantId: assistantId
    }));
};
// src/lib/threadIdStorage/localStorageOptions/index.ts
var localStorageOptions = {
    get: get2,
    set: set2,
    remove: remove2
};
// src/lib/iframes/isIframe.ts
var isIframe = function() {
    if (typeof window === "undefined") return false;
    return window.self !== window.top;
};
// src/contexts/core/SuperinterfaceContext/index.tsx
var SuperinterfaceContext = /* @__PURE__ */ createContext({
    baseUrl: baseUrl,
    variables: {},
    defaultOptions: {
        queries: {},
        mutations: {}
    },
    threadIdStorageOptions: isIframe() ? localStorageOptions : cookieOptions,
    createMessageAbortControllerRef: {
        current: null
    }
});
// src/hooks/core/useSuperinterfaceContext/index.ts
import { useContext } from "react";
var useSuperinterfaceContext = function() {
    return useContext(SuperinterfaceContext);
};
// src/components/core/SuperinterfaceProvider/index.tsx
import { jsx as _jsx } from "react/jsx-runtime";
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var SuperinterfaceProvider = function(_ref) {
    var children = _ref.children, baseUrl2 = _ref.baseUrl, variables = _ref.variables, defaultOptions = _ref.defaultOptions, threadIdStorageOptions = _ref.threadIdStorageOptions;
    var superinterfaceContext = useSuperinterfaceContext();
    var createMessageAbortControllerRef = useRef(null);
    var value = merge(superinterfaceContext, _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, baseUrl2 ? {
        baseUrl: baseUrl2
    } : {}), variables ? {
        variables: variables
    } : {}), defaultOptions ? {
        defaultOptions: defaultOptions
    } : {}), threadIdStorageOptions ? {
        threadIdStorageOptions: threadIdStorageOptions
    } : {}), {}, {
        createMessageAbortControllerRef: createMessageAbortControllerRef
    }));
    return /* @__PURE__ */ _jsx(SuperinterfaceContext.Provider, {
        value: value,
        children: children
    });
};
// src/components/threads/Thread/Messages/index.tsx
import { Flex as Flex18 } from "@radix-ui/themes";
// src/components/threads/Thread/Message/index.tsx
import { c as _c25 } from "react-compiler-runtime";
import { useMemo as useMemo9 } from "react";
import { isEmpty as isEmpty2 } from "radash";
import { Box as Box9 } from "@radix-ui/themes";
// src/components/skeletons/StartingContentSkeleton/index.tsx
import { Skeleton } from "@radix-ui/themes";
import { jsx as _jsx2 } from "react/jsx-runtime";
var StartingContentSkeleton = function() {
    return /* @__PURE__ */ _jsx2(Skeleton, {
        loading: true,
        mt: "1",
        height: "var(--space-4)",
        width: "var(--space-4)",
        style: {
            borderRadius: "var(--radius-6)",
            flexShrink: 0
        }
    });
};
// src/components/runSteps/RunSteps/index.tsx
import { c as _c7 } from "react-compiler-runtime";
import { Flex as Flex5 } from "@radix-ui/themes";
import { useContext as useContext3 } from "react";
// src/contexts/components/ComponentsContext/index.tsx
import { createContext as createContext3 } from "react";
// src/components/runSteps/RunStep/index.tsx
import { c as _c6 } from "react-compiler-runtime";
// src/components/runSteps/RunStep/ToolCalls/index.tsx
import { Flex as Flex4 } from "@radix-ui/themes";
// src/components/runSteps/RunStep/ToolCalls/ToolCall/index.tsx
import { c as _c5 } from "react-compiler-runtime";
// src/components/runSteps/RunStep/ToolCalls/ToolCall/Fn/index.tsx
import { c as _c3 } from "react-compiler-runtime";
import { useContext as useContext2 } from "react";
// src/contexts/functions/FunctionComponentsContext/index.tsx
import { createContext as createContext2 } from "react";
var FunctionComponentsContext = /* @__PURE__ */ createContext2({});
// src/components/functions/FunctionBase/index.tsx
import { Popover, Flex as Flex2 } from "@radix-ui/themes";
// src/components/toolCalls/ToolCallBase/index.tsx
import { Flex, Button } from "@radix-ui/themes";
import { jsx as _jsx3 } from "react/jsx-runtime";
var ToolCallBase = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx3(Flex, {
        py: "1",
        ml: "-2",
        children: /* @__PURE__ */ _jsx3(Button, {
            size: "1",
            color: "gold",
            variant: "outline",
            style: {
                boxShadow: "none"
            },
            children: children
        })
    });
};
// src/components/toolCalls/ToolCallBase/ToolCallTitle.tsx
import { Text } from "@radix-ui/themes";
import { jsx as _jsx4 } from "react/jsx-runtime";
var ToolCallTitle = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx4(Text, {
        weight: "regular",
        children: children
    });
};
// src/components/toolCalls/ToolCallBase/ToolCallIcon.tsx
import { c as _c } from "react-compiler-runtime";
import { CircleIcon, CircleBackslashIcon, CheckCircledIcon } from "@radix-ui/react-icons";
import { jsx as _jsx5 } from "react/jsx-runtime";
var ToolCallIcon = function(t0) {
    var $ = _c(3);
    var runStep = t0.runStep;
    if (runStep.completed_at) {
        var t1;
        if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
            t1 = /* @__PURE__ */ _jsx5(CheckCircledIcon, {});
            $[0] = t1;
        } else {
            t1 = $[0];
        }
        return t1;
    } else {
        if (runStep.cancelled_at || runStep.failed_at || runStep.status === "expired") {
            var _t;
            if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
                _t = /* @__PURE__ */ _jsx5(CircleBackslashIcon, {});
                $[1] = _t;
            } else {
                _t = $[1];
            }
            return _t;
        } else {
            var _t2;
            if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
                _t2 = /* @__PURE__ */ _jsx5(CircleIcon, {});
                $[2] = _t2;
            } else {
                _t2 = $[2];
            }
            return _t2;
        }
    }
};
// src/components/functions/FunctionBase/Content/index.tsx
import { c as _c2 } from "react-compiler-runtime";
import { useMemo } from "react";
import { Code, Box } from "@radix-ui/themes";
// src/components/functions/FunctionBase/Content/lib/formattedJsonOrRaw.ts
var formattedJsonOrRaw = function(_ref) {
    var value = _ref.value;
    if (!value) {
        return null;
    }
    try {
        return JSON.stringify(JSON.parse(value), null, 2);
    } catch (error) {
        if (typeof value === "string") {
            return value;
        } else {
            return JSON.stringify(value, null, 2);
        }
    }
};
// src/components/functions/FunctionBase/Content/index.tsx
import { jsx as _jsx6, jsxs as _jsxs } from "react/jsx-runtime";
var Content = function(t0) {
    var $ = _c2(12);
    var fn = t0.fn;
    var t1;
    var t2;
    if ($[0] !== fn.arguments) {
        t2 = formattedJsonOrRaw({
            value: fn.arguments
        });
        $[0] = fn.arguments;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    t1 = t2;
    var args = t1;
    var t3;
    var t4;
    if ($[2] !== fn.output) {
        t4 = formattedJsonOrRaw({
            value: fn.output
        });
        $[2] = fn.output;
        $[3] = t4;
    } else {
        t4 = $[3];
    }
    t3 = t4;
    var output = t3;
    var t5;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t5 = {
            whiteSpace: "pre",
            wordBreak: "break-word"
        };
        $[4] = t5;
    } else {
        t5 = $[4];
    }
    var t6;
    if ($[5] !== args) {
        t6 = args && /* @__PURE__ */ _jsx6(Box, {
            children: args
        });
        $[5] = args;
        $[6] = t6;
    } else {
        t6 = $[6];
    }
    var t7;
    if ($[7] !== output) {
        t7 = output && /* @__PURE__ */ _jsx6(Box, {
            children: output
        });
        $[7] = output;
        $[8] = t7;
    } else {
        t7 = $[8];
    }
    var t8;
    if ($[9] !== t6 || $[10] !== t7) {
        t8 = /* @__PURE__ */ _jsxs(Code, {
            variant: "ghost",
            color: "gold",
            style: t5,
            children: [
                t6,
                t7
            ]
        });
        $[9] = t6;
        $[10] = t7;
        $[11] = t8;
    } else {
        t8 = $[11];
    }
    return t8;
};
// src/components/functions/FunctionBase/index.tsx
import { jsx as _jsx7, jsxs as _jsxs2 } from "react/jsx-runtime";
var FunctionBase = function(_ref) {
    var fn = _ref.fn, runStep = _ref.runStep, title2 = _ref.title;
    return /* @__PURE__ */ _jsxs2(Popover.Root, {
        children: [
            /* @__PURE__ */ _jsx7(Popover.Trigger, {
                children: /* @__PURE__ */ _jsx7(Flex2, {
                    children: /* @__PURE__ */ _jsxs2(ToolCallBase, {
                        children: [
                            /* @__PURE__ */ _jsx7(ToolCallIcon, {
                                runStep: runStep
                            }),
                            /* @__PURE__ */ _jsx7(ToolCallTitle, {
                                children: title2
                            })
                        ]
                    })
                })
            }),
            /* @__PURE__ */ _jsx7(Popover.Content, {
                style: {
                    maxHeight: "200px"
                },
                children: /* @__PURE__ */ _jsx7(Content, {
                    fn: fn
                })
            })
        ]
    });
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/Fn/DefaultFunction/lib/title.ts
var title = function(_ref) {
    var fn = _ref.fn, runStep = _ref.runStep;
    if (runStep.completed_at) {
        return "Finished ".concat(fn.name);
    } else if (runStep.cancelled_at) {
        return "Cancelled ".concat(fn.name);
    } else {
        return "Calling ".concat(fn.name);
    }
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/Fn/DefaultFunction/index.tsx
import { jsx as _jsx8 } from "react/jsx-runtime";
var DefaultFunction = function(_ref) {
    var fn = _ref.fn, runStep = _ref.runStep;
    return /* @__PURE__ */ _jsx8(FunctionBase, {
        fn: fn,
        runStep: runStep,
        title: title({
            runStep: runStep,
            fn: fn
        })
    });
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/Fn/index.tsx
import { jsx as _jsx9 } from "react/jsx-runtime";
var Fn = function(t0) {
    var $ = _c3(4);
    var fn = t0.fn, runStep = t0.runStep;
    var functionComponentsContext = useContext2(FunctionComponentsContext);
    var Component = functionComponentsContext[fn.name] || DefaultFunction;
    var t1;
    if ($[0] !== Component || $[1] !== fn || $[2] !== runStep) {
        t1 = /* @__PURE__ */ _jsx9(Component, {
            fn: fn,
            runStep: runStep
        });
        $[0] = Component;
        $[1] = fn;
        $[2] = runStep;
        $[3] = t1;
    } else {
        t1 = $[3];
    }
    return t1;
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/CodeInterpreter/index.tsx
import { Popover as Popover2, Flex as Flex3 } from "@radix-ui/themes";
// src/components/runSteps/RunStep/ToolCalls/ToolCall/CodeInterpreter/Content.tsx
import { c as _c4 } from "react-compiler-runtime";
import { Code as Code2, Box as Box2 } from "@radix-ui/themes";
import { jsx as _jsx10, jsxs as _jsxs3 } from "react/jsx-runtime";
var Content2 = function(t0) {
    var $ = _c4(10);
    var codeInterpreter = t0.codeInterpreter;
    if (!codeInterpreter.input) {
        return null;
    }
    var t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = {
            whiteSpace: "pre",
            wordBreak: "break-word"
        };
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    var t2;
    if ($[1] !== codeInterpreter.input) {
        t2 = /* @__PURE__ */ _jsx10(Box2, {
            children: codeInterpreter.input
        });
        $[1] = codeInterpreter.input;
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    var t3;
    if ($[3] !== codeInterpreter.outputs) {
        t3 = JSON.stringify(codeInterpreter.outputs);
        $[3] = codeInterpreter.outputs;
        $[4] = t3;
    } else {
        t3 = $[4];
    }
    var t4;
    if ($[5] !== t3) {
        t4 = /* @__PURE__ */ _jsx10(Box2, {
            children: t3
        });
        $[5] = t3;
        $[6] = t4;
    } else {
        t4 = $[6];
    }
    var t5;
    if ($[7] !== t2 || $[8] !== t4) {
        t5 = /* @__PURE__ */ _jsxs3(Code2, {
            variant: "ghost",
            color: "gold",
            style: t1,
            children: [
                t2,
                t4
            ]
        });
        $[7] = t2;
        $[8] = t4;
        $[9] = t5;
    } else {
        t5 = $[9];
    }
    return t5;
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/CodeInterpreter/index.tsx
import { jsx as _jsx11, jsxs as _jsxs4 } from "react/jsx-runtime";
var CodeInterpreter = function(_ref) {
    var codeInterpreter = _ref.codeInterpreter, runStep = _ref.runStep;
    return /* @__PURE__ */ _jsxs4(Popover2.Root, {
        children: [
            /* @__PURE__ */ _jsx11(Popover2.Trigger, {
                children: /* @__PURE__ */ _jsx11(Flex3, {
                    children: /* @__PURE__ */ _jsxs4(ToolCallBase, {
                        children: [
                            /* @__PURE__ */ _jsx11(ToolCallIcon, {
                                runStep: runStep
                            }),
                            /* @__PURE__ */ _jsx11(ToolCallTitle, {
                                children: "Using code interpreter"
                            })
                        ]
                    })
                })
            }),
            /* @__PURE__ */ _jsx11(Popover2.Content, {
                maxHeight: "200px",
                children: /* @__PURE__ */ _jsx11(Content2, {
                    codeInterpreter: codeInterpreter
                })
            })
        ]
    });
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/FileSearch.tsx
import { jsx as _jsx12, jsxs as _jsxs5 } from "react/jsx-runtime";
var FileSearch = function(_ref) {
    var runStep = _ref.runStep, toolCall = _ref.toolCall;
    return /* @__PURE__ */ _jsxs5(ToolCallBase, {
        children: [
            /* @__PURE__ */ _jsx12(ToolCallIcon, {
                runStep: runStep
            }),
            /* @__PURE__ */ _jsx12(ToolCallTitle, {
                children: "Searching files"
            })
        ]
    });
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/Fallback.tsx
import { jsx as _jsx13, jsxs as _jsxs6 } from "react/jsx-runtime";
var Fallback = function(_ref) {
    var runStep = _ref.runStep, toolCall = _ref.toolCall;
    return /* @__PURE__ */ _jsxs6(ToolCallBase, {
        children: [
            /* @__PURE__ */ _jsx13(ToolCallIcon, {
                runStep: runStep
            }),
            /* @__PURE__ */ _jsxs6(ToolCallTitle, {
                children: [
                    "Using tool: ",
                    toolCall.type
                ]
            })
        ]
    });
};
// src/components/runSteps/RunStep/ToolCalls/ToolCall/index.tsx
import { jsx as _jsx14 } from "react/jsx-runtime";
var ToolCall = function(t0) {
    var $ = _c5(12);
    var toolCall = t0.toolCall, runStep = t0.runStep;
    if (toolCall.type === "function") {
        var _t;
        if ($[0] !== runStep || $[1] !== toolCall.function) {
            _t = /* @__PURE__ */ _jsx14(Fn, {
                fn: toolCall.function,
                runStep: runStep
            });
            $[0] = runStep;
            $[1] = toolCall.function;
            $[2] = _t;
        } else {
            _t = $[2];
        }
        return _t;
    }
    if (toolCall.type === "code_interpreter") {
        var _t2;
        if ($[3] !== runStep || $[4] !== toolCall.code_interpreter) {
            _t2 = /* @__PURE__ */ _jsx14(CodeInterpreter, {
                codeInterpreter: toolCall.code_interpreter,
                runStep: runStep
            });
            $[3] = runStep;
            $[4] = toolCall.code_interpreter;
            $[5] = _t2;
        } else {
            _t2 = $[5];
        }
        return _t2;
    }
    if (toolCall.type === "file_search") {
        var _t3;
        if ($[6] !== runStep || $[7] !== toolCall) {
            _t3 = /* @__PURE__ */ _jsx14(FileSearch, {
                toolCall: toolCall,
                runStep: runStep
            });
            $[6] = runStep;
            $[7] = toolCall;
            $[8] = _t3;
        } else {
            _t3 = $[8];
        }
        return _t3;
    }
    var t1;
    if ($[9] !== runStep || $[10] !== toolCall) {
        t1 = /* @__PURE__ */ _jsx14(Fallback, {
            toolCall: toolCall,
            runStep: runStep
        });
        $[9] = runStep;
        $[10] = toolCall;
        $[11] = t1;
    } else {
        t1 = $[11];
    }
    return t1;
};
// src/components/runSteps/RunStep/ToolCalls/Starting/index.tsx
import { Popover as Popover3, Text as Text2 } from "@radix-ui/themes";
import { CircleIcon as CircleIcon2 } from "@radix-ui/react-icons";
import { jsx as _jsx15, jsxs as _jsxs7 } from "react/jsx-runtime";
var Starting = function() {
    return /* @__PURE__ */ _jsxs7(Popover3.Root, {
        children: [
            /* @__PURE__ */ _jsxs7(ToolCallBase, {
                children: [
                    /* @__PURE__ */ _jsx15(CircleIcon2, {}),
                    /* @__PURE__ */ _jsx15(ToolCallTitle, {
                        children: "Starting actions"
                    })
                ]
            }),
            /* @__PURE__ */ _jsx15(Popover3.Content, {
                style: {
                    maxHeight: "500px"
                },
                children: /* @__PURE__ */ _jsx15(Text2, {
                    children: "Getting ready to connect to domain API"
                })
            })
        ]
    });
};
// src/components/runSteps/RunStep/ToolCalls/index.tsx
import { jsx as _jsx16, jsxs as _jsxs8 } from "react/jsx-runtime";
var Root = function(_ref) {
    var children = _ref.children, className = _ref.className, style = _ref.style;
    return /* @__PURE__ */ _jsx16(Flex4, {
        direction: "column",
        className: className,
        style: style,
        children: children
    });
};
var ToolCalls = function(_ref2) {
    var stepDetails = _ref2.stepDetails, runStep = _ref2.runStep, className = _ref2.className, style = _ref2.style;
    return /* @__PURE__ */ _jsxs8(Root, {
        className: className,
        style: style,
        children: [
            !stepDetails.tool_calls.length && /* @__PURE__ */ _jsx16(Starting, {}),
            stepDetails.tool_calls.map(function(toolCall) {
                return /* @__PURE__ */ _jsx16(ToolCall, {
                    toolCall: toolCall,
                    runStep: runStep
                }, toolCall.id);
            })
        ]
    });
};
ToolCalls.Root = Root;
ToolCalls.Starting = Starting;
ToolCalls.ToolCall = ToolCall;
// src/components/runSteps/RunStep/index.tsx
import { jsx as _jsx17 } from "react/jsx-runtime";
var RunStep = function(t0) {
    var $ = _c6(4);
    var runStep = t0.runStep, className = t0.className, style = t0.style;
    if (runStep.step_details.type === "tool_calls") {
        var t1;
        if ($[0] !== className || $[1] !== runStep || $[2] !== style) {
            t1 = /* @__PURE__ */ _jsx17(ToolCalls, {
                className: className,
                style: style,
                stepDetails: runStep.step_details,
                runStep: runStep
            });
            $[0] = className;
            $[1] = runStep;
            $[2] = style;
            $[3] = t1;
        } else {
            t1 = $[3];
        }
        return t1;
    }
    return null;
};
RunStep.ToolCalls = ToolCalls;
// src/contexts/components/ComponentsContext/index.tsx
var ComponentsContext = /* @__PURE__ */ createContext3({
    components: {
        RunStep: RunStep
    }
});
// src/components/runSteps/RunSteps/index.tsx
import { jsx as _jsx18 } from "react/jsx-runtime";
var RunSteps = function(t0) {
    var $ = _c7(7);
    var runSteps = t0.runSteps;
    var componentsContext = useContext3(ComponentsContext);
    var Component = componentsContext.components.RunStep;
    var t1;
    if ($[0] !== Component || $[1] !== runSteps) {
        var _t;
        if ($[3] !== Component) {
            _t = function(runStep) {
                return /* @__PURE__ */ _jsx18(Component, {
                    runStep: runStep
                }, runStep.id);
            };
            $[3] = Component;
            $[4] = _t;
        } else {
            _t = $[4];
        }
        t1 = runSteps.map(_t);
        $[0] = Component;
        $[1] = runSteps;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    var t2;
    if ($[5] !== t1) {
        t2 = /* @__PURE__ */ _jsx18(Flex5, {
            direction: "column-reverse",
            children: t1
        });
        $[5] = t1;
        $[6] = t2;
    } else {
        t2 = $[6];
    }
    return t2;
};
// src/hooks/messages/useIsMutatingMessage/index.ts
import { c as _c8 } from "react-compiler-runtime";
import { useMemo as useMemo2 } from "react";
import { useIsMutating } from "@tanstack/react-query";
var useIsMutatingMessage = function() {
    var $ = _c8(2);
    var threadContext = useSuperinterfaceContext();
    var t0;
    if ($[0] !== threadContext.variables) {
        t0 = {
            mutationKey: [
                "createMessage",
                threadContext.variables
            ]
        };
        $[0] = threadContext.variables;
        $[1] = t0;
    } else {
        t0 = $[1];
    }
    var mutatingMessagesCount = useIsMutating(t0);
    var t1;
    t1 = mutatingMessagesCount > 0;
    var isMutatingMessage = t1;
    return isMutatingMessage;
};
// src/contexts/messages/MessageContext/index.ts
import { createContext as createContext4 } from "react";
var MessageContext = /* @__PURE__ */ createContext4({
    message: null
});
// src/components/threads/Thread/Message/Provider.tsx
var Provider = MessageContext.Provider;
// src/components/threads/Thread/Message/Attachments/index.tsx
import { c as _c9 } from "react-compiler-runtime";
import { Flex as Flex6, Badge } from "@radix-ui/themes";
import { FileIcon } from "@radix-ui/react-icons";
import { jsx as _jsx19, jsxs as _jsxs9 } from "react/jsx-runtime";
var Attachments = function(t0) {
    var _message$attachments;
    var $ = _c9(4);
    var message = t0.message;
    if (!((_message$attachments = message.attachments) !== null && _message$attachments !== void 0 && _message$attachments.length)) {
        return null;
    }
    var t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = /* @__PURE__ */ _jsx19(FileIcon, {});
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    var t2 = message.attachments.length > 1 ? "s" : "";
    var t3;
    if ($[1] !== message.attachments.length || $[2] !== t2) {
        t3 = /* @__PURE__ */ _jsx19(Flex6, {
            align: "start",
            pb: "1",
            children: /* @__PURE__ */ _jsxs9(Badge, {
                color: "gray",
                variant: "surface",
                children: [
                    t1,
                    message.attachments.length,
                    " file",
                    t2
                ]
            })
        });
        $[1] = message.attachments.length;
        $[2] = t2;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    return t3;
};
// src/components/messages/MessageContent/ContentPart/index.tsx
import { c as _c24 } from "react-compiler-runtime";
// src/components/messages/MessageContent/ContentPart/TextContent.tsx
import { c as _c22 } from "react-compiler-runtime";
import React, { useState as useState2, useEffect as useEffect2, useMemo as useMemo8 } from "react";
import { Badge as Badge2 } from "@radix-ui/themes";
import { compile } from "@mdx-js/mdx";
import { MDXProvider, useMDXComponents } from "@mdx-js/react";
import * as runtime from "react/jsx-runtime";
// src/lib/recma/recmaFallbackComponentPlugin.ts
import { visit, CONTINUE, SKIP } from "estree-util-visit";
var recmaFallbackComponentPlugin = function() {
    return function(tree) {
        visit(tree, function(node) {
            if (node.type === "VariableDeclaration" && node.kind === "const") {
                var varDecl = node;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = varDecl.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var declarator = _step.value;
                        var _declarator$init, _declarator$init2;
                        if (declarator.id.type === "ObjectPattern" && ((_declarator$init = declarator.init) === null || _declarator$init === void 0 ? void 0 : _declarator$init.type) === "Identifier" && declarator.init.name === "_components" || declarator.id.type === "ObjectPattern" && ((_declarator$init2 = declarator.init) === null || _declarator$init2 === void 0 ? void 0 : _declarator$init2.type) === "ObjectExpression") {
                            varDecl.kind = "let";
                            return SKIP;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return CONTINUE;
        });
        visit(tree, function(node) {
            var _node$id;
            if (node.type === "FunctionDeclaration" && ((_node$id = node.id) === null || _node$id === void 0 ? void 0 : _node$id.type) === "Identifier" && node.id.name === "_missingMdxReference") {
                var funcNode = node;
                funcNode.body = {
                    type: "BlockStatement",
                    body: [
                        {
                            type: "IfStatement",
                            test: {
                                type: "Identifier",
                                name: "component"
                            },
                            consequent: {
                                type: "ReturnStatement",
                                argument: {
                                    type: "FunctionExpression",
                                    id: null,
                                    params: [
                                        {
                                            type: "Identifier",
                                            name: "props"
                                        }
                                    ],
                                    body: {
                                        type: "BlockStatement",
                                        body: [
                                            {
                                                type: "ReturnStatement",
                                                argument: {
                                                    type: "BinaryExpression",
                                                    operator: "+",
                                                    left: {
                                                        type: "BinaryExpression",
                                                        operator: "+",
                                                        left: {
                                                            type: "Literal",
                                                            value: "<"
                                                        },
                                                        right: {
                                                            type: "Identifier",
                                                            name: "id"
                                                        }
                                                    },
                                                    right: {
                                                        type: "BinaryExpression",
                                                        operator: "+",
                                                        left: {
                                                            type: "Literal",
                                                            value: "></"
                                                        },
                                                        right: {
                                                            type: "BinaryExpression",
                                                            operator: "+",
                                                            left: {
                                                                type: "Identifier",
                                                                name: "id"
                                                            },
                                                            right: {
                                                                type: "Literal",
                                                                value: ">"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        ]
                                    },
                                    generator: false,
                                    async: false
                                }
                            },
                            alternate: null
                        }
                    ]
                };
                return SKIP;
            }
            return CONTINUE;
        });
        visit(tree, function(node) {
            if (node.type === "IfStatement") {
                var ifNode = node;
                if (ifNode.test.type === "UnaryExpression" && ifNode.test.operator === "!" && ifNode.test.argument.type === "Identifier") {
                    var componentName = ifNode.test.argument.name;
                    if (ifNode.consequent.type === "ExpressionStatement" && ifNode.consequent.expression.type === "CallExpression" && ifNode.consequent.expression.callee.type === "Identifier" && ifNode.consequent.expression.callee.name === "_missingMdxReference") {
                        var assignmentExpr = {
                            type: "AssignmentExpression",
                            operator: "=",
                            left: {
                                type: "Identifier",
                                name: componentName
                            },
                            right: ifNode.consequent.expression
                        };
                        ifNode.consequent = {
                            type: "ExpressionStatement",
                            expression: assignmentExpr
                        };
                        return SKIP;
                    }
                }
            }
            return CONTINUE;
        });
    };
};
// src/hooks/markdown/useMarkdownContext/index.ts
import { useContext as useContext5 } from "react";
// src/contexts/markdown/MarkdownContext/index.ts
import { createContext as createContext6 } from "react";
// src/contexts/markdown/MarkdownContext/lib/components/index.tsx
import { Heading, Table } from "@radix-ui/themes";
// src/contexts/markdown/MarkdownContext/lib/components/Paragraph.tsx
import { Box as Box3, Text as Text3 } from "@radix-ui/themes";
import { jsx as _jsx20 } from "react/jsx-runtime";
var Paragraph = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx20(Box3, {
        pb: "3",
        children: /* @__PURE__ */ _jsx20(Text3, {
            size: "3",
            style: {
                whiteSpace: "pre-line",
                wordBreak: "break-word"
            },
            children: children
        })
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Link.tsx
import { Link as RadixLink } from "@radix-ui/themes";
import { jsx as _jsx21 } from "react/jsx-runtime";
var Link = function(_ref) {
    var children = _ref.children, href = _ref.href, download = _ref.download, _ref_target = _ref.target, target = _ref_target === void 0 ? "_blank" : _ref_target;
    return /* @__PURE__ */ _jsx21(RadixLink, {
        href: href,
        target: target,
        download: download,
        children: children
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/UnorderedList.tsx
import { Box as Box4 } from "@radix-ui/themes";
import { jsx as _jsx22 } from "react/jsx-runtime";
var UnorderedList = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx22(Box4, {
        pb: "3",
        asChild: true,
        children: /* @__PURE__ */ _jsx22("ul", {
            style: {
                listStylePosition: "inside"
            },
            children: children
        })
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/OrderedList.tsx
import { Box as Box5 } from "@radix-ui/themes";
import { jsx as _jsx23 } from "react/jsx-runtime";
var OrderedList = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx23(Box5, {
        pb: "3",
        asChild: true,
        children: /* @__PURE__ */ _jsx23("ol", {
            style: {
                listStylePosition: "inside"
            },
            children: children
        })
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/ListItem.tsx
import { Box as Box6 } from "@radix-ui/themes";
import { jsx as _jsx24 } from "react/jsx-runtime";
var ListItem = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx24(Box6, {
        pb: "1",
        children: /* @__PURE__ */ _jsx24("li", {
            children: children
        })
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Strong.tsx
import { Strong as RadixStrong } from "@radix-ui/themes";
import { jsx as _jsx25 } from "react/jsx-runtime";
var Strong = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx25(RadixStrong, {
        children: children
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Pre.tsx
import { Box as Box7 } from "@radix-ui/themes";
import { jsx as _jsx26 } from "react/jsx-runtime";
var Pre = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx26(Box7, {
        style: {
            whiteSpace: "pre-wrap",
            wordBreak: "break-word"
        },
        children: children
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Code.tsx
import { c as _c14 } from "react-compiler-runtime";
import { Code as RadixCode } from "@radix-ui/themes";
// src/components/suggestions/Suggestions/index.tsx
import { c as _c13 } from "react-compiler-runtime";
import { useMemo as useMemo6 } from "react";
// src/hooks/messages/useLatestMessage/index.ts
import { c as _c11 } from "react-compiler-runtime";
import { useMemo as useMemo4 } from "react";
// src/hooks/messages/useMessages/index.tsx
import { c as _c10 } from "react-compiler-runtime";
import { useMemo as useMemo3 } from "react";
import { useInfiniteQuery, useQueryClient } from "@tanstack/react-query";
// src/lib/threads/queryOptions/index.ts
import { infiniteQueryOptions } from "@tanstack/react-query";
// src/lib/threads/queryOptions/variableParams.ts
function ownKeys2(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread2(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
            _defineProperty2(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty2(e, r, t) {
    return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey2(t) {
    var i = _toPrimitive2(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive2(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var variableParams = function(_ref) {
    var _superinterfaceContex;
    var variables = _ref.variables, superinterfaceContext = _ref.superinterfaceContext;
    if (variables.threadId) return variables;
    if (!variables.assistantId) return variables;
    if (!((_superinterfaceContex = superinterfaceContext.threadIdStorageOptions) !== null && _superinterfaceContex !== void 0 && _superinterfaceContex.get)) return variables;
    var threadId = superinterfaceContext.threadIdStorageOptions.get({
        assistantId: variables.assistantId
    });
    if (!threadId) return variables;
    return _objectSpread2(_objectSpread2({}, variables), {}, {
        threadId: threadId
    });
};
// src/lib/threads/queryOptions/index.ts
function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
function ownKeys3(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread3(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
            _defineProperty3(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty3(e, r, t) {
    return (r = _toPropertyKey3(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey3(t) {
    var i = _toPrimitive3(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive3(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var queryOptions = function(_ref) {
    var queryKeyBase = _ref.queryKeyBase, path2 = _ref.path, queryClient = _ref.queryClient, threadContext = _ref.threadContext, superinterfaceContext = _ref.superinterfaceContext;
    var queryKey = _to_consumable_array(queryKeyBase).concat([
        threadContext.variables
    ]);
    return infiniteQueryOptions(_objectSpread3(_objectSpread3(_objectSpread3({
        // @ts-ignore-next-line
        queryFn: function() {
            var _queryFn = _asyncToGenerator(function(_ref2) {
                var pageParam, queryKey2, _queryKey2, _key, variables, params;
                return _ts_generator(this, function(_state) {
                    pageParam = _ref2.pageParam, queryKey2 = _ref2.queryKey;
                    _queryKey2 = _sliced_to_array(queryKey2, 2), _key = _queryKey2[0], variables = _queryKey2[1];
                    params = new URLSearchParams(_objectSpread3(_objectSpread3({}, pageParam ? {
                        pageParam: pageParam
                    } : {}), variableParams({
                        variables: variables,
                        superinterfaceContext: superinterfaceContext
                    })));
                    return [
                        2,
                        fetch("".concat(superinterfaceContext.baseUrl).concat(path2, "?").concat(params)).then(/* @__PURE__ */ function() {
                            var _ref3 = _asyncToGenerator(function(response) {
                                var errorResponse, error;
                                return _ts_generator(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            if (!(response.status !== 200)) return [
                                                3,
                                                4
                                            ];
                                            _state.label = 1;
                                        case 1:
                                            _state.trys.push([
                                                1,
                                                3,
                                                ,
                                                4
                                            ]);
                                            return [
                                                4,
                                                response.json()
                                            ];
                                        case 2:
                                            errorResponse = _state.sent();
                                            throw new Error(errorResponse.error);
                                        case 3:
                                            error = _state.sent();
                                            throw new Error("Failed to fetch");
                                        case 4:
                                            return [
                                                2,
                                                response.json()
                                            ];
                                    }
                                });
                            });
                            return function(_x2) {
                                return _ref3.apply(this, arguments);
                            };
                        }())
                    ];
                });
            });
            function queryFn2(_x) {
                return _queryFn.apply(this, arguments);
            }
            return queryFn2;
        }(),
        initialPageParam: void 0,
        getNextPageParam: function(lastPage) {
            if (!lastPage.hasNextPage) return null;
            return lastPage.lastId;
        },
        limit: 10
    }, threadContext.defaultOptions.queries), queryClient.getQueryDefaults(queryKey)), {}, {
        queryKey: queryKey
    }));
};
// src/lib/messages/messagesQueryOptions.ts
var messagesQueryOptions = function(_ref) {
    var queryClient = _ref.queryClient, threadContext = _ref.threadContext, superinterfaceContext = _ref.superinterfaceContext;
    return queryOptions({
        queryKeyBase: [
            "messages"
        ],
        path: "/messages",
        queryClient: queryClient,
        threadContext: threadContext,
        superinterfaceContext: superinterfaceContext
    });
};
// src/hooks/messages/useMessages/index.tsx
function ownKeys4(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread4(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
            _defineProperty4(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty4(e, r, t) {
    return (r = _toPropertyKey4(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey4(t) {
    var i = _toPrimitive4(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive4(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var messages = function(_ref) {
    var props = _ref.props;
    if (!props.data) return [];
    return props.data.pages.reduce(function(acc, page) {
        return acc.concat(page.data);
    }, []);
};
var useMessages = function() {
    var $ = _c10(9);
    var queryClient = useQueryClient();
    var threadContext = useSuperinterfaceContext();
    var superinterfaceContext = useSuperinterfaceContext();
    var t0;
    if ($[0] !== queryClient || $[1] !== superinterfaceContext || $[2] !== threadContext) {
        t0 = messagesQueryOptions({
            queryClient: queryClient,
            threadContext: threadContext,
            superinterfaceContext: superinterfaceContext
        });
        $[0] = queryClient;
        $[1] = superinterfaceContext;
        $[2] = threadContext;
        $[3] = t0;
    } else {
        t0 = $[3];
    }
    var props = useInfiniteQuery(t0);
    var t1;
    var t2;
    if ($[4] !== props) {
        t2 = messages({
            props: props
        });
        $[4] = props;
        $[5] = t2;
    } else {
        t2 = $[5];
    }
    var t3;
    if ($[6] !== props || $[7] !== t2) {
        t3 = _objectSpread4(_objectSpread4({}, props), {}, {
            messages: t2
        });
        $[6] = props;
        $[7] = t2;
        $[8] = t3;
    } else {
        t3 = $[8];
    }
    t1 = t3;
    return t1;
};
// src/hooks/messages/useLatestMessage/index.ts
function ownKeys5(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread5(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
            _defineProperty5(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty5(e, r, t) {
    return (r = _toPropertyKey5(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey5(t) {
    var i = _toPrimitive5(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive5(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var useLatestMessage = function() {
    var $ = _c11(3);
    var props = useMessages();
    var t0;
    var t1 = props.messages[0] || null;
    var t2;
    if ($[0] !== props || $[1] !== t1) {
        t2 = _objectSpread5(_objectSpread5({}, props), {}, {
            latestMessage: t1
        });
        $[0] = props;
        $[1] = t1;
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    t0 = t2;
    return t0;
};
// src/components/suggestions/Suggestions/Content.tsx
import { useMemo as useMemo5 } from "react";
import { isEmpty } from "radash";
import { onlyText } from "react-children-utilities";
import { Flex as Flex7 } from "@radix-ui/themes";
// src/components/suggestions/Suggestions/Item.tsx
import { c as _c12 } from "react-compiler-runtime";
import { ArrowUpIcon } from "@radix-ui/react-icons";
import { Text as Text4, Button as Button2, Spinner } from "@radix-ui/themes";
// src/hooks/messages/useCreateMessage/index.ts
import { useCallback } from "react";
import { useMutation, useQueryClient as useQueryClient2 } from "@tanstack/react-query";
// src/hooks/messages/useCreateMessage/lib/mutationOptions/onMutate/index.ts
import { omit } from "radash";
// src/hooks/messages/useCreateMessage/lib/mutationOptions/onMutate/data.ts
import { isArray } from "radash";
import dayjs from "dayjs";
// src/lib/optimistic/optimisticId.ts
import { uid } from "radash";
var optimisticId = function() {
    return "-".concat(uid(24));
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/onMutate/data.ts
function ownKeys6(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread6(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
            _defineProperty6(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty6(e, r, t) {
    return (r = _toPropertyKey6(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey6(t) {
    var i = _toPrimitive6(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive6(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var content = function(_ref) {
    var newMessage = _ref.newMessage;
    if (isArray(newMessage.content)) {
        return newMessage.content;
    }
    return [
        {
            type: "text",
            text: {
                annotations: [],
                value: newMessage.content
            }
        }
    ];
};
var data = function(_ref2) {
    var newMessage = _ref2.newMessage;
    return function(prevData) {
        var _newMessage$attachmen;
        var message = {
            id: optimisticId(),
            role: "user",
            created_at: dayjs().unix(),
            object: "thread.message",
            content: content({
                newMessage: newMessage
            }),
            run_id: null,
            assistant_id: null,
            thread_id: null,
            attachments: (_newMessage$attachmen = newMessage.attachments) !== null && _newMessage$attachmen !== void 0 ? _newMessage$attachmen : [],
            metadata: {},
            runSteps: []
        };
        if (!prevData) {
            return {
                pageParams: [],
                pages: [
                    {
                        data: [
                            message
                        ],
                        hasNextPage: false,
                        lastId: message.id
                    }
                ]
            };
        }
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        return _objectSpread6(_objectSpread6({}, prevData), {}, {
            pages: [
                _objectSpread6(_objectSpread6({}, latestPage), {}, {
                    data: [
                        message
                    ].concat(_to_consumable_array(latestPage.data))
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    };
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/onMutate/index.ts
function asyncGeneratorStep2(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator2(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep2(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep2(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var onMutate = function(_ref) {
    var queryClient = _ref.queryClient;
    return /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator2(function(newMessage) {
            var queryKey, prevMessages;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        queryKey = [
                            "messages",
                            omit(newMessage, [
                                "content",
                                "attachments"
                            ])
                        ];
                        return [
                            4,
                            queryClient.cancelQueries({
                                queryKey: queryKey
                            })
                        ];
                    case 1:
                        _state.sent();
                        prevMessages = queryClient.getQueryData(queryKey);
                        queryClient.setQueryData(queryKey, data({
                            newMessage: newMessage
                        }));
                        return [
                            2,
                            {
                                prevMessages: prevMessages,
                                newMessage: newMessage
                            }
                        ];
                }
            });
        });
        return function(_x) {
            return _ref2.apply(this, arguments);
        };
    }();
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/index.ts
import { JSONParser } from "@streamparser/json-whatwg";
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadCreated.ts
var threadCreated = function(_ref) {
    var _superinterfaceContex, _value$data$metadata, _value$data$metadata2;
    var value = _ref.value, superinterfaceContext = _ref.superinterfaceContext;
    if (!((_superinterfaceContex = superinterfaceContext.threadIdStorageOptions) !== null && _superinterfaceContex !== void 0 && _superinterfaceContex.set)) return;
    if (!((_value$data$metadata = value.data.metadata) !== null && _value$data$metadata !== void 0 && _value$data$metadata.assistantId)) return;
    if (!((_value$data$metadata2 = value.data.metadata) !== null && _value$data$metadata2 !== void 0 && _value$data$metadata2.threadId)) return;
    superinterfaceContext.threadIdStorageOptions.set({
        // @ts-ignore-next-line
        assistantId: value.data.metadata.assistantId,
        // @ts-ignore-next-line
        threadId: value.data.metadata.threadId
    });
};
// src/lib/optimistic/isOptimistic.ts
import _3 from "lodash";
var isOptimistic = function(_ref) {
    var id = _ref.id;
    return _3.startsWith(id, "-");
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/extendMessage.ts
import { last } from "radash";
function ownKeys7(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread7(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys7(Object(t), true).forEach(function(r2) {
            _defineProperty7(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys7(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty7(e, r, t) {
    return (r = _toPropertyKey7(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey7(t) {
    var i = _toPrimitive7(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive7(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var extendMessage = function(_ref) {
    var _ref2, _last$runSteps, _last, _last2;
    var message = _ref.message, messages2 = _ref.messages;
    var prevRunMessages = messages2.filter(function(m) {
        return m.run_id === message.run_id;
    });
    var prevOptimitisticRunMessages = prevRunMessages.filter(function(m) {
        return isOptimistic({
            id: m.id
        });
    });
    var runSteps = (_ref2 = (_last$runSteps = (_last = last(prevOptimitisticRunMessages)) === null || _last === void 0 ? void 0 : _last.runSteps) !== null && _last$runSteps !== void 0 ? _last$runSteps : (_last2 = last(prevRunMessages)) === null || _last2 === void 0 ? void 0 : _last2.runSteps) !== null && _ref2 !== void 0 ? _ref2 : [];
    return _objectSpread7(_objectSpread7({}, message), {}, {
        runSteps: runSteps
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadMessageCreated.ts
function ownKeys8(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread8(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys8(Object(t), true).forEach(function(r2) {
            _defineProperty8(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys8(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty8(e, r, t) {
    return (r = _toPropertyKey8(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey8(t) {
    var i = _toPrimitive8(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive8(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var appendMessage = function(_ref) {
    var message = _ref.message, messages2 = _ref.messages;
    var prevMessages = messages2.filter(function(m) {
        return m.run_id != message.run_id || !isOptimistic({
            id: m.id
        });
    });
    return [
        extendMessage({
            message: message,
            messages: messages2
        })
    ].concat(_to_consumable_array(prevMessages));
};
var threadMessageCreated = function(_ref2) {
    var value = _ref2.value, messagesQueryKey = _ref2.messagesQueryKey, queryClient = _ref2.queryClient;
    return queryClient.setQueryData(messagesQueryKey, function(prevData) {
        if (!prevData) {
            return {
                pageParams: [],
                pages: [
                    {
                        data: appendMessage({
                            message: value.data,
                            messages: []
                        }),
                        hasNextPage: false,
                        lastId: value.data.id
                    }
                ]
            };
        }
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        return _objectSpread8(_objectSpread8({}, prevData), {}, {
            pages: [
                _objectSpread8(_objectSpread8({}, latestPage), {}, {
                    data: appendMessage({
                        message: value.data,
                        messages: latestPage.data
                    })
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadMessageDelta.ts
import _4 from "lodash";
import { omit as omit2 } from "radash";
function ownKeys9(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread9(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys9(Object(t), true).forEach(function(r2) {
            _defineProperty9(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys9(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty9(e, r, t) {
    return (r = _toPropertyKey9(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey9(t) {
    var i = _toPrimitive9(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive9(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var updatedContentPart = function(_ref) {
    var prevContentPart = _ref.prevContentPart, delta = _ref.delta;
    if (!prevContentPart) {
        return omit2(delta, [
            "index"
        ]);
    }
    if (delta.type === "text" && delta.text && prevContentPart.type == "text" && prevContentPart.text) {
        var _prevContentPart$text, _delta$text$annotatio;
        return _objectSpread9(_objectSpread9({}, prevContentPart), {}, {
            text: _objectSpread9(_objectSpread9({}, prevContentPart.text), {}, {
                value: "".concat(prevContentPart.text.value).concat(delta.text.value),
                annotations: _to_consumable_array((_prevContentPart$text = prevContentPart.text.annotations) !== null && _prevContentPart$text !== void 0 ? _prevContentPart$text : []).concat(_to_consumable_array((_delta$text$annotatio = delta.text.annotations) !== null && _delta$text$annotatio !== void 0 ? _delta$text$annotatio : []))
            })
        });
    }
    return prevContentPart;
};
var updatedContent = function(_ref2) {
    var content2 = _ref2.content, value = _ref2.value;
    if (!value.data.delta.content) return content2;
    var result = _4.cloneDeep(content2);
    value.data.delta.content.forEach(function(delta) {
        result[delta.index] = updatedContentPart({
            // @ts-ignore-next-line
            prevContentPart: result[delta.index],
            delta: delta
        });
    });
    return result;
};
var threadMessageDelta = function(_ref3) {
    var value = _ref3.value, queryClient = _ref3.queryClient, messagesQueryKey = _ref3.messagesQueryKey;
    return queryClient.setQueryData(messagesQueryKey, function(prevData) {
        if (!prevData) {
            return {
                pageParams: [],
                pages: [
                    {
                        data: [],
                        hasNextPage: false,
                        lastId: null
                    }
                ]
            };
        }
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        var _latestPage_data = _to_array(latestPage.data), latestMessage = _latestPage_data[0], messagesRest = _latestPage_data.slice(1);
        return _objectSpread9(_objectSpread9({}, prevData), {}, {
            pages: [
                _objectSpread9(_objectSpread9({}, latestPage), {}, {
                    data: [
                        _objectSpread9(_objectSpread9({}, latestMessage), {}, {
                            content: updatedContent({
                                content: latestMessage.content,
                                value: value
                            })
                        })
                    ].concat(_to_consumable_array(messagesRest))
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadMessageCompleted.ts
import { replace } from "radash";
function ownKeys10(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread10(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys10(Object(t), true).forEach(function(r2) {
            _defineProperty10(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys10(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty10(e, r, t) {
    return (r = _toPropertyKey10(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey10(t) {
    var i = _toPrimitive10(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive10(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var threadMessageCompleted = function(_ref) {
    var value = _ref.value, queryClient = _ref.queryClient, messagesQueryKey = _ref.messagesQueryKey;
    return queryClient.setQueryData(messagesQueryKey, function(prevData) {
        if (!prevData) {
            return {
                pageParams: [],
                pages: [
                    {
                        data: [],
                        hasNextPage: false,
                        lastId: null
                    }
                ]
            };
        }
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        return _objectSpread10(_objectSpread10({}, prevData), {}, {
            pages: [
                _objectSpread10(_objectSpread10({}, latestPage), {}, {
                    data: replace(latestPage.data, extendMessage({
                        message: value.data,
                        messages: latestPage.data
                    }), function(m) {
                        return m.id === value.data.id;
                    })
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadRunCreated.ts
function ownKeys11(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread11(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys11(Object(t), true).forEach(function(r2) {
            _defineProperty11(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys11(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty11(e, r, t) {
    return (r = _toPropertyKey11(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey11(t) {
    var i = _toPrimitive11(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive11(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var threadRunCreated = function(_ref) {
    var value = _ref.value, queryClient = _ref.queryClient, messagesQueryKey = _ref.messagesQueryKey;
    return queryClient.setQueryData(messagesQueryKey, function(prevData) {
        if (!prevData) return prevData;
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        return _objectSpread11(_objectSpread11({}, prevData), {}, {
            pages: [
                _objectSpread11(_objectSpread11({}, latestPage), {}, {
                    data: [
                        {
                            id: optimisticId(),
                            assistant_id: value.data.assistant_id,
                            content: [],
                            created_at: value.data.created_at,
                            attachments: [],
                            metadata: {},
                            status: "in_progress",
                            role: "assistant",
                            runSteps: [],
                            run_id: value.data.id,
                            thread_id: value.data.thread_id
                        }
                    ].concat(_to_consumable_array(latestPage.data))
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadRunFailed.ts
var threadRunFailed = function(_ref) {
    var value = _ref.value, queryClient = _ref.queryClient, messagesQueryKey = _ref.messagesQueryKey;
    throw new Error("Failed to send your message, try again. If you are the owner, check the logs.");
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadRunStepCreated.ts
function ownKeys12(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread12(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys12(Object(t), true).forEach(function(r2) {
            _defineProperty12(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys12(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty12(e, r, t) {
    return (r = _toPropertyKey12(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey12(t) {
    var i = _toPrimitive12(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive12(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var threadRunStepCreated = function(_ref) {
    var value = _ref.value, queryClient = _ref.queryClient, messagesQueryKey = _ref.messagesQueryKey;
    return queryClient.setQueryData(messagesQueryKey, function(prevData) {
        if (!prevData) return prevData;
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        return _objectSpread12(_objectSpread12({}, prevData), {}, {
            pages: [
                _objectSpread12(_objectSpread12({}, latestPage), {}, {
                    data: latestPage.data.map(function(m) {
                        if (m.run_id === value.data.run_id) {
                            return _objectSpread12(_objectSpread12({}, m), {}, {
                                runSteps: [
                                    value.data
                                ].concat(_to_consumable_array(m.runSteps))
                            });
                        }
                        return m;
                    })
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadRunStepDelta.ts
import _5 from "lodash";
import { omit as omit3 } from "radash";
function ownKeys13(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread13(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys13(Object(t), true).forEach(function(r2) {
            _defineProperty13(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys13(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty13(e, r, t) {
    return (r = _toPropertyKey13(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey13(t) {
    var i = _toPrimitive13(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive13(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var updatedToolCall = function(_ref) {
    var toolCall = _ref.toolCall, delta = _ref.delta;
    if (!toolCall) {
        return omit3(delta, [
            "index"
        ]);
    }
    if (delta.type === "function" && delta.function && toolCall.type === "function" && toolCall.function) {
        var result = _5.cloneDeep(toolCall);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(delta.function)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array(_step.value, 2), key2 = _step_value[0], value = _step_value[1];
                var _result$function$key;
                result.function[key2] = "".concat((_result$function$key = result.function[key2]) !== null && _result$function$key !== void 0 ? _result$function$key : "").concat(value);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return result;
    }
    return toolCall;
};
var updatedRunStep = function(_ref2) {
    var _runStep$step_details, _value$data$delta;
    var runStep = _ref2.runStep, value = _ref2.value;
    if (!(runStep !== null && runStep !== void 0 && (_runStep$step_details = runStep.step_details) !== null && _runStep$step_details !== void 0 && _runStep$step_details.tool_calls)) return runStep;
    if (((_value$data$delta = value.data.delta) === null || _value$data$delta === void 0 || (_value$data$delta = _value$data$delta.step_details) === null || _value$data$delta === void 0 ? void 0 : _value$data$delta.type) === "tool_calls") {
        if (!value.data.delta.step_details.tool_calls) return runStep;
        var newToolCalls = _5.cloneDeep(runStep.step_details.tool_calls);
        value.data.delta.step_details.tool_calls.forEach(function(delta) {
            return newToolCalls[delta.index] = updatedToolCall({
                toolCall: newToolCalls[delta.index],
                delta: delta
            });
        });
        return _objectSpread13(_objectSpread13({}, runStep), {}, {
            step_details: _objectSpread13(_objectSpread13(_objectSpread13({}, runStep.step_details), value.data.delta.step_details), {}, {
                tool_calls: newToolCalls
            })
        });
    } else {
        return runStep;
    }
};
var threadRunStepDelta = function(_ref3) {
    var value = _ref3.value, queryClient = _ref3.queryClient, messagesQueryKey = _ref3.messagesQueryKey;
    return queryClient.setQueryData(messagesQueryKey, function(prevData) {
        if (!prevData) return prevData;
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        return _objectSpread13(_objectSpread13({}, prevData), {}, {
            pages: [
                _objectSpread13(_objectSpread13({}, latestPage), {}, {
                    data: latestPage.data.map(function(m) {
                        if (m.run_id === value.data.run_id) {
                            return _objectSpread13(_objectSpread13({}, m), {}, {
                                runSteps: m.runSteps.map(function(rs) {
                                    if (rs.id === value.data.id) {
                                        return updatedRunStep({
                                            runStep: rs,
                                            value: value
                                        });
                                    }
                                    return rs;
                                })
                            });
                        }
                        return m;
                    })
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadRunStepCompleted.ts
import { replace as replace2 } from "radash";
function ownKeys14(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread14(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys14(Object(t), true).forEach(function(r2) {
            _defineProperty14(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys14(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty14(e, r, t) {
    return (r = _toPropertyKey14(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey14(t) {
    var i = _toPrimitive14(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive14(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var threadRunStepCompleted = function(_ref) {
    var value = _ref.value, queryClient = _ref.queryClient, messagesQueryKey = _ref.messagesQueryKey;
    return queryClient.setQueryData(messagesQueryKey, function(prevData) {
        if (!prevData) return prevData;
        var _prevData_pages = _to_array(prevData.pages), latestPage = _prevData_pages[0], pagesRest = _prevData_pages.slice(1);
        return _objectSpread14(_objectSpread14({}, prevData), {}, {
            pages: [
                _objectSpread14(_objectSpread14({}, latestPage), {}, {
                    data: latestPage.data.map(function(m) {
                        if (m.run_id === value.data.run_id) {
                            return _objectSpread14(_objectSpread14({}, m), {}, {
                                runSteps: replace2(m.runSteps, value.data, function(rs) {
                                    return rs.id === value.data.id;
                                })
                            });
                        }
                        return m;
                    })
                })
            ].concat(_to_consumable_array(pagesRest))
        });
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/threadRunRequiresAction.ts
import { map } from "radash";
function ownKeys15(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread15(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys15(Object(t), true).forEach(function(r2) {
            _defineProperty15(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys15(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty15(e, r, t) {
    return (r = _toPropertyKey15(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey15(t) {
    var i = _toPrimitive15(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive15(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function asyncGeneratorStep3(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator3(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep3(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep3(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var threadRunRequiresAction = /* @__PURE__ */ function() {
    var _ref2 = _asyncToGenerator3(function(_ref) {
        var value, superinterfaceContext, toolCalls, toolOutputs;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    value = _ref.value, superinterfaceContext = _ref.superinterfaceContext;
                    if (!(value.data.required_action.type === "submit_client_tool_outputs")) return [
                        3,
                        2
                    ];
                    toolCalls = value.data.required_action.submit_client_tool_outputs.tool_calls;
                    return [
                        4,
                        map(toolCalls, /* @__PURE__ */ function() {
                            var _ref3 = _asyncToGenerator3(function(toolCall) {
                                var fn, args, parsedArgs, output, _yield$fn, error, serializedOutput;
                                return _ts_generator(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            if (toolCall.type !== "function") {
                                                return [
                                                    2,
                                                    {
                                                        toolCallId: toolCall.id,
                                                        output: "Error: client tool type ".concat(toolCall.type, " is not supported.")
                                                    }
                                                ];
                                            }
                                            fn = window[toolCall.function.name];
                                            if (!fn) {
                                                return [
                                                    2,
                                                    {
                                                        toolCallId: toolCall.id,
                                                        output: "Error: client function ".concat(toolCall.function.name, " is not defined.")
                                                    }
                                                ];
                                            }
                                            args = toolCall.function.arguments;
                                            parsedArgs = JSON.parse(args);
                                            _state.label = 1;
                                        case 1:
                                            _state.trys.push([
                                                1,
                                                3,
                                                ,
                                                4
                                            ]);
                                            return [
                                                4,
                                                fn(parsedArgs)
                                            ];
                                        case 2:
                                            output = (_yield$fn = _state.sent()) !== null && _yield$fn !== void 0 ? _yield$fn : "";
                                            return [
                                                3,
                                                4
                                            ];
                                        case 3:
                                            error = _state.sent();
                                            output = "Error: ".concat(error.message);
                                            return [
                                                3,
                                                4
                                            ];
                                        case 4:
                                            try {
                                                if (typeof output === "string") {
                                                    serializedOutput = output;
                                                } else {
                                                    serializedOutput = JSON.stringify(output);
                                                }
                                            } catch (error) {
                                                serializedOutput = "Error: ".concat(error.message);
                                            }
                                            return [
                                                2,
                                                {
                                                    toolCallId: toolCall.id,
                                                    output: serializedOutput
                                                }
                                            ];
                                    }
                                });
                            });
                            return function(_x2) {
                                return _ref3.apply(this, arguments);
                            };
                        }())
                    ];
                case 1:
                    toolOutputs = _state.sent();
                    return [
                        2,
                        fetch("".concat(superinterfaceContext.baseUrl, "/threads/runs/submit-client-tool-outputs"), {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify(_objectSpread15({
                                toolOutputs: toolOutputs
                            }, superinterfaceContext.variables))
                        })
                    ];
                case 2:
                    return [
                        2
                    ];
            }
        });
    });
    return function threadRunRequiresAction2(_x) {
        return _ref2.apply(this, arguments);
    };
}();
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/handlers/index.ts
var handlers = {
    "thread.created": threadCreated,
    "thread.message.created": threadMessageCreated,
    "thread.message.delta": threadMessageDelta,
    "thread.message.completed": threadMessageCompleted,
    "thread.run.created": threadRunCreated,
    "thread.run.failed": threadRunFailed,
    "thread.run.step.created": threadRunStepCreated,
    "thread.run.step.delta": threadRunStepDelta,
    "thread.run.step.completed": threadRunStepCompleted,
    "thread.run.requires_action": threadRunRequiresAction
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/handleResponse/index.ts
var handleResponse = function(_ref) {
    var value = _ref.value, messagesQueryKey = _ref.messagesQueryKey, queryClient = _ref.queryClient, superinterfaceContext = _ref.superinterfaceContext;
    var handler = handlers[value.value.event];
    if (!handler) {
        return console.log("Missing handler", {
            value: value
        });
    }
    return handler({
        value: value.value,
        queryClient: queryClient,
        messagesQueryKey: messagesQueryKey,
        superinterfaceContext: superinterfaceContext
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/body.ts
function ownKeys16(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread16(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys16(Object(t), true).forEach(function(r2) {
            _defineProperty16(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys16(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty16(e, r, t) {
    return (r = _toPropertyKey16(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey16(t) {
    var i = _toPrimitive16(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive16(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var body = function(_ref) {
    var _superinterfaceContex;
    var variables = _ref.variables, superinterfaceContext = _ref.superinterfaceContext;
    if (variables.threadId) return variables;
    if (!variables.assistantId) return variables;
    if (!((_superinterfaceContex = superinterfaceContext.threadIdStorageOptions) !== null && _superinterfaceContex !== void 0 && _superinterfaceContex.get)) return variables;
    var threadId = superinterfaceContext.threadIdStorageOptions.get({
        assistantId: variables.assistantId
    });
    if (!threadId) return variables;
    return _objectSpread16(_objectSpread16({}, variables), {}, {
        threadId: threadId
    });
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/mutationFn/index.ts
function asyncGeneratorStep4(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator4(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep4(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep4(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var mutationFn = function(_ref) {
    var superinterfaceContext = _ref.superinterfaceContext, queryClient = _ref.queryClient, threadContext = _ref.threadContext;
    return /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator4(function(variables) {
            var abortController, response, errorResponse, error, parser, reader, messagesQueryKey, _$_ref, done, value;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        abortController = new AbortController();
                        superinterfaceContext.createMessageAbortControllerRef.current = abortController;
                        return [
                            4,
                            fetch("".concat(superinterfaceContext.baseUrl, "/messages"), {
                                method: "POST",
                                body: JSON.stringify(body({
                                    variables: variables,
                                    superinterfaceContext: superinterfaceContext
                                })),
                                signal: abortController.signal
                            })
                        ];
                    case 1:
                        response = _state.sent();
                        if (!(response.status !== 200)) return [
                            3,
                            5
                        ];
                        _state.label = 2;
                    case 2:
                        _state.trys.push([
                            2,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4,
                            response.json()
                        ];
                    case 3:
                        errorResponse = _state.sent();
                        throw new Error(errorResponse.error);
                    case 4:
                        error = _state.sent();
                        throw new Error("Failed to send your message, try again. If you are the owner, check the logs.");
                    case 5:
                        if (response.body == null) {
                            throw new Error("The response body is empty.");
                        }
                        parser = new JSONParser({
                            stringBufferSize: void 0,
                            paths: [
                                "$"
                            ],
                            separator: ""
                        });
                        reader = response.body.pipeThrough(parser).getReader();
                        messagesQueryKey = [
                            "messages",
                            threadContext.variables
                        ];
                        _state.label = 6;
                    case 6:
                        if (!true) return [
                            3,
                            8
                        ];
                        return [
                            4,
                            reader.read()
                        ];
                    case 7:
                        _$_ref = _state.sent(), done = _$_ref.done, value = _$_ref.value;
                        if (done) return [
                            3,
                            8
                        ];
                        handleResponse({
                            value: value,
                            messagesQueryKey: messagesQueryKey,
                            queryClient: queryClient,
                            superinterfaceContext: superinterfaceContext
                        });
                        return [
                            3,
                            6
                        ];
                    case 8:
                        return [
                            2
                        ];
                }
            });
        });
        return function(_x) {
            return _ref2.apply(this, arguments);
        };
    }();
};
// src/hooks/messages/useCreateMessage/lib/mutationOptions/index.ts
function ownKeys17(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread17(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys17(Object(t), true).forEach(function(r2) {
            _defineProperty17(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys17(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty17(e, r, t) {
    return (r = _toPropertyKey17(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey17(t) {
    var i = _toPrimitive17(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive17(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var mutationOptions = function(_ref) {
    var queryClient = _ref.queryClient, threadContext = _ref.threadContext, superinterfaceContext = _ref.superinterfaceContext, onError = _ref.onError;
    var mutationKey = [
        "createMessage",
        threadContext.variables
    ];
    return _objectSpread17(_objectSpread17(_objectSpread17({
        mutationFn: mutationFn({
            queryClient: queryClient,
            superinterfaceContext: superinterfaceContext,
            threadContext: threadContext
        }),
        onMutate: onMutate({
            queryClient: queryClient
        }),
        onError: onError
    }, threadContext.defaultOptions.mutations), queryClient.getMutationDefaults(mutationKey)), {}, {
        mutationKey: mutationKey
    });
};
// src/hooks/messages/useCreateMessage/index.ts
function ownKeys18(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread18(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys18(Object(t), true).forEach(function(r2) {
            _defineProperty18(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys18(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty18(e, r, t) {
    return (r = _toPropertyKey18(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey18(t) {
    var i = _toPrimitive18(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive18(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var useCreateMessage = function useCreateMessage2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        onError: function() {}
    }, _ref_onError = _ref.onError, onError = _ref_onError === void 0 ? function() {} : _ref_onError;
    var queryClient = useQueryClient2();
    var superinterfaceContext = useSuperinterfaceContext();
    var threadContext = useSuperinterfaceContext();
    var props = useMutation(mutationOptions({
        queryClient: queryClient,
        threadContext: threadContext,
        superinterfaceContext: superinterfaceContext,
        onError: onError
    }));
    var createMessage = useCallback(function(variables) {
        return props.mutateAsync(_objectSpread18(_objectSpread18({}, threadContext.variables), variables));
    }, [
        props.mutateAsync,
        threadContext.variables
    ]);
    return _objectSpread18(_objectSpread18({}, props), {}, {
        createMessage: createMessage
    });
};
// src/components/suggestions/Suggestions/Item.tsx
import { useQueryClient as useQueryClient3 } from "@tanstack/react-query";
// src/hooks/toasts/useToasts/index.ts
import { useContext as useContext4 } from "react";
// src/contexts/toasts/ToastsContext/index.ts
import { createContext as createContext5 } from "react";
var ToastsContext = /* @__PURE__ */ createContext5({
    toasts: [],
    addToast: function() {}
});
// src/hooks/toasts/useToasts/index.ts
var useToasts = function() {
    return useContext4(ToastsContext);
};
// src/lib/errors/createMessageDefaultOnError.ts
var createMessageDefaultOnError = function(_ref) {
    var queryClient = _ref.queryClient, addToast = _ref.addToast, threadContext = _ref.threadContext;
    return function(error) {
        if (error.name === "AbortError") {
            queryClient.invalidateQueries({
                queryKey: [
                    "messages",
                    threadContext.variables
                ]
            });
            queryClient.invalidateQueries({
                queryKey: [
                    "runs",
                    threadContext.variables
                ]
            });
            return;
        }
        addToast({
            type: "error",
            message: error.message
        });
    };
};
// src/components/suggestions/Suggestions/Item.tsx
import { jsx as _jsx27, jsxs as _jsxs10 } from "react/jsx-runtime";
function ownKeys19(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread19(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys19(Object(t), true).forEach(function(r2) {
            _defineProperty19(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys19(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty19(e, r, t) {
    return (r = _toPropertyKey19(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey19(t) {
    var i = _toPrimitive19(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive19(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Item = function(t0) {
    var $ = _c12(16);
    var suggestion = t0.suggestion, isDisabled = t0.isDisabled, className = t0.className, style = t0.style;
    var addToast = useToasts().addToast;
    var queryClient = useQueryClient3();
    var threadContext = useSuperinterfaceContext();
    var t1;
    if ($[0] !== addToast || $[1] !== queryClient || $[2] !== threadContext) {
        t1 = createMessageDefaultOnError({
            queryClient: queryClient,
            addToast: addToast,
            threadContext: threadContext
        });
        $[0] = addToast;
        $[1] = queryClient;
        $[2] = threadContext;
        $[3] = t1;
    } else {
        t1 = $[3];
    }
    var t2;
    if ($[4] !== t1) {
        t2 = {
            onError: t1
        };
        $[4] = t1;
        $[5] = t2;
    } else {
        t2 = $[5];
    }
    var _useCreateMessage = useCreateMessage(t2), createMessage = _useCreateMessage.createMessage, isPending = _useCreateMessage.isPending;
    var t3;
    if ($[6] !== createMessage || $[7] !== suggestion) {
        t3 = function() {
            createMessage({
                content: suggestion
            });
        };
        $[6] = createMessage;
        $[7] = suggestion;
        $[8] = t3;
    } else {
        t3 = $[8];
    }
    var t4;
    if ($[9] !== className || $[10] !== isDisabled || $[11] !== isPending || $[12] !== style || $[13] !== suggestion || $[14] !== t3) {
        t4 = /* @__PURE__ */ _jsx27(Content3, {
            onClick: t3,
            isDisabled: isDisabled,
            isPending: isPending,
            className: className,
            style: style,
            children: suggestion
        });
        $[9] = className;
        $[10] = isDisabled;
        $[11] = isPending;
        $[12] = style;
        $[13] = suggestion;
        $[14] = t3;
        $[15] = t4;
    } else {
        t4 = $[15];
    }
    return t4;
};
var Content3 = function(_ref) {
    var onClick = _ref.onClick, isDisabled = _ref.isDisabled, isPending = _ref.isPending, children = _ref.children, className = _ref.className, style = _ref.style;
    return /* @__PURE__ */ _jsxs10(Button2, {
        className: className,
        variant: "soft",
        onClick: onClick,
        disabled: isDisabled,
        style: _objectSpread19({
            minHeight: "var(--base-button-height)",
            height: "inherit",
            flexShrink: 1
        }, style !== null && style !== void 0 ? style : {}),
        children: [
            /* @__PURE__ */ _jsx27(Text4, {
                size: "1",
                weight: "regular",
                children: children
            }),
            /* @__PURE__ */ _jsx27(Spinner, {
                loading: isPending,
                children: /* @__PURE__ */ _jsx27(ArrowUpIcon, {
                    style: {
                        flexShrink: 0
                    }
                })
            })
        ]
    });
};
Item.Content = Content3;
// src/components/suggestions/Suggestions/Content.tsx
import { jsx as _jsx28 } from "react/jsx-runtime";
var Content4 = function(_ref) {
    var children = _ref.children, className = _ref.className, style = _ref.style;
    var isMutatingMessage = useIsMutatingMessage();
    var suggestions = useMemo5(function() {
        return onlyText(children).split(/\r?\n/).filter(function(c) {
            return !isEmpty(c);
        }).map(function(c_0) {
            return c_0.trim();
        });
    }, [
        children
    ]);
    if (isEmpty(suggestions)) return null;
    return /* @__PURE__ */ _jsx28(Flex7, {
        gap: "2",
        py: "2",
        wrap: "wrap",
        className: className,
        style: style,
        children: suggestions.map(function(suggestion) {
            return /* @__PURE__ */ _jsx28(Item, {
                suggestion: suggestion,
                isDisabled: isMutatingMessage
            }, suggestion);
        })
    });
};
// src/components/suggestions/Suggestions/index.tsx
import { jsx as _jsx29 } from "react/jsx-runtime";
var Suggestions = function(t0) {
    var _latestMessageProps$l;
    var $ = _c13(4);
    var children = t0.children, className = t0.className, style = t0.style;
    var latestMessageProps = useLatestMessage();
    var t1;
    t1 = (_latestMessageProps$l = latestMessageProps.latestMessage) === null || _latestMessageProps$l === void 0 || (_latestMessageProps$l = _latestMessageProps$l.metadata) === null || _latestMessageProps$l === void 0 ? void 0 : _latestMessageProps$l.isBlocking;
    var isDisabled = t1;
    if (latestMessageProps.isLoading) {
        return null;
    }
    if (isDisabled) {
        return null;
    }
    var t2;
    if ($[0] !== children || $[1] !== className || $[2] !== style) {
        t2 = /* @__PURE__ */ _jsx29(Content4, {
            className: className,
            style: style,
            children: children
        });
        $[0] = children;
        $[1] = className;
        $[2] = style;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    return t2;
};
Suggestions.Item = Item;
// src/contexts/markdown/MarkdownContext/lib/components/Code.tsx
import { jsx as _jsx30 } from "react/jsx-runtime";
var Code3 = function(t0) {
    var $ = _c14(5);
    var children = t0.children, className = t0.className;
    if (className === "language-suggestions") {
        var _t;
        if ($[0] !== children) {
            _t = /* @__PURE__ */ _jsx30(Suggestions, {
                children: children
            });
            $[0] = children;
            $[1] = _t;
        } else {
            _t = $[1];
        }
        return _t;
    }
    var t1;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = {
            wordBreak: "break-word"
        };
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    var t2;
    if ($[3] !== children) {
        t2 = /* @__PURE__ */ _jsx30(RadixCode, {
            style: t1,
            children: children
        });
        $[3] = children;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    return t2;
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/index.tsx
import { c as _c19 } from "react-compiler-runtime";
// src/components/images/Image.tsx
import { Box as Box8 } from "@radix-ui/themes";
import { jsx as _jsx31 } from "react/jsx-runtime";
function ownKeys20(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread20(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys20(Object(t), true).forEach(function(r2) {
            _defineProperty20(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys20(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty20(e, r, t) {
    return (r = _toPropertyKey20(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey20(t) {
    var i = _toPrimitive20(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive20(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Image = function(props) {
    return /* @__PURE__ */ _jsx31(Box8, {
        pb: "3",
        children: /* @__PURE__ */ _jsx31("img", _objectSpread20(_objectSpread20({}, props), {}, {
            style: {
                maxWidth: "100%",
                height: "auto"
            }
        }))
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/lib/isVideoSrc.ts
var videoExtensions = [
    "3g2",
    "3gp",
    "aaf",
    "asf",
    "avchd",
    "avi",
    "drc",
    "flv",
    "m2v",
    "m3u8",
    "m4p",
    "m4v",
    "mkv",
    "mng",
    "mov",
    "mp2",
    "mp4",
    "mpe",
    "mpeg",
    "mpg",
    "mpv",
    "mxf",
    "nsv",
    "ogg",
    "ogv",
    "qt",
    "rm",
    "rmvb",
    "roq",
    "svi",
    "vob",
    "webm",
    "wmv",
    "yuv"
];
var isVideoSrc = function(_ref) {
    var src = _ref.src;
    return videoExtensions.includes(src.split(".").pop() || "");
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/lib/isAudioSrc.ts
var isAudioSrc = function(_ref) {
    var src = _ref.src;
    return src.endsWith(".mp3") || src.endsWith(".wav");
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/Video/index.tsx
import { Flex as Flex8 } from "@radix-ui/themes";
import "@vidstack/react/player/styles/base.css";
import { MediaPlayer, MediaProvider, Controls } from "@vidstack/react";
// src/components/media/PlayButton.tsx
import { c as _c15 } from "react-compiler-runtime";
import { PlayButton as VidstackPlayButton, useMediaState } from "@vidstack/react";
import { IconButton } from "@radix-ui/themes";
import { PlayIcon, PauseIcon } from "@radix-ui/react-icons";
import { jsx as _jsx32 } from "react/jsx-runtime";
var PlayButton = function() {
    var $ = _c15(2);
    var isPaused = useMediaState("paused");
    var t0;
    if ($[0] !== isPaused) {
        t0 = /* @__PURE__ */ _jsx32(IconButton, {
            variant: "ghost",
            asChild: true,
            children: /* @__PURE__ */ _jsx32(VidstackPlayButton, {
                children: isPaused ? /* @__PURE__ */ _jsx32(PlayIcon, {}) : /* @__PURE__ */ _jsx32(PauseIcon, {})
            })
        });
        $[0] = isPaused;
        $[1] = t0;
    } else {
        t0 = $[1];
    }
    return t0;
};
// src/components/media/VolumeButton.tsx
import { c as _c16 } from "react-compiler-runtime";
import { MuteButton, useMediaState as useMediaState2, useMediaRemote } from "@vidstack/react";
import { IconButton as IconButton2, HoverCard, Slider } from "@radix-ui/themes";
import { SpeakerModerateIcon, SpeakerOffIcon } from "@radix-ui/react-icons";
import { jsx as _jsx33, jsxs as _jsxs11 } from "react/jsx-runtime";
var VolumeButton = function() {
    var $ = _c16(13);
    var volume = useMediaState2("volume");
    var isMuted = useMediaState2("muted");
    var remote = useMediaRemote();
    var t0;
    if ($[0] !== isMuted || $[1] !== volume) {
        t0 = /* @__PURE__ */ _jsx33(HoverCard.Trigger, {
            children: /* @__PURE__ */ _jsx33(IconButton2, {
                variant: "ghost",
                asChild: true,
                children: /* @__PURE__ */ _jsx33(MuteButton, {
                    children: isMuted || volume === 0 ? /* @__PURE__ */ _jsx33(SpeakerOffIcon, {}) : /* @__PURE__ */ _jsx33(SpeakerModerateIcon, {})
                })
            })
        });
        $[0] = isMuted;
        $[1] = volume;
        $[2] = t0;
    } else {
        t0 = $[2];
    }
    var t1 = volume * 100;
    var t2;
    if ($[3] !== t1) {
        t2 = [
            t1
        ];
        $[3] = t1;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    var t3;
    if ($[5] !== remote) {
        t3 = function(t42) {
            var _t42 = _sliced_to_array(t42, 1), value = _t42[0];
            return remote.changeVolume(value / 100);
        };
        $[5] = remote;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    var t4;
    if ($[7] !== t2 || $[8] !== t3) {
        t4 = /* @__PURE__ */ _jsx33(HoverCard.Content, {
            size: "1",
            side: "top",
            height: "100px",
            children: /* @__PURE__ */ _jsx33(Slider, {
                size: "1",
                variant: "soft",
                orientation: "vertical",
                value: t2,
                onValueChange: t3
            })
        });
        $[7] = t2;
        $[8] = t3;
        $[9] = t4;
    } else {
        t4 = $[9];
    }
    var t5;
    if ($[10] !== t0 || $[11] !== t4) {
        t5 = /* @__PURE__ */ _jsxs11(HoverCard.Root, {
            children: [
                t0,
                t4
            ]
        });
        $[10] = t0;
        $[11] = t4;
        $[12] = t5;
    } else {
        t5 = $[12];
    }
    return t5;
};
// src/components/media/Time.tsx
import { c as _c17 } from "react-compiler-runtime";
import { useState, useEffect, useMemo as useMemo7 } from "react";
import { useMediaState as useMediaState3, useMediaRemote as useMediaRemote2 } from "@vidstack/react";
import { Slider as Slider2 } from "@radix-ui/themes";
import { jsx as _jsx34 } from "react/jsx-runtime";
var Time = function() {
    var $ = _c17(17);
    var time = useMediaState3("currentTime");
    var duration = useMediaState3("duration");
    var seeking = useMediaState3("seeking");
    var canSeek = useMediaState3("canSeek");
    var remote = useMediaRemote2();
    var _useState = _sliced_to_array(useState(0), 2), value = _useState[0], setValue = _useState[1];
    var t0;
    var t1;
    if ($[0] !== duration || $[1] !== seeking || $[2] !== time) {
        t0 = function() {
            if (seeking) {
                return;
            }
            setValue(time / duration * 100);
        };
        t1 = [
            time,
            duration,
            seeking
        ];
        $[0] = duration;
        $[1] = seeking;
        $[2] = time;
        $[3] = t0;
        $[4] = t1;
    } else {
        t0 = $[3];
        t1 = $[4];
    }
    useEffect(t0, t1);
    var t2;
    t2 = 1 / duration * 100;
    var step = t2;
    var t3;
    if ($[5] !== value) {
        t3 = [
            value
        ];
        $[5] = value;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    var t4 = !canSeek;
    var t5 = Number.isFinite(step) ? step : 1;
    var t6;
    var t7;
    if ($[7] !== duration || $[8] !== remote) {
        t6 = function(t82) {
            var _t82 = _sliced_to_array(t82, 1), value_0 = _t82[0];
            setValue(value_0);
            remote.seeking(value_0 / 100 * duration);
        };
        t7 = function(t9) {
            var _t9 = _sliced_to_array(t9, 1), value_1 = _t9[0];
            remote.seek(value_1 / 100 * duration);
        };
        $[7] = duration;
        $[8] = remote;
        $[9] = t6;
        $[10] = t7;
    } else {
        t6 = $[9];
        t7 = $[10];
    }
    var t8;
    if ($[11] !== t3 || $[12] !== t4 || $[13] !== t5 || $[14] !== t6 || $[15] !== t7) {
        t8 = /* @__PURE__ */ _jsx34(Slider2, {
            size: "1",
            variant: "soft",
            value: t3,
            disabled: t4,
            step: t5,
            onValueChange: t6,
            onValueCommit: t7
        });
        $[11] = t3;
        $[12] = t4;
        $[13] = t5;
        $[14] = t6;
        $[15] = t7;
        $[16] = t8;
    } else {
        t8 = $[16];
    }
    return t8;
};
// src/components/media/MediaContainer.tsx
import { Card, Inset } from "@radix-ui/themes";
import { jsx as _jsx35 } from "react/jsx-runtime";
var MediaContainer = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx35(Card, {
        mb: "3",
        children: /* @__PURE__ */ _jsx35(Inset, {
            clip: "padding-box",
            style: {
                display: "flex",
                flexDirection: "column"
            },
            children: children
        })
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/Video/FullscreenButton.tsx
import { c as _c18 } from "react-compiler-runtime";
import { FullscreenButton as VidstackFullscreenButton, useMediaState as useMediaState4 } from "@vidstack/react";
import { IconButton as IconButton3 } from "@radix-ui/themes";
import { EnterFullScreenIcon, ExitFullScreenIcon } from "@radix-ui/react-icons";
import { jsx as _jsx36 } from "react/jsx-runtime";
var FullscreenButton = function() {
    var $ = _c18(2);
    var isFullscreen = useMediaState4("fullscreen");
    var t0;
    if ($[0] !== isFullscreen) {
        t0 = /* @__PURE__ */ _jsx36(IconButton3, {
            variant: "ghost",
            asChild: true,
            children: /* @__PURE__ */ _jsx36(VidstackFullscreenButton, {
                children: isFullscreen ? /* @__PURE__ */ _jsx36(ExitFullScreenIcon, {}) : /* @__PURE__ */ _jsx36(EnterFullScreenIcon, {})
            })
        });
        $[0] = isFullscreen;
        $[1] = t0;
    } else {
        t0 = $[1];
    }
    return t0;
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/Video/index.tsx
import { jsx as _jsx37, jsxs as _jsxs12 } from "react/jsx-runtime";
var Video = function(_ref) {
    var src = _ref.src;
    return /* @__PURE__ */ _jsx37(MediaContainer, {
        children: /* @__PURE__ */ _jsxs12(MediaPlayer, {
            src: {
                src: src,
                type: "video/".concat(src.split(".").pop())
            },
            playsInline: true,
            hideControlsOnMouseLeave: true,
            crossOrigin: true,
            children: [
                /* @__PURE__ */ _jsx37(MediaProvider, {}),
                /* @__PURE__ */ _jsx37("style", {
                    children: "\n          .superinterface-video-controls {\n            opacity: 0;\n            transition: opacity 0.2s ease-out;\n          }\n\n          .superinterface-video-controls[data-visible] {\n            opacity: 1;\n          }\n        "
                }),
                /* @__PURE__ */ _jsx37(Flex8, {
                    asChild: true,
                    position: "absolute",
                    bottom: "0",
                    left: "0",
                    right: "0",
                    className: "superinterface-video-controls",
                    p: "3",
                    style: {
                        zIndex: 10,
                        background: "var(--accent-4)"
                    },
                    children: /* @__PURE__ */ _jsx37(Controls.Root, {
                        children: /* @__PURE__ */ _jsx37(Flex8, {
                            asChild: true,
                            align: "center",
                            gap: "3",
                            flexGrow: "1",
                            children: /* @__PURE__ */ _jsxs12(Controls.Group, {
                                children: [
                                    /* @__PURE__ */ _jsx37(PlayButton, {}),
                                    /* @__PURE__ */ _jsx37(Time, {}),
                                    /* @__PURE__ */ _jsx37(VolumeButton, {}),
                                    /* @__PURE__ */ _jsx37(FullscreenButton, {})
                                ]
                            })
                        })
                    })
                })
            ]
        })
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/Audio/index.tsx
import { Flex as Flex9 } from "@radix-ui/themes";
import "@vidstack/react/player/styles/base.css";
import { MediaPlayer as MediaPlayer2, MediaProvider as MediaProvider2, Controls as Controls2 } from "@vidstack/react";
import { jsx as _jsx38, jsxs as _jsxs13 } from "react/jsx-runtime";
var Audio = function(_ref) {
    var src = _ref.src;
    return /* @__PURE__ */ _jsx38(MediaContainer, {
        children: /* @__PURE__ */ _jsxs13(MediaPlayer2, {
            src: {
                src: src,
                type: "audio/".concat(src.split(".").pop())
            },
            viewType: "audio",
            crossOrigin: true,
            playsInline: true,
            children: [
                /* @__PURE__ */ _jsx38(MediaProvider2, {}),
                /* @__PURE__ */ _jsx38(Flex9, {
                    asChild: true,
                    p: "3",
                    flexGrow: "1",
                    style: {
                        zIndex: 10,
                        background: "var(--accent-4)"
                    },
                    children: /* @__PURE__ */ _jsx38(Controls2.Root, {
                        children: /* @__PURE__ */ _jsx38(Flex9, {
                            asChild: true,
                            align: "center",
                            gap: "3",
                            flexGrow: "1",
                            children: /* @__PURE__ */ _jsxs13(Controls2.Group, {
                                children: [
                                    /* @__PURE__ */ _jsx38(PlayButton, {}),
                                    /* @__PURE__ */ _jsx38(Time, {}),
                                    /* @__PURE__ */ _jsx38(VolumeButton, {})
                                ]
                            })
                        })
                    })
                })
            ]
        })
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Img/index.tsx
import { jsx as _jsx39 } from "react/jsx-runtime";
function ownKeys21(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread21(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys21(Object(t), true).forEach(function(r2) {
            _defineProperty21(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys21(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty21(e, r, t) {
    return (r = _toPropertyKey21(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey21(t) {
    var i = _toPrimitive21(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive21(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Img = function(props) {
    var $ = _c19(8);
    if (!props.src) {
        var t0;
        if ($[0] !== props) {
            t0 = /* @__PURE__ */ _jsx39(Image, _objectSpread21({}, props));
            $[0] = props;
            $[1] = t0;
        } else {
            t0 = $[1];
        }
        return t0;
    } else {
        if (isVideoSrc({
            src: props.src
        })) {
            var _t;
            if ($[2] !== props.src) {
                _t = /* @__PURE__ */ _jsx39(Video, {
                    src: props.src
                });
                $[2] = props.src;
                $[3] = _t;
            } else {
                _t = $[3];
            }
            return _t;
        } else {
            if (isAudioSrc({
                src: props.src
            })) {
                var _t2;
                if ($[4] !== props.src) {
                    _t2 = /* @__PURE__ */ _jsx39(Audio, {
                        src: props.src
                    });
                    $[4] = props.src;
                    $[5] = _t2;
                } else {
                    _t2 = $[5];
                }
                return _t2;
            } else {
                var _t3;
                if ($[6] !== props) {
                    _t3 = /* @__PURE__ */ _jsx39(Image, _objectSpread21({}, props));
                    $[6] = props;
                    $[7] = _t3;
                } else {
                    _t3 = $[7];
                }
                return _t3;
            }
        }
    }
};
// src/contexts/markdown/MarkdownContext/lib/components/Annotation/index.tsx
import { c as _c21 } from "react-compiler-runtime";
import { QuoteIcon } from "@radix-ui/react-icons";
// src/components/annotations/FilePathAnnotation.tsx
import { c as _c20 } from "react-compiler-runtime";
import { jsx as _jsx40 } from "react/jsx-runtime";
var FilePathAnnotation = function(t0) {
    var $ = _c20(3);
    var annotation = t0.annotation, children = t0.children;
    var superinterfaceContext = useSuperinterfaceContext();
    var nextSearchParams = new URLSearchParams(superinterfaceContext.variables);
    var t1 = "".concat(superinterfaceContext.baseUrl, "/files/").concat(annotation.file_path.file_id, "/contents?").concat(nextSearchParams);
    var t2;
    if ($[0] !== children || $[1] !== t1) {
        t2 = /* @__PURE__ */ _jsx40(Link, {
            href: t1,
            target: "_self",
            download: true,
            children: children
        });
        $[0] = children;
        $[1] = t1;
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    return t2;
};
// src/contexts/markdown/MarkdownContext/lib/components/Annotation/AnnotationBase.tsx
import { IconButton as IconButton4, Popover as Popover4, Flex as Flex10, Text as Text5 } from "@radix-ui/themes";
import { jsx as _jsx41, jsxs as _jsxs14 } from "react/jsx-runtime";
var AnnotationBase = function(_ref) {
    var icon = _ref.icon, content2 = _ref.content;
    return /* @__PURE__ */ _jsxs14(Popover4.Root, {
        children: [
            /* @__PURE__ */ _jsx41(Popover4.Trigger, {
                children: /* @__PURE__ */ _jsx41(IconButton4, {
                    variant: "soft",
                    color: "gray",
                    size: "1",
                    children: icon
                })
            }),
            /* @__PURE__ */ _jsx41(Popover4.Content, {
                size: "1",
                children: /* @__PURE__ */ _jsx41(Flex10, {
                    direction: "column",
                    children: /* @__PURE__ */ _jsx41(Text5, {
                        size: "1",
                        color: "gray",
                        children: content2
                    })
                })
            })
        ]
    });
};
// src/contexts/markdown/MarkdownContext/lib/components/Annotation/index.tsx
import { jsx as _jsx42 } from "react/jsx-runtime";
var _excluded = [
    "children"
];
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
var Annotation = function(t0) {
    var $ = _c21(9);
    var children;
    var rest;
    if ($[0] !== t0) {
        var _t = t0;
        children = _t.children;
        rest = _objectWithoutProperties(_t, _excluded);
        _t;
        $[0] = t0;
        $[1] = children;
        $[2] = rest;
    } else {
        children = $[1];
        rest = $[2];
    }
    var t1;
    if ($[3] !== rest) {
        var _rest$dataAnnotation;
        t1 = JSON.parse((_rest$dataAnnotation = rest["data-annotation"]) !== null && _rest$dataAnnotation !== void 0 ? _rest$dataAnnotation : "{}");
        $[3] = rest;
        $[4] = t1;
    } else {
        t1 = $[4];
    }
    var annotation = t1;
    if (annotation.type === "file_citation") {
        var t2;
        if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
            t2 = /* @__PURE__ */ _jsx42(AnnotationBase, {
                icon: /* @__PURE__ */ _jsx42(QuoteIcon, {}),
                content: "File cited."
            });
            $[5] = t2;
        } else {
            t2 = $[5];
        }
        return t2;
    } else {
        if (annotation.type === "file_path") {
            var _t2;
            if ($[6] !== annotation || $[7] !== children) {
                _t2 = /* @__PURE__ */ _jsx42(FilePathAnnotation, {
                    annotation: annotation,
                    children: children
                });
                $[6] = annotation;
                $[7] = children;
                $[8] = _t2;
            } else {
                _t2 = $[8];
            }
            return _t2;
        }
    }
    return null;
};
// src/contexts/markdown/MarkdownContext/lib/components/index.tsx
import { jsx as _jsx43, Fragment as _Fragment, jsxs as _jsxs15 } from "react/jsx-runtime";
var _excluded2 = [
    "width"
];
function _objectWithoutProperties2(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose2(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose2(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
function ownKeys22(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread22(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys22(Object(t), true).forEach(function(r2) {
            _defineProperty22(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys22(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty22(e, r, t) {
    return (r = _toPropertyKey22(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey22(t) {
    var i = _toPrimitive22(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive22(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var components = {
    p: Paragraph,
    a: Link,
    strong: Strong,
    ul: UnorderedList,
    ol: OrderedList,
    li: ListItem,
    pre: Pre,
    code: Code3,
    img: Img,
    annotation: Annotation,
    h1: function(props) {
        return /* @__PURE__ */ _jsx43(Heading, {
            as: "h1",
            children: props.children
        });
    },
    h2: function(props) {
        return /* @__PURE__ */ _jsx43(Heading, {
            as: "h2",
            size: "5",
            children: props.children
        });
    },
    h3: function(props) {
        return /* @__PURE__ */ _jsx43(Heading, {
            as: "h3",
            size: "4",
            children: props.children
        });
    },
    h4: function(props) {
        return /* @__PURE__ */ _jsx43(Heading, {
            as: "h4",
            size: "3",
            children: props.children
        });
    },
    h5: function(props) {
        return /* @__PURE__ */ _jsx43(Heading, {
            as: "h5",
            size: "3",
            children: props.children
        });
    },
    h6: function(props) {
        return /* @__PURE__ */ _jsx43(Heading, {
            as: "h6",
            size: "3",
            children: props.children
        });
    },
    table: function(props) {
        return /* @__PURE__ */ _jsxs15(_Fragment, {
            children: [
                /* @__PURE__ */ _jsx43("style", {
                    children: ".rt-TableRootTable { overflow: inherit; }"
                }),
                /* @__PURE__ */ _jsx43(Table.Root, _objectSpread22(_objectSpread22({}, props), {}, {
                    variant: "surface",
                    mb: "3"
                }))
            ]
        });
    },
    thead: function(props) {
        return /* @__PURE__ */ _jsx43(Table.Header, _objectSpread22({}, props));
    },
    tbody: function(props) {
        return /* @__PURE__ */ _jsx43(Table.Body, _objectSpread22({}, props));
    },
    tr: function(props) {
        return /* @__PURE__ */ _jsx43(Table.Row, _objectSpread22({}, props));
    },
    td: function(_ref) {
        var width2 = _ref.width, rest = _objectWithoutProperties2(_ref, _excluded2);
        return /* @__PURE__ */ _jsx43(Table.Cell, _objectSpread22(_objectSpread22({}, rest), {}, {
            width: width2
        }));
    },
    th: function(props) {
        return /* @__PURE__ */ _jsx43(Table.ColumnHeaderCell, _objectSpread22({}, props));
    }
};
// src/contexts/markdown/MarkdownContext/lib/getRemarkPlugins.ts
import remarkGfm from "remark-gfm";
// src/lib/remark/remarkAnnotation.ts
import { isNumber } from "radash";
import flatMap from "unist-util-flatmap";
function ownKeys23(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread23(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys23(Object(t), true).forEach(function(r2) {
            _defineProperty23(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys23(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty23(e, r, t) {
    return (r = _toPropertyKey23(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey23(t) {
    var i = _toPrimitive23(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive23(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var sortedAnnotations = function(_ref) {
    var content2 = _ref.content;
    return content2.text.annotations.sort(function(a, b) {
        return a.start_index - b.start_index;
    });
};
var remarkAnnotation = function(_ref2) {
    var content2 = _ref2.content;
    return function() {
        return function(tree) {
            flatMap(tree, function(node) {
                if (node.type === "text" || node.type === "link") {
                    return processNodeWithAnnotations({
                        node: node,
                        content: content2
                    });
                } else {
                    return [
                        node
                    ];
                }
            });
        };
    };
};
var processNodeWithAnnotations = function(_ref3) {
    var _content$text;
    var node = _ref3.node, content2 = _ref3.content;
    if (!((_content$text = content2.text) !== null && _content$text !== void 0 && (_content$text = _content$text.annotations) !== null && _content$text !== void 0 && _content$text.length)) {
        return [
            node
        ];
    }
    if (!node.position) {
        return [
            node
        ];
    }
    var annotations = sortedAnnotations({
        content: content2
    });
    if (node.type === "text") {
        return processTextNode({
            node: node,
            annotations: annotations
        });
    } else if (node.type === "link") {
        var linkNode = node;
        linkNode.children = flatMap(linkNode.children, function(childNode) {
            if (childNode.type === "text") {
                return processTextNode({
                    node: childNode,
                    annotations: annotations
                });
            } else {
                return [
                    childNode
                ];
            }
        });
        return [
            linkNode
        ];
    } else {
        return [
            node
        ];
    }
};
var processTextNode = function(_ref4) {
    var node = _ref4.node, annotations = _ref4.annotations;
    if (!node.position || !node.value) {
        return [
            node
        ];
    }
    var nodeStart = node.position.start.offset;
    var nodeEnd = node.position.end.offset;
    if (!isNumber(nodeStart) || !isNumber(nodeEnd)) {
        return [
            node
        ];
    }
    var newNodes = [];
    var lastIndex = nodeStart;
    annotations.forEach(function(annotation) {
        var annotationStart = annotation.start_index;
        var annotationEnd = annotation.end_index;
        if (nodeEnd <= annotationStart || nodeStart >= annotationEnd) {
            return;
        }
        var start = Math.max(nodeStart, annotationStart);
        var end = Math.min(nodeEnd, annotationEnd);
        if (lastIndex < start) {
            newNodes.push(createTextNode({
                node: node,
                startOffset: lastIndex,
                endOffset: start
            }));
        }
        newNodes.push(createAnnotationNode({
            node: node,
            startOffset: start,
            endOffset: end,
            annotation: annotation
        }));
        lastIndex = end;
    });
    if (lastIndex < nodeEnd) {
        newNodes.push(createTextNode({
            node: node,
            startOffset: lastIndex,
            endOffset: nodeEnd
        }));
    }
    return newNodes;
};
var createTextNode = function(_ref5) {
    var node = _ref5.node, startOffset = _ref5.startOffset, endOffset = _ref5.endOffset;
    var valueStart = startOffset - node.position.start.offset;
    var valueEnd = endOffset - node.position.start.offset;
    return {
        type: "text",
        value: node.value.slice(valueStart, valueEnd),
        position: {
            start: _objectSpread23(_objectSpread23({}, node.position.start), {}, {
                offset: startOffset
            }),
            end: _objectSpread23(_objectSpread23({}, node.position.end), {}, {
                offset: endOffset
            })
        }
    };
};
var createAnnotationNode = function(_ref6) {
    var node = _ref6.node, startOffset = _ref6.startOffset, endOffset = _ref6.endOffset, annotation = _ref6.annotation;
    var valueStart = startOffset - node.position.start.offset;
    var valueEnd = endOffset - node.position.start.offset;
    return {
        type: "annotation",
        value: node.value.slice(valueStart, valueEnd),
        position: {
            start: _objectSpread23(_objectSpread23({}, node.position.start), {}, {
                offset: startOffset
            }),
            end: _objectSpread23(_objectSpread23({}, node.position.end), {}, {
                offset: endOffset
            })
        },
        data: {
            hName: "annotation",
            hProperties: _define_property({}, "data-annotation", JSON.stringify(annotation))
        }
    };
};
// src/lib/remark/remarkPureLiteralPlugin.ts
var import_parser = __toESM(require_lib(), 1);
var Babel = __toESM(require_lib4(), 1);
import { visit as visit2 } from "unist-util-visit";
var remarkPureLiteralPlugin = function() {
    return function(tree) {
        visit2(tree, function(node) {
            if (node.type === "mdxJsxFlowElement" || node.type === "mdxJsxTextElement") {
                var jsxEl = node;
                jsxEl.attributes.forEach(function(attr) {
                    if (attr.type === "mdxJsxExpressionAttribute") {
                        handleExpressionAttribute(attr, attr.value);
                    } else if (attr.type === "mdxJsxAttribute" && _type_of(attr.value) === "object" && attr.value !== null && attr.value.type === "mdxJsxAttributeValueExpression") {
                        handleExpressionAttribute(attr, attr.value.value);
                    }
                });
            }
            if (node.type === "mdxFlowExpression" || node.type === "mdxTextExpression") {
                var exprNode = node;
                node.type = "text";
                node.value = "{".concat(exprNode.value, "}");
                Object.keys(node).forEach(function(k) {
                    if (![
                        "type",
                        "value",
                        "position"
                    ].includes(k)) delete node[k];
                });
            }
        });
    };
};
var handleExpressionAttribute = function(attr, rawExpression) {
    if (!checkIfPureLiteral(rawExpression)) {
        attr.type = "mdxJsxAttribute";
        attr.value = "{".concat(rawExpression, "}");
    }
};
var fixRawExpression = function(rawExpr) {
    return "(".concat(rawExpr.trim(), ")");
};
var checkIfPureLiteral = function(rawExpr) {
    try {
        var ast = (0, import_parser.parse)(fixRawExpression(rawExpr), {
            sourceType: "unambiguous",
            plugins: [
                "jsx",
                "typescript"
            ]
        });
        if (ast.program.body.length !== 1) return false;
        var stmt = ast.program.body[0];
        return Babel.isExpressionStatement(stmt) && isNodePureLiteral(stmt.expression);
    } catch (_unused) {
        return false;
    }
};
var isNodePureLiteral = function(node) {
    if (!node) return false;
    if (Babel.isNumericLiteral(node) || Babel.isStringLiteral(node) || Babel.isBooleanLiteral(node) || Babel.isNullLiteral(node)) {
        return true;
    }
    if (Babel.isTemplateLiteral(node)) {
        if (node.expressions.length === 0) {
            return true;
        }
        return false;
    }
    if (Babel.isObjectExpression(node)) {
        return node.properties.every(function(prop) {
            return Babel.isObjectProperty(prop) && !prop.computed && (Babel.isIdentifier(prop.key) || Babel.isStringLiteral(prop.key) || Babel.isNumericLiteral(prop.key)) && isNodePureLiteral(prop.value);
        });
    }
    if (Babel.isArrayExpression(node)) {
        return node.elements.every(function(el) {
            return el && isNodePureLiteral(el);
        });
    }
    return false;
};
// src/contexts/markdown/MarkdownContext/lib/getRemarkPlugins.ts
var getRemarkPlugins = function(_ref) {
    var content2 = _ref.content;
    return [
        remarkPureLiteralPlugin,
        remarkAnnotation({
            content: content2
        }),
        remarkGfm
    ];
};
// src/contexts/markdown/MarkdownContext/index.ts
var MarkdownContext = /* @__PURE__ */ createContext6({
    components: components,
    getRemarkPlugins: getRemarkPlugins
});
// src/hooks/markdown/useMarkdownContext/index.ts
var useMarkdownContext = function() {
    return useContext5(MarkdownContext);
};
// src/components/messages/MessageContent/ContentPart/TextContent.tsx
import { ErrorBoundary } from "react-error-boundary";
import { jsx as _jsx44 } from "react/jsx-runtime";
function ownKeys24(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread24(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys24(Object(t), true).forEach(function(r2) {
            _defineProperty24(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys24(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty24(e, r, t) {
    return (r = _toPropertyKey24(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey24(t) {
    var i = _toPrimitive24(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive24(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function asyncGeneratorStep5(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator5(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep5(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep5(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var evaluate = /* @__PURE__ */ function() {
    var _ref2 = _asyncToGenerator5(function(_ref) {
        var code, fn;
        return _ts_generator(this, function(_state) {
            code = _ref.code;
            fn = new Function("runtime", "useMDXComponents", code);
            return [
                2,
                fn(_objectSpread24(_objectSpread24({}, runtime), {}, {
                    useMDXComponents: useMDXComponents
                }))
            ];
        });
    });
    return function evaluate2(_x) {
        return _ref2.apply(this, arguments);
    };
}();
var TextContent = function(t0) {
    var $ = _c22(13);
    var content2 = t0.content;
    var _useMarkdownContext = useMarkdownContext(), getRemarkPlugins2 = _useMarkdownContext.getRemarkPlugins, components2 = _useMarkdownContext.components;
    var t1;
    var t2;
    if ($[0] !== content2 || $[1] !== getRemarkPlugins2) {
        t2 = getRemarkPlugins2({
            content: content2
        });
        $[0] = content2;
        $[1] = getRemarkPlugins2;
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    t1 = t2;
    var remarkPlugins = t1;
    var _useState2 = _sliced_to_array(useState2(null), 2), MDXComponent = _useState2[0], setMDXComponent = _useState2[1];
    var t3;
    var t4;
    if ($[3] !== content2 || $[4] !== remarkPlugins) {
        t3 = function() {
            var compileMDX = /* @__PURE__ */ function() {
                var _ref3 = _asyncToGenerator5(function() {
                    var compiled, code, module, MDXContent, t52, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    compile(content2.text.value, {
                                        outputFormat: "function-body",
                                        remarkPlugins: remarkPlugins,
                                        recmaPlugins: [
                                            recmaFallbackComponentPlugin
                                        ],
                                        providerImportSource: "@mdx-js/react"
                                    })
                                ];
                            case 1:
                                compiled = _state.sent();
                                code = String(compiled);
                                return [
                                    4,
                                    evaluate({
                                        code: code
                                    })
                                ];
                            case 2:
                                module = _state.sent();
                                MDXContent = module.default;
                                setMDXComponent(function() {
                                    return MDXContent;
                                });
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                t52 = _state.sent();
                                error = t52;
                                return [
                                    3,
                                    4
                                ];
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                });
                return function compileMDX2() {
                    return _ref3.apply(this, arguments);
                };
            }();
            compileMDX();
        };
        t4 = [
            content2,
            remarkPlugins
        ];
        $[3] = content2;
        $[4] = remarkPlugins;
        $[5] = t3;
        $[6] = t4;
    } else {
        t3 = $[5];
        t4 = $[6];
    }
    useEffect2(t3, t4);
    if (!MDXComponent) {
        return content2.text.value;
    }
    var t5;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
        t5 = /* @__PURE__ */ _jsx44(Badge2, {
            color: "red",
            mb: "2",
            children: "Could not render message."
        });
        $[7] = t5;
    } else {
        t5 = $[7];
    }
    var t6;
    if ($[8] !== MDXComponent) {
        t6 = /* @__PURE__ */ _jsx44(MDXComponent, {});
        $[8] = MDXComponent;
        $[9] = t6;
    } else {
        t6 = $[9];
    }
    var t7;
    if ($[10] !== components2 || $[11] !== t6) {
        t7 = /* @__PURE__ */ _jsx44(ErrorBoundary, {
            fallback: t5,
            children: /* @__PURE__ */ _jsx44(MDXProvider, {
                components: components2,
                children: t6
            })
        });
        $[10] = components2;
        $[11] = t6;
        $[12] = t7;
    } else {
        t7 = $[12];
    }
    return t7;
};
// src/components/messages/MessageContent/ContentPart/ImageFileContent.tsx
import { c as _c23 } from "react-compiler-runtime";
import { jsx as _jsx45 } from "react/jsx-runtime";
var ImageFileContent = function(t0) {
    var $ = _c23(2);
    var content2 = t0.content;
    var superinterfaceContext = useSuperinterfaceContext();
    var nextSearchParams = new URLSearchParams(superinterfaceContext.variables);
    var t1 = "".concat(superinterfaceContext.baseUrl, "/files/").concat(content2.image_file.file_id, "/contents?").concat(nextSearchParams);
    var t2;
    if ($[0] !== t1) {
        t2 = /* @__PURE__ */ _jsx45(Image, {
            alt: "",
            src: t1
        });
        $[0] = t1;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    return t2;
};
// src/components/messages/MessageContent/ContentPart/index.tsx
import { jsx as _jsx46 } from "react/jsx-runtime";
var ContentPart = function(t0) {
    var $ = _c24(4);
    var content2 = t0.content;
    if (content2.type === "text") {
        var t1;
        if ($[0] !== content2) {
            t1 = /* @__PURE__ */ _jsx46(TextContent, {
                content: content2
            });
            $[0] = content2;
            $[1] = t1;
        } else {
            t1 = $[1];
        }
        return t1;
    }
    if (content2.type === "image_file") {
        var _t;
        if ($[2] !== content2) {
            _t = /* @__PURE__ */ _jsx46(ImageFileContent, {
                content: content2
            });
            $[2] = content2;
            $[3] = _t;
        } else {
            _t = $[3];
        }
        return _t;
    }
    return null;
};
// src/components/messages/MessageContent/index.tsx
import { jsx as _jsx47, Fragment as _Fragment2 } from "react/jsx-runtime";
var MessageContent = function(_ref) {
    var message = _ref.message;
    return /* @__PURE__ */ _jsx47(_Fragment2, {
        children: message.content.map(function(content2, index) {
            return /* @__PURE__ */ _jsx47(ContentPart, {
                content: content2
            }, index);
        })
    });
};
// src/components/threads/Thread/Message/index.tsx
import { jsx as _jsx48, jsxs as _jsxs16 } from "react/jsx-runtime";
var Message = function(t0) {
    var $ = _c25(50);
    var message = t0.message, className = t0.className, style = t0.style;
    var t1;
    bb0: {
        if (!message.runSteps.length) {
            var _t;
            if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
                _t = [
                    [],
                    []
                ];
                $[0] = _t;
            } else {
                _t = $[0];
            }
            t1 = _t;
            break bb0;
        }
        var _t2;
        if ($[1] !== message.id) {
            _t2 = function(runStep) {
                if (runStep.step_details.type !== "message_creation") {
                    return;
                }
                return runStep.step_details.message_creation.message_id === message.id;
            };
            $[1] = message.id;
            $[2] = _t2;
        } else {
            _t2 = $[2];
        }
        var messageCreationRunStepIndex = message.runSteps.findIndex(_t2);
        var _t3;
        if ($[3] !== message.runSteps || $[4] !== messageCreationRunStepIndex) {
            var nextRunStepIndex = message.runSteps.slice(0, messageCreationRunStepIndex).findLastIndex(_temp);
            if (nextRunStepIndex === -1) {
                nextRunStepIndex = 0;
            }
            _t3 = message.runSteps.slice(nextRunStepIndex, messageCreationRunStepIndex);
            $[3] = message.runSteps;
            $[4] = messageCreationRunStepIndex;
            $[5] = _t3;
        } else {
            _t3 = $[5];
        }
        var laterRunSteps = _t3;
        var _t4;
        if ($[6] !== message.runSteps || $[7] !== messageCreationRunStepIndex) {
            _t4 = message.runSteps.slice(messageCreationRunStepIndex + 1).findIndex(_temp2);
            $[6] = message.runSteps;
            $[7] = messageCreationRunStepIndex;
            $[8] = _t4;
        } else {
            _t4 = $[8];
        }
        var prevRunStepIndex = _t4;
        var olderRunSteps;
        if (prevRunStepIndex === -1) {
            var _t5;
            if ($[9] !== message.runSteps || $[10] !== messageCreationRunStepIndex) {
                _t5 = message.runSteps.slice(messageCreationRunStepIndex + 1);
                $[9] = message.runSteps;
                $[10] = messageCreationRunStepIndex;
                $[11] = _t5;
            } else {
                _t5 = $[11];
            }
            olderRunSteps = _t5;
        } else {
            var _t6;
            if ($[12] !== message.runSteps || $[13] !== messageCreationRunStepIndex || $[14] !== prevRunStepIndex) {
                _t6 = message.runSteps.slice(messageCreationRunStepIndex + 1, messageCreationRunStepIndex + prevRunStepIndex);
                $[12] = message.runSteps;
                $[13] = messageCreationRunStepIndex;
                $[14] = prevRunStepIndex;
                $[15] = _t6;
            } else {
                _t6 = $[15];
            }
            olderRunSteps = _t6;
        }
        var _t7;
        if ($[16] !== laterRunSteps || $[17] !== olderRunSteps) {
            _t7 = [
                olderRunSteps,
                laterRunSteps
            ];
            $[16] = laterRunSteps;
            $[17] = olderRunSteps;
            $[18] = _t7;
        } else {
            _t7 = $[18];
        }
        t1 = _t7;
    }
    var _t1 = _sliced_to_array(t1, 2), olderRunSteps_0 = _t1[0], laterRunSteps_0 = _t1[1];
    var isMutatingMessage = useIsMutatingMessage();
    var t2;
    bb1: {
        if (!isMutatingMessage) {
            t2 = false;
            break bb1;
        }
        if (message.status === "in_progress") {
            t2 = true;
            break bb1;
        }
        var _t8;
        if ($[19] !== message.runSteps) {
            _t8 = message.runSteps.some(_temp3);
            $[19] = message.runSteps;
            $[20] = _t8;
        } else {
            _t8 = $[20];
        }
        t2 = _t8;
    }
    var isInProgress = t2;
    var t3;
    if ($[21] !== message) {
        t3 = {
            message: message
        };
        $[21] = message;
        $[22] = t3;
    } else {
        t3 = $[22];
    }
    var t4;
    if ($[23] !== olderRunSteps_0) {
        t4 = /* @__PURE__ */ _jsx48(RunSteps, {
            runSteps: olderRunSteps_0
        });
        $[23] = olderRunSteps_0;
        $[24] = t4;
    } else {
        t4 = $[24];
    }
    var t5;
    var t6;
    if ($[25] !== message) {
        t5 = /* @__PURE__ */ _jsx48(Attachments, {
            message: message
        });
        t6 = /* @__PURE__ */ _jsx48(MessageContent, {
            message: message
        });
        $[25] = message;
        $[26] = t5;
        $[27] = t6;
    } else {
        t5 = $[26];
        t6 = $[27];
    }
    var t7;
    if ($[28] !== isInProgress || $[29] !== laterRunSteps_0) {
        t7 = isInProgress && isEmpty2(laterRunSteps_0) && /* @__PURE__ */ _jsx48(StartingContentSkeleton, {});
        $[28] = isInProgress;
        $[29] = laterRunSteps_0;
        $[30] = t7;
    } else {
        t7 = $[30];
    }
    var t8;
    if ($[31] !== t5 || $[32] !== t6 || $[33] !== t7) {
        t8 = /* @__PURE__ */ _jsxs16(Box9, {
            children: [
                t5,
                t6,
                t7
            ]
        });
        $[31] = t5;
        $[32] = t6;
        $[33] = t7;
        $[34] = t8;
    } else {
        t8 = $[34];
    }
    var t9;
    if ($[35] !== laterRunSteps_0) {
        t9 = /* @__PURE__ */ _jsx48(RunSteps, {
            runSteps: laterRunSteps_0
        });
        $[35] = laterRunSteps_0;
        $[36] = t9;
    } else {
        t9 = $[36];
    }
    var t10;
    if ($[37] !== isInProgress || $[38] !== laterRunSteps_0) {
        t10 = isInProgress && !isEmpty2(laterRunSteps_0) && /* @__PURE__ */ _jsx48(Box9, {
            children: /* @__PURE__ */ _jsx48(StartingContentSkeleton, {})
        });
        $[37] = isInProgress;
        $[38] = laterRunSteps_0;
        $[39] = t10;
    } else {
        t10 = $[39];
    }
    var t11;
    if ($[40] !== className || $[41] !== style || $[42] !== t10 || $[43] !== t4 || $[44] !== t8 || $[45] !== t9) {
        t11 = /* @__PURE__ */ _jsxs16(Box9, {
            className: className,
            style: style,
            children: [
                t4,
                t8,
                t9,
                t10
            ]
        });
        $[40] = className;
        $[41] = style;
        $[42] = t10;
        $[43] = t4;
        $[44] = t8;
        $[45] = t9;
        $[46] = t11;
    } else {
        t11 = $[46];
    }
    var t12;
    if ($[47] !== t11 || $[48] !== t3) {
        t12 = /* @__PURE__ */ _jsx48(Provider, {
            value: t3,
            children: t11
        });
        $[47] = t11;
        $[48] = t3;
        $[49] = t12;
    } else {
        t12 = $[49];
    }
    return t12;
};
function _temp(runStep_0) {
    return runStep_0.step_details.type === "message_creation";
}
function _temp2(runStep_1) {
    return runStep_1.step_details.type === "message_creation";
}
function _temp3(rs) {
    return rs.status === "in_progress";
}
// src/components/threads/Thread/Messages/Content/index.tsx
import { c as _c32 } from "react-compiler-runtime";
import { useEffect as useEffect3 } from "react";
// src/hooks/messageGroups/useMessageGroups/index.ts
import { c as _c26 } from "react-compiler-runtime";
import { useMemo as useMemo10 } from "react";
// src/hooks/messageGroups/useMessageGroups/lib/messageGroups/index.ts
import _6 from "lodash";
import { last as last2 } from "radash";
// src/lib/messages/order.ts
import { sort } from "radash";
var order = function(_ref) {
    var messages2 = _ref.messages;
    return sort(messages2, function(m) {
        return m.created_at;
    }, true);
};
// src/hooks/messageGroups/useMessageGroups/lib/messageGroups/newGroup/newGroupItem.ts
var newGroupItem = function(_ref) {
    var message = _ref.message;
    return {
        id: message.id,
        role: message.role,
        createdAt: message.created_at,
        messages: [
            message
        ]
    };
};
// src/hooks/messageGroups/useMessageGroups/lib/messageGroups/newGroup/index.ts
var newGroup = function(_ref) {
    var groups = _ref.groups, message = _ref.message;
    return _to_consumable_array(groups).concat([
        newGroupItem({
            message: message
        })
    ]);
};
// src/hooks/messageGroups/useMessageGroups/lib/messageGroups/index.ts
function ownKeys25(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread25(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
            _defineProperty25(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty25(e, r, t) {
    return (r = _toPropertyKey25(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey25(t) {
    var i = _toPrimitive25(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive25(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var messageGroups = function(_ref) {
    var messages2 = _ref.messages;
    return _6.reduce(order({
        messages: messages2
    }), function(groups, message) {
        var group = last2(groups);
        if (!group) return newGroup({
            groups: groups,
            message: message
        });
        if (group.role !== message.role) {
            return newGroup({
                groups: groups,
                message: message
            });
        }
        return _to_consumable_array(_6.dropRight(groups)).concat([
            _objectSpread25(_objectSpread25({}, group), {}, {
                messages: _to_consumable_array(group.messages).concat([
                    message
                ])
            })
        ]);
    }, []);
};
// src/hooks/messageGroups/useMessageGroups/index.ts
var useMessageGroups = function(t0) {
    var $ = _c26(4);
    var messages2 = t0.messages;
    var t1;
    var t2;
    if ($[0] !== messages2) {
        t2 = messageGroups({
            messages: messages2
        });
        $[0] = messages2;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    var t3;
    if ($[2] !== t2) {
        t3 = {
            messageGroups: t2
        };
        $[2] = t2;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    t1 = t3;
    return t1;
};
// src/components/skeletons/MessagesSkeleton/index.tsx
import { c as _c28 } from "react-compiler-runtime";
import { forwardRef as forwardRef2 } from "react";
import { Flex as Flex13, Avatar, Box as Box10, Skeleton as Skeleton2 } from "@radix-ui/themes";
// src/components/messageGroups/MessageGroupBase/index.tsx
import { c as _c27 } from "react-compiler-runtime";
import { forwardRef } from "react";
import { Flex as Flex11, Container } from "@radix-ui/themes";
import { jsx as _jsx49 } from "react/jsx-runtime";
var MessageGroupBase = /* @__PURE__ */ forwardRef(function MessageGroupBase2(t0, ref) {
    var $ = _c27(5);
    var children = t0.children;
    var t1;
    if ($[0] !== children) {
        t1 = /* @__PURE__ */ _jsx49(Flex11, {
            flexShrink: "0",
            gap: "3",
            children: children
        });
        $[0] = children;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2;
    if ($[2] !== ref || $[3] !== t1) {
        t2 = /* @__PURE__ */ _jsx49(Container, {
            ref: ref,
            size: "2",
            flexGrow: "0",
            children: t1
        });
        $[2] = ref;
        $[3] = t1;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    return t2;
});
// src/components/messageGroups/MessageGroupBase/Name.tsx
import { Flex as Flex12, Text as Text6 } from "@radix-ui/themes";
import { jsx as _jsx50 } from "react/jsx-runtime";
var Name = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx50(Flex12, {
        align: "center",
        height: "var(--space-5)",
        children: /* @__PURE__ */ _jsx50(Text6, {
            size: "2",
            weight: "bold",
            children: children
        })
    });
};
// src/components/skeletons/MessagesSkeleton/index.tsx
import { jsx as _jsx51, jsxs as _jsxs17 } from "react/jsx-runtime";
var MessagesSkeleton = /* @__PURE__ */ forwardRef2(function MessagesSkeleton2(_props, ref) {
    var $ = _c28(7);
    var t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = /* @__PURE__ */ _jsx51(Skeleton2, {
            loading: true,
            children: /* @__PURE__ */ _jsx51(Avatar, {
                fallback: /* @__PURE__ */ _jsx51(Flex13, {}),
                size: "1"
            })
        });
        $[0] = t0;
    } else {
        t0 = $[0];
    }
    var t1;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = /* @__PURE__ */ _jsx51(Name, {
            children: /* @__PURE__ */ _jsx51(Skeleton2, {
                loading: true,
                style: {
                    width: "128px"
                }
            })
        });
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = /* @__PURE__ */ _jsx51(Skeleton2, {
            loading: true,
            style: {
                width: "256px"
            }
        });
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    var t3;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = /* @__PURE__ */ _jsx51(Skeleton2, {
            loading: true,
            style: {
                width: "256px",
                marginTop: "var(--space-2)"
            }
        });
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    var t4;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t4 = /* @__PURE__ */ _jsxs17(Box10, {
            pb: "3",
            children: [
                t1,
                t2,
                t3,
                /* @__PURE__ */ _jsx51(Skeleton2, {
                    loading: true,
                    style: {
                        width: "256px",
                        marginTop: "var(--space-2)"
                    }
                })
            ]
        });
        $[4] = t4;
    } else {
        t4 = $[4];
    }
    var t5;
    if ($[5] !== ref) {
        t5 = /* @__PURE__ */ _jsxs17(MessageGroupBase, {
            ref: ref,
            children: [
                t0,
                t4
            ]
        });
        $[5] = ref;
        $[6] = t5;
    } else {
        t5 = $[6];
    }
    return t5;
});
// src/components/threads/Thread/Messages/Content/MessageGroup/index.tsx
import { c as _c31 } from "react-compiler-runtime";
import { useContext as useContext8 } from "react";
import { Box as Box11 } from "@radix-ui/themes";
// src/components/messageGroups/MessageGroupBase/AssistantAvatar.tsx
import { c as _c29 } from "react-compiler-runtime";
import { useContext as useContext6 } from "react";
import { Flex as Flex14 } from "@radix-ui/themes";
// src/contexts/assistants/AssistantAvatarContext/index.tsx
import { createContext as createContext7 } from "react";
import { Avatar as Avatar2 } from "@radix-ui/themes";
import { LightningBoltIcon } from "@radix-ui/react-icons";
import { jsx as _jsx52 } from "react/jsx-runtime";
var AssistantAvatarContext = /* @__PURE__ */ createContext7(/* @__PURE__ */ _jsx52(Avatar2, {
    fallback: /* @__PURE__ */ _jsx52(LightningBoltIcon, {}),
    size: "1"
}));
// src/components/messageGroups/MessageGroupBase/AssistantAvatar.tsx
import { jsx as _jsx53 } from "react/jsx-runtime";
var AssistantAvatar = function() {
    var $ = _c29(3);
    var AssistantAvatarContextValue = useContext6(AssistantAvatarContext);
    var t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = {
            borderRadius: "var(--radius-3)",
            overflow: "hidden"
        };
        $[0] = t0;
    } else {
        t0 = $[0];
    }
    var t1;
    if ($[1] !== AssistantAvatarContextValue) {
        t1 = /* @__PURE__ */ _jsx53(Flex14, {
            flexShrink: "0",
            height: "24px",
            width: "24px",
            style: t0,
            children: AssistantAvatarContextValue
        });
        $[1] = AssistantAvatarContextValue;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    return t1;
};
// src/contexts/assistants/AssistantNameContext/index.tsx
import { createContext as createContext8 } from "react";
var AssistantNameContext = /* @__PURE__ */ createContext8("Assistant");
// src/components/messageGroups/MessageGroupBase/UserAvatar.tsx
import { c as _c30 } from "react-compiler-runtime";
import { useContext as useContext7 } from "react";
import { Flex as Flex15 } from "@radix-ui/themes";
// src/contexts/users/UserAvatarContext/index.tsx
import { createContext as createContext9 } from "react";
import { Avatar as Avatar3 } from "@radix-ui/themes";
import { PersonIcon } from "@radix-ui/react-icons";
import { jsx as _jsx54 } from "react/jsx-runtime";
var UserAvatarContext = /* @__PURE__ */ createContext9(/* @__PURE__ */ _jsx54(Avatar3, {
    fallback: /* @__PURE__ */ _jsx54(PersonIcon, {}),
    size: "1"
}));
// src/components/messageGroups/MessageGroupBase/UserAvatar.tsx
import { jsx as _jsx55 } from "react/jsx-runtime";
var UserAvatar = function() {
    var $ = _c30(3);
    var UserAvatarContextValue = useContext7(UserAvatarContext);
    var t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = {
            borderRadius: "var(--radius-3)",
            overflow: "hidden"
        };
        $[0] = t0;
    } else {
        t0 = $[0];
    }
    var t1;
    if ($[1] !== UserAvatarContextValue) {
        t1 = /* @__PURE__ */ _jsx55(Flex15, {
            flexShrink: "0",
            height: "24px",
            width: "24px",
            style: t0,
            children: UserAvatarContextValue
        });
        $[1] = UserAvatarContextValue;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    return t1;
};
// src/components/threads/Thread/Messages/Content/MessageGroup/Content/index.tsx
import { Flex as Flex16 } from "@radix-ui/themes";
import { jsx as _jsx56 } from "react/jsx-runtime";
var Content5 = function(_ref) {
    var messageGroup = _ref.messageGroup;
    return /* @__PURE__ */ _jsx56(Flex16, {
        direction: "column-reverse",
        children: messageGroup.messages.map(function(message) {
            return /* @__PURE__ */ _jsx56(Message, {
                message: message
            }, message.id);
        })
    });
};
// src/components/threads/Thread/Messages/Content/MessageGroup/index.tsx
import { jsx as _jsx57, jsxs as _jsxs18 } from "react/jsx-runtime";
var MessageGroup = function(t0) {
    var $ = _c31(12);
    var messageGroup = t0.messageGroup;
    var assistantNameContext = useContext8(AssistantNameContext);
    var t1;
    if ($[0] !== messageGroup.role) {
        t1 = messageGroup.role === "user" ? /* @__PURE__ */ _jsx57(UserAvatar, {}) : /* @__PURE__ */ _jsx57(AssistantAvatar, {});
        $[0] = messageGroup.role;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2 = messageGroup.role === "user" ? "You" : assistantNameContext;
    var t3;
    if ($[2] !== t2) {
        t3 = /* @__PURE__ */ _jsx57(Name, {
            children: t2
        });
        $[2] = t2;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    var t4;
    if ($[4] !== messageGroup) {
        t4 = /* @__PURE__ */ _jsx57(Content5, {
            messageGroup: messageGroup
        });
        $[4] = messageGroup;
        $[5] = t4;
    } else {
        t4 = $[5];
    }
    var t5;
    if ($[6] !== t3 || $[7] !== t4) {
        t5 = /* @__PURE__ */ _jsxs18(Box11, {
            flexGrow: "1",
            children: [
                t3,
                t4
            ]
        });
        $[6] = t3;
        $[7] = t4;
        $[8] = t5;
    } else {
        t5 = $[8];
    }
    var t6;
    if ($[9] !== t1 || $[10] !== t5) {
        t6 = /* @__PURE__ */ _jsxs18(MessageGroupBase, {
            children: [
                t1,
                t5
            ]
        });
        $[9] = t1;
        $[10] = t5;
        $[11] = t6;
    } else {
        t6 = $[11];
    }
    return t6;
};
// src/components/threads/Thread/Messages/Content/index.tsx
import { jsx as _jsx58, Fragment as _Fragment3 } from "react/jsx-runtime";
var Content6 = function() {
    var $ = _c32(11);
    var _useMessages = useMessages(), messages2 = _useMessages.messages, isLoading = _useMessages.isLoading, isLoadingError = _useMessages.isLoadingError;
    var addToast = useToasts().addToast;
    var t0;
    if ($[0] !== messages2) {
        t0 = {
            messages: messages2
        };
        $[0] = messages2;
        $[1] = t0;
    } else {
        t0 = $[1];
    }
    var _useMessageGroups = useMessageGroups(t0), messageGroups2 = _useMessageGroups.messageGroups;
    var t1;
    var t2;
    if ($[2] !== addToast || $[3] !== isLoadingError) {
        t1 = function() {
            if (isLoadingError) {
                addToast({
                    type: "error",
                    message: "Could not load messages. Please try again."
                });
            }
        };
        t2 = [
            isLoadingError,
            addToast
        ];
        $[2] = addToast;
        $[3] = isLoadingError;
        $[4] = t1;
        $[5] = t2;
    } else {
        t1 = $[4];
        t2 = $[5];
    }
    useEffect3(t1, t2);
    if (isLoading || isLoadingError) {
        var _t;
        if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
            _t = /* @__PURE__ */ _jsx58(MessagesSkeleton, {});
            $[6] = _t;
        } else {
            _t = $[6];
        }
        return _t;
    }
    var t3;
    if ($[7] !== messageGroups2) {
        t3 = messageGroups2.map(_temp4);
        $[7] = messageGroups2;
        $[8] = t3;
    } else {
        t3 = $[8];
    }
    var t4;
    if ($[9] !== t3) {
        t4 = /* @__PURE__ */ _jsx58(_Fragment3, {
            children: t3
        });
        $[9] = t3;
        $[10] = t4;
    } else {
        t4 = $[10];
    }
    return t4;
};
function _temp4(messageGroup) {
    return /* @__PURE__ */ _jsx58(MessageGroup, {
        messageGroup: messageGroup
    }, messageGroup.id);
}
// src/components/threads/Thread/Messages/Progress/index.tsx
import { c as _c34 } from "react-compiler-runtime";
import { useMemo as useMemo11 } from "react";
// src/components/skeletons/StartingSkeleton/index.tsx
import { c as _c33 } from "react-compiler-runtime";
import { useContext as useContext9 } from "react";
import { Box as Box12 } from "@radix-ui/themes";
import { jsx as _jsx59, jsxs as _jsxs19 } from "react/jsx-runtime";
var StartingSkeleton = function(t0) {
    var $ = _c33(7);
    var children = t0.children;
    var assistantNameContext = useContext9(AssistantNameContext);
    var t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = /* @__PURE__ */ _jsx59(AssistantAvatar, {});
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    var t2;
    if ($[1] !== assistantNameContext) {
        t2 = /* @__PURE__ */ _jsx59(Name, {
            children: assistantNameContext
        });
        $[1] = assistantNameContext;
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    var t3;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = /* @__PURE__ */ _jsx59(StartingContentSkeleton, {});
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    var t4;
    if ($[4] !== children || $[5] !== t2) {
        t4 = /* @__PURE__ */ _jsxs19(MessageGroupBase, {
            children: [
                t1,
                /* @__PURE__ */ _jsxs19(Box12, {
                    children: [
                        t2,
                        children,
                        t3
                    ]
                })
            ]
        });
        $[4] = children;
        $[5] = t2;
        $[6] = t4;
    } else {
        t4 = $[6];
    }
    return t4;
};
// src/components/threads/Thread/Messages/Progress/index.tsx
import { jsx as _jsx60 } from "react/jsx-runtime";
var Progress = function() {
    var $ = _c34(1);
    var latestMessage = useLatestMessage().latestMessage;
    var isMutatingMessage = useIsMutatingMessage();
    var t0;
    bb0: {
        if (!latestMessage) {
            t0 = false;
            break bb0;
        }
        if (latestMessage.role !== "user") {
            t0 = false;
            break bb0;
        }
        if (latestMessage.status === "in_progress") {
            t0 = false;
            break bb0;
        }
        if (!isOptimistic({
            id: latestMessage.id
        })) {
            t0 = false;
            break bb0;
        }
        if (!isMutatingMessage) {
            t0 = false;
            break bb0;
        }
        t0 = true;
    }
    var isVisible = t0;
    if (!isVisible) {
        return null;
    }
    var t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = /* @__PURE__ */ _jsx60(StartingSkeleton, {});
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    return t1;
};
// src/components/threads/Thread/Messages/Root/index.tsx
import { c as _c35 } from "react-compiler-runtime";
import { Flex as Flex17 } from "@radix-ui/themes";
// src/hooks/misc/useInfiniteScroll/index.tsx
import { useRef as useRef3 } from "react";
import { useInView } from "react-intersection-observer";
// src/hooks/misc/useThrottledEffect/index.tsx
import _7 from "lodash";
import { useRef as useRef2, useEffect as useEffect4, useCallback as useCallback2 } from "react";
var useThrottledEffect = function(cb, delay, additionalDeps) {
    var cbRef = useRef2(cb);
    var throttledCb = useCallback2(_7.throttle(function() {
        var _cbRef;
        return (_cbRef = cbRef).current.apply(_cbRef, arguments);
    }, delay, {
        leading: true,
        trailing: true
    }), [
        delay
    ]);
    useEffect4(function() {
        cbRef.current = cb;
    });
    useEffect4(throttledCb, [
        throttledCb
    ].concat(_to_consumable_array(additionalDeps)));
};
// src/hooks/misc/useInfiniteScroll/index.tsx
var useInfiniteScroll = function(_ref) {
    var isFetchingNextPage = _ref.isFetchingNextPage, hasNextPage = _ref.hasNextPage, fetchNextPage = _ref.fetchNextPage;
    var containerRef = useRef3(null);
    var _useInView = useInView({
        root: containerRef.current,
        rootMargin: "0px",
        threshold: 0.1
    }), loaderRef = _useInView.ref, inView = _useInView.inView;
    useThrottledEffect(function() {
        if (isFetchingNextPage) return;
        if (!inView) return;
        if (!hasNextPage) return;
        fetchNextPage();
    }, 500, [
        inView,
        isFetchingNextPage,
        hasNextPage,
        fetchNextPage
    ]);
    return {
        containerRef: containerRef,
        loaderRef: loaderRef,
        inView: inView
    };
};
// src/components/threads/Thread/Messages/Root/index.tsx
import { jsx as _jsx61, jsxs as _jsxs20 } from "react/jsx-runtime";
function ownKeys26(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread26(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys26(Object(t), true).forEach(function(r2) {
            _defineProperty26(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys26(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty26(e, r, t) {
    return (r = _toPropertyKey26(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey26(t) {
    var i = _toPrimitive26(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive26(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Root2 = function(t0) {
    var $ = _c35(18);
    var children = t0.children, style = t0.style, className = t0.className;
    var _useMessages = useMessages(), isFetchingNextPage = _useMessages.isFetchingNextPage, hasNextPage = _useMessages.hasNextPage, fetchNextPage = _useMessages.fetchNextPage;
    var t1;
    if ($[0] !== fetchNextPage || $[1] !== hasNextPage || $[2] !== isFetchingNextPage) {
        t1 = {
            isFetchingNextPage: isFetchingNextPage,
            hasNextPage: hasNextPage,
            fetchNextPage: fetchNextPage
        };
        $[0] = fetchNextPage;
        $[1] = hasNextPage;
        $[2] = isFetchingNextPage;
        $[3] = t1;
    } else {
        t1 = $[3];
    }
    var _useInfiniteScroll = useInfiniteScroll(t1), containerRef = _useInfiniteScroll.containerRef, loaderRef = _useInfiniteScroll.loaderRef;
    var t2;
    if ($[4] !== style) {
        t2 = style !== null && style !== void 0 ? style : {};
        $[4] = style;
        $[5] = t2;
    } else {
        t2 = $[5];
    }
    var t3;
    if ($[6] !== t2) {
        t3 = _objectSpread26({
            overflow: "auto"
        }, t2);
        $[6] = t2;
        $[7] = t3;
    } else {
        t3 = $[7];
    }
    var t4;
    if ($[8] !== hasNextPage || $[9] !== loaderRef) {
        t4 = hasNextPage && /* @__PURE__ */ _jsx61(Flex17, {
            ref: loaderRef
        });
        $[8] = hasNextPage;
        $[9] = loaderRef;
        $[10] = t4;
    } else {
        t4 = $[10];
    }
    var t5;
    if ($[11] === Symbol.for("react.memo_cache_sentinel")) {
        t5 = /* @__PURE__ */ _jsx61(Flex17, {
            flexShrink: "0",
            flexGrow: "1"
        });
        $[11] = t5;
    } else {
        t5 = $[11];
    }
    var t6;
    if ($[12] !== children || $[13] !== className || $[14] !== containerRef || $[15] !== t3 || $[16] !== t4) {
        t6 = /* @__PURE__ */ _jsxs20(Flex17, {
            ref: containerRef,
            direction: "column-reverse",
            flexGrow: "1",
            style: t3,
            className: className,
            children: [
                children,
                t4,
                t5
            ]
        });
        $[12] = children;
        $[13] = className;
        $[14] = containerRef;
        $[15] = t3;
        $[16] = t4;
        $[17] = t6;
    } else {
        t6 = $[17];
    }
    return t6;
};
// src/components/threads/Thread/Messages/NextPageSkeleton.tsx
import { c as _c36 } from "react-compiler-runtime";
import { jsx as _jsx62 } from "react/jsx-runtime";
var NextPageSkeleton = function() {
    var $ = _c36(1);
    var hasNextPage = useMessages().hasNextPage;
    if (!hasNextPage) {
        return null;
    }
    var t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = /* @__PURE__ */ _jsx62(MessagesSkeleton, {});
        $[0] = t0;
    } else {
        t0 = $[0];
    }
    return t0;
};
// src/components/threads/Thread/Messages/index.tsx
import { jsx as _jsx63, jsxs as _jsxs21 } from "react/jsx-runtime";
var Messages = function(_ref) {
    var children = _ref.children, className = _ref.className, style = _ref.style;
    return /* @__PURE__ */ _jsxs21(Root2, {
        style: style,
        className: className,
        children: [
            /* @__PURE__ */ _jsx63(Flex18, {
                flexShrink: "0",
                height: "var(--space-3)"
            }),
            /* @__PURE__ */ _jsx63(Progress, {}),
            children,
            /* @__PURE__ */ _jsx63(Content6, {}),
            /* @__PURE__ */ _jsx63(NextPageSkeleton, {}),
            /* @__PURE__ */ _jsx63(Flex18, {
                flexShrink: "0",
                flexGrow: "1",
                minHeight: "var(--space-5)"
            })
        ]
    });
};
Messages.Root = Root2;
Messages.Message = Message;
Messages.NextPageSkeleton = NextPageSkeleton;
// src/components/threads/Thread/MessageForm/Submit/index.tsx
import { c as _c37 } from "react-compiler-runtime";
import { ArrowUpIcon as ArrowUpIcon2, StopIcon } from "@radix-ui/react-icons";
import { IconButton as IconButton5, Flex as Flex19 } from "@radix-ui/themes";
// src/hooks/messages/useMessageFormContext/index.ts
import { useContext as useContext10 } from "react";
// src/contexts/messages/MessageFormContext/index.ts
import { createContext as createContext10 } from "react";
var MessageFormContext = /* @__PURE__ */ createContext10({
    content: "",
    isDisabled: false,
    isLoading: false,
    files: [],
    setFiles: function() {},
    isFileLoading: false
});
// src/hooks/messages/useMessageFormContext/index.ts
var useMessageFormContext = function() {
    return useContext10(MessageFormContext);
};
// src/components/threads/Thread/MessageForm/Submit/index.tsx
import { jsx as _jsx64 } from "react/jsx-runtime";
function ownKeys27(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread27(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys27(Object(t), true).forEach(function(r2) {
            _defineProperty27(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys27(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty27(e, r, t) {
    return (r = _toPropertyKey27(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey27(t) {
    var i = _toPrimitive27(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive27(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Root3 = function(_ref) {
    var children = _ref.children, style = _ref.style, className = _ref.className;
    return /* @__PURE__ */ _jsx64(Flex19, {
        flexShrink: "0",
        align: "end",
        style: style,
        className: className,
        children: children
    });
};
var Button3 = function(props) {
    var $ = _c37(10);
    var superinterfaceContext = useSuperinterfaceContext();
    var _useMessageFormContext = useMessageFormContext(), isDisabled = _useMessageFormContext.isDisabled, isLoading = _useMessageFormContext.isLoading, isFileLoading = _useMessageFormContext.isFileLoading;
    if (isLoading) {
        var _t;
        if ($[0] !== superinterfaceContext.createMessageAbortControllerRef.current) {
            _t = function() {
                var _superinterfaceContex;
                return (_superinterfaceContex = superinterfaceContext.createMessageAbortControllerRef.current) === null || _superinterfaceContex === void 0 ? void 0 : _superinterfaceContex.abort();
            };
            $[0] = superinterfaceContext.createMessageAbortControllerRef.current;
            $[1] = _t;
        } else {
            _t = $[1];
        }
        var _t2;
        if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
            _t2 = /* @__PURE__ */ _jsx64(StopIcon, {});
            $[2] = _t2;
        } else {
            _t2 = $[2];
        }
        var _t3;
        if ($[3] !== props || $[4] !== _t) {
            _t3 = /* @__PURE__ */ _jsx64(IconButton5, _objectSpread27(_objectSpread27({
                type: "button",
                onClick: _t
            }, props), {}, {
                children: _t2
            }));
            $[3] = props;
            $[4] = _t;
            $[5] = _t3;
        } else {
            _t3 = $[5];
        }
        return _t3;
    }
    var t0 = isDisabled || isFileLoading;
    var t1;
    if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = /* @__PURE__ */ _jsx64(ArrowUpIcon2, {});
        $[6] = t1;
    } else {
        t1 = $[6];
    }
    var t2;
    if ($[7] !== props || $[8] !== t0) {
        t2 = /* @__PURE__ */ _jsx64(IconButton5, _objectSpread27(_objectSpread27({
            type: "submit",
            disabled: t0
        }, props), {}, {
            children: t1
        }));
        $[7] = props;
        $[8] = t0;
        $[9] = t2;
    } else {
        t2 = $[9];
    }
    return t2;
};
var Submit = function(props) {
    return /* @__PURE__ */ _jsx64(Root3, _objectSpread27(_objectSpread27({}, props), {}, {
        children: /* @__PURE__ */ _jsx64(Button3, {})
    }));
};
Submit.Root = Root3;
Submit.Button = Button3;
// src/components/threads/Thread/MessageForm/Root/index.tsx
import { useQueryClient as useQueryClient4 } from "@tanstack/react-query";
import { useMemo as useMemo12, useState as useState3 } from "react";
import { useForm, FormProvider } from "react-hook-form";
import { Box as Box13 } from "@radix-ui/themes";
// src/components/threads/Thread/MessageForm/Root/lib/formOptions.ts
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
var schema = z.object({
    content: z.string().min(1)
});
var formOptions = {
    resolver: zodResolver(schema)
};
// src/components/threads/Thread/MessageForm/Root/index.tsx
import { partob } from "radash";
import { jsx as _jsx65 } from "react/jsx-runtime";
function ownKeys28(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread28(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys28(Object(t), true).forEach(function(r2) {
            _defineProperty28(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys28(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty28(e, r, t) {
    return (r = _toPropertyKey28(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey28(t) {
    var i = _toPrimitive28(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive28(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function asyncGeneratorStep6(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator6(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep6(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep6(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var Root4 = function(_ref) {
    "use no memo";
    var children = _ref.children, onSubmitArg = _ref.onSubmit, isDisabledArg = _ref.isDisabled, style = _ref.style, className = _ref.className;
    var _useState3 = _sliced_to_array(useState3([]), 2), files = _useState3[0], setFiles = _useState3[1];
    var formProps = useForm(formOptions);
    var handleSubmit = formProps.handleSubmit, isSubmitting = formProps.formState.isSubmitting, reset = formProps.reset, watch = formProps.watch;
    var addToast = useToasts().addToast;
    var queryClient = useQueryClient4();
    var threadContext = useSuperinterfaceContext();
    var createMessage = useCreateMessage({
        onError: createMessageDefaultOnError({
            queryClient: queryClient,
            addToast: addToast,
            threadContext: threadContext
        })
    }).createMessage;
    var isMutatingMessage = useIsMutatingMessage();
    var isFileLoading = useMemo12(function() {
        return files.some(function(file) {
            return isOptimistic({
                id: file.id
            });
        });
    }, [
        files
    ]);
    var isLoading = useMemo12(function() {
        return isMutatingMessage || isSubmitting;
    }, [
        isMutatingMessage,
        isSubmitting
    ]);
    var latestMessage = useLatestMessage().latestMessage;
    var isDisabled = useMemo12(function() {
        var _latestMessage$metada;
        return(// @ts-ignore-next-line
        (latestMessage === null || latestMessage === void 0 || (_latestMessage$metada = latestMessage.metadata) === null || _latestMessage$metada === void 0 ? void 0 : _latestMessage$metada.isBlocking) || isDisabledArg);
    }, [
        latestMessage,
        isDisabledArg
    ]);
    var onSubmit = onSubmitArg ? partob(onSubmitArg, {
        reset: reset,
        createMessage: createMessage
    }) : /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator6(function(data2) {
            var attachments;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (isFileLoading) return [
                            2
                        ];
                        if (isLoading) return [
                            2
                        ];
                        if (isDisabled) return [
                            2
                        ];
                        reset();
                        setFiles([]);
                        attachments = files.map(function(file_0) {
                            return {
                                file_id: file_0.id,
                                tools: [
                                    {
                                        type: "file_search"
                                    }
                                ]
                            };
                        });
                        return [
                            4,
                            createMessage(_objectSpread28({
                                // @ts-ignore-next-line
                                content: data2.content
                            }, attachments.length ? {
                                attachments: attachments
                            } : {}))
                        ];
                    case 1:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        });
        return function(_x) {
            return _ref2.apply(this, arguments);
        };
    }();
    var content2 = watch("content");
    return /* @__PURE__ */ _jsx65(MessageFormContext.Provider, {
        value: {
            isDisabled: isDisabled,
            isLoading: isLoading,
            files: files,
            setFiles: setFiles,
            isFileLoading: isFileLoading,
            content: content2
        },
        children: /* @__PURE__ */ _jsx65(FormProvider, _objectSpread28(_objectSpread28({}, formProps), {}, {
            children: /* @__PURE__ */ _jsx65(Box13, {
                asChild: true,
                flexShrink: "0",
                style: style,
                className: className,
                children: /* @__PURE__ */ _jsx65("form", {
                    onSubmit: handleSubmit(onSubmit),
                    children: children
                })
            })
        }))
    });
};
// src/components/threads/Thread/MessageForm/Field/index.tsx
import { useFormContext as useFormContext2 } from "react-hook-form";
import { Container as RadixContainer, Flex as Flex23 } from "@radix-ui/themes";
// src/components/threads/Thread/MessageForm/Field/Control.tsx
import { Flex as Flex20 } from "@radix-ui/themes";
import { useFormContext } from "react-hook-form";
// src/hooks/misc/usePrevious.ts
import { useEffect as useEffect5, useRef as useRef4 } from "react";
var usePrevious = function(state) {
    var ref = useRef4();
    useEffect5(function() {
        ref.current = state;
    });
    return ref.current;
};
// src/components/threads/Thread/MessageForm/Field/Control.tsx
import { useContext as useContext11, useMemo as useMemo13, useRef as useRef5, useEffect as useEffect6 } from "react";
// src/components/textareas/TextareaBase/index.tsx
import { c as _c38 } from "react-compiler-runtime";
import { forwardRef as forwardRef3 } from "react";
import TextareaAutosize from "react-textarea-autosize";
import { jsx as _jsx66, Fragment as _Fragment4, jsxs as _jsxs22 } from "react/jsx-runtime";
var _excluded3 = [
    "style",
    "className"
];
function ownKeys29(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread29(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys29(Object(t), true).forEach(function(r2) {
            _defineProperty29(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys29(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty29(e, r, t) {
    return (r = _toPropertyKey29(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey29(t) {
    var i = _toPrimitive29(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive29(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties3(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose3(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose3(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
var TextareaBase = /* @__PURE__ */ forwardRef3(function TextareaBase2(t0, ref) {
    var _className;
    var $ = _c38(14);
    var className;
    var rest;
    var style;
    if ($[0] !== t0) {
        var _t = t0;
        var _$ref;
        _$ref = _t, style = _$ref.style, className = _$ref.className, _$ref;
        rest = _objectWithoutProperties3(_t, _excluded3);
        _t;
        $[0] = t0;
        $[1] = className;
        $[2] = rest;
        $[3] = style;
    } else {
        className = $[1];
        rest = $[2];
        style = $[3];
    }
    var t1;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = /* @__PURE__ */ _jsx66("style", {
            children: ".superinterface-textarea { min-height: inherit; height: 30px; }\n.superinterface-textarea::placeholder { color: var(--gray-a10); }"
        });
        $[4] = t1;
    } else {
        t1 = $[4];
    }
    var t2 = "rt-reset superinterface-textarea ".concat((_className = className) !== null && _className !== void 0 ? _className : "");
    var t3;
    if ($[5] !== style) {
        var _style;
        t3 = (_style = style) !== null && _style !== void 0 ? _style : {};
        $[5] = style;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    var t4;
    if ($[7] !== t3) {
        t4 = _objectSpread29({
            border: 0,
            outline: 0,
            boxSizing: "border-box",
            resize: "none",
            color: "var(--gray-12)",
            flexGrow: 1,
            display: "flex"
        }, t3);
        $[7] = t3;
        $[8] = t4;
    } else {
        t4 = $[8];
    }
    var t5;
    if ($[9] !== ref || $[10] !== rest || $[11] !== t2 || $[12] !== t4) {
        t5 = /* @__PURE__ */ _jsxs22(_Fragment4, {
            children: [
                t1,
                /* @__PURE__ */ _jsx66(TextareaAutosize, _objectSpread29({
                    ref: ref,
                    className: t2,
                    style: t4
                }, rest))
            ]
        });
        $[9] = ref;
        $[10] = rest;
        $[11] = t2;
        $[12] = t4;
        $[13] = t5;
    } else {
        t5 = $[13];
    }
    return t5;
});
// src/components/threads/Thread/MessageForm/Field/Control.tsx
import { jsx as _jsx67 } from "react/jsx-runtime";
function ownKeys30(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread30(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys30(Object(t), true).forEach(function(r2) {
            _defineProperty30(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys30(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty30(e, r, t) {
    return (r = _toPropertyKey30(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey30(t) {
    var i = _toPrimitive30(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive30(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Root5 = function(_ref) {
    var children = _ref.children, style = _ref.style, className = _ref.className;
    return /* @__PURE__ */ _jsx67(Flex20, {
        flexGrow: "1",
        pt: "4px",
        style: style,
        className: className,
        children: children
    });
};
var Input = function(props) {
    "use no memo";
    var _props$placeholder;
    var assistantNameContext = useContext11(AssistantNameContext);
    var register = useFormContext().register;
    var _useMessageFormContext = useMessageFormContext(), isDisabled = _useMessageFormContext.isDisabled, isLoading = _useMessageFormContext.isLoading;
    var isSubmitDisabled = useMemo13(function() {
        return isDisabled || isLoading;
    }, [
        isDisabled,
        isLoading
    ]);
    var isDisabledPrevious = usePrevious(isDisabled);
    var textareaRef = useRef5(null);
    var textareaProps = register("content");
    useEffect6(function() {
        if (isDisabled) return;
        if (!isDisabledPrevious) return;
        if (!textareaRef.current) return;
        textareaRef.current.focus();
    }, [
        isDisabled,
        isDisabledPrevious,
        textareaProps
    ]);
    return /* @__PURE__ */ _jsx67(TextareaBase, _objectSpread30(_objectSpread30(_objectSpread30({
        minRows: 1,
        placeholder: (_props$placeholder = props.placeholder) !== null && _props$placeholder !== void 0 ? _props$placeholder : "Message ".concat(assistantNameContext, "..."),
        disabled: isDisabled,
        onKeyDown: function(e) {
            if (e.key === "Enter" && !e.shiftKey) {
                var _e$currentTarget$form;
                e.preventDefault();
                if (isSubmitDisabled) return;
                (_e$currentTarget$form = e.currentTarget.form) === null || _e$currentTarget$form === void 0 || _e$currentTarget$form.requestSubmit();
            }
        }
    }, textareaProps), props), {}, {
        ref: function(e_0) {
            textareaProps.ref(e_0);
            textareaRef.current = e_0;
        }
    }));
};
var Control = function(props) {
    return /* @__PURE__ */ _jsx67(Root5, _objectSpread30(_objectSpread30({}, props), {}, {
        children: /* @__PURE__ */ _jsx67(Input, {})
    }));
};
Control.Root = Root5;
Control.Input = Input;
// src/components/threads/Thread/MessageForm/Field/Files/Preview.tsx
import { c as _c39 } from "react-compiler-runtime";
import { Flex as Flex21, Card as Card2, Spinner as Spinner2, Text as Text7, IconButton as IconButton6 } from "@radix-ui/themes";
import { FileIcon as FileIcon2, Cross2Icon } from "@radix-ui/react-icons";
import { jsx as _jsx68, jsxs as _jsxs23 } from "react/jsx-runtime";
function ownKeys31(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread31(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys31(Object(t), true).forEach(function(r2) {
            _defineProperty31(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys31(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty31(e, r, t) {
    return (r = _toPropertyKey31(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey31(t) {
    var i = _toPrimitive31(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive31(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Preview = function(props) {
    var $ = _c39(8);
    var _useMessageFormContext = useMessageFormContext(), files = _useMessageFormContext.files, setFiles = _useMessageFormContext.setFiles;
    if (!files.length) {
        return null;
    }
    var t0;
    if ($[0] !== files || $[1] !== setFiles) {
        var _t;
        if ($[3] !== setFiles) {
            _t = function(file) {
                return /* @__PURE__ */ _jsx68(Card2, {
                    variant: "ghost",
                    children: /* @__PURE__ */ _jsxs23(Flex21, {
                        align: "center",
                        justify: "between",
                        gap: "1",
                        children: [
                            /* @__PURE__ */ _jsxs23(Flex21, {
                                align: "center",
                                gap: "1",
                                flexShrink: "1",
                                minWidth: "0",
                                maxWidth: "250px",
                                children: [
                                    /* @__PURE__ */ _jsx68(Flex21, {
                                        flexShrink: "0",
                                        children: /* @__PURE__ */ _jsx68(Spinner2, {
                                            loading: isOptimistic({
                                                id: file.id
                                            }),
                                            children: /* @__PURE__ */ _jsx68(FileIcon2, {})
                                        })
                                    }),
                                    /* @__PURE__ */ _jsx68(Text7, {
                                        size: "2",
                                        truncate: true,
                                        wrap: "nowrap",
                                        children: file.filename
                                    })
                                ]
                            }),
                            /* @__PURE__ */ _jsx68(Flex21, {
                                flexShrink: "0",
                                children: /* @__PURE__ */ _jsx68(IconButton6, {
                                    onClick: function() {
                                        return setFiles(function(prev) {
                                            return prev.filter(function(prevFile) {
                                                return prevFile.id !== file.id;
                                            });
                                        });
                                    },
                                    color: "gray",
                                    variant: "ghost",
                                    size: "1",
                                    children: /* @__PURE__ */ _jsx68(Cross2Icon, {})
                                })
                            })
                        ]
                    })
                }, file.id);
            };
            $[3] = setFiles;
            $[4] = _t;
        } else {
            _t = $[4];
        }
        t0 = files.map(_t);
        $[0] = files;
        $[1] = setFiles;
        $[2] = t0;
    } else {
        t0 = $[2];
    }
    var t1;
    if ($[5] !== props || $[6] !== t0) {
        t1 = /* @__PURE__ */ _jsx68(Flex21, _objectSpread31(_objectSpread31({
            flexBasis: "100%",
            direction: "column",
            pb: "2",
            gap: "1"
        }, props), {}, {
            children: t0
        }));
        $[5] = props;
        $[6] = t0;
        $[7] = t1;
    } else {
        t1 = $[7];
    }
    return t1;
};
// src/components/threads/Thread/MessageForm/Field/Files/Control.tsx
import { useCallback as useCallback3 } from "react";
import { omit as omit4 } from "radash";
import dayjs2 from "dayjs";
import { FilePlusIcon } from "@radix-ui/react-icons";
import { IconButton as IconButton7, Flex as Flex22 } from "@radix-ui/themes";
// src/hooks/files/useCreateFile/index.ts
import { c as _c40 } from "react-compiler-runtime";
import { useMutation as useMutation2, useQueryClient as useQueryClient5 } from "@tanstack/react-query";
// src/hooks/files/useCreateFile/lib/mutationOptions/mutationFn/body/formData.ts
var formData = function(variables) {
    var data2 = new FormData();
    for(var key2 in variables){
        data2.append(key2, variables[key2]);
    }
    return data2;
};
// src/hooks/files/useCreateFile/lib/mutationOptions/mutationFn/body/index.ts
function ownKeys32(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread32(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys32(Object(t), true).forEach(function(r2) {
            _defineProperty32(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys32(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty32(e, r, t) {
    return (r = _toPropertyKey32(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey32(t) {
    var i = _toPrimitive32(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive32(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var body2 = function(_ref) {
    var _superinterfaceContex;
    var variables = _ref.variables, superinterfaceContext = _ref.superinterfaceContext;
    if (variables.threadId) return formData(variables);
    if (!variables.assistantId) return formData(variables);
    if (!((_superinterfaceContex = superinterfaceContext.threadIdStorageOptions) !== null && _superinterfaceContex !== void 0 && _superinterfaceContex.get)) return formData(variables);
    var threadId = superinterfaceContext.threadIdStorageOptions.get({
        assistantId: variables.assistantId
    });
    if (!threadId) return formData(variables);
    return formData(_objectSpread32(_objectSpread32({}, variables), {}, {
        threadId: threadId
    }));
};
// src/hooks/files/useCreateFile/lib/mutationOptions/mutationFn/index.ts
function asyncGeneratorStep7(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator7(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep7(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep7(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var mutationFn2 = function(_ref) {
    var superinterfaceContext = _ref.superinterfaceContext, queryClient = _ref.queryClient, threadContext = _ref.threadContext;
    return /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator7(function(variables) {
            var response, result;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            fetch("".concat(superinterfaceContext.baseUrl, "/files"), {
                                method: "POST",
                                body: body2({
                                    variables: variables,
                                    superinterfaceContext: superinterfaceContext
                                })
                            })
                        ];
                    case 1:
                        response = _state.sent();
                        return [
                            4,
                            response.json()
                        ];
                    case 2:
                        result = _state.sent();
                        return [
                            2,
                            result
                        ];
                }
            });
        });
        return function(_x) {
            return _ref2.apply(this, arguments);
        };
    }();
};
// src/hooks/files/useCreateFile/lib/mutationOptions/index.ts
function ownKeys33(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread33(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys33(Object(t), true).forEach(function(r2) {
            _defineProperty33(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys33(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty33(e, r, t) {
    return (r = _toPropertyKey33(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey33(t) {
    var i = _toPrimitive33(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive33(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var mutationOptions2 = function(_ref) {
    var queryClient = _ref.queryClient, threadContext = _ref.threadContext, superinterfaceContext = _ref.superinterfaceContext, onError = _ref.onError;
    var mutationKey = [
        "createFile",
        threadContext.variables
    ];
    return _objectSpread33(_objectSpread33(_objectSpread33({
        mutationFn: mutationFn2({
            queryClient: queryClient,
            superinterfaceContext: superinterfaceContext,
            threadContext: threadContext
        }),
        onError: onError
    }, threadContext.defaultOptions.mutations), queryClient.getMutationDefaults(mutationKey)), {}, {
        mutationKey: mutationKey
    });
};
// src/hooks/files/useCreateFile/index.ts
function ownKeys34(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread34(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys34(Object(t), true).forEach(function(r2) {
            _defineProperty34(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys34(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty34(e, r, t) {
    return (r = _toPropertyKey34(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey34(t) {
    var i = _toPrimitive34(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive34(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var useCreateFile = function(t0) {
    var $ = _c40(15);
    var t1;
    if ($[0] !== t0) {
        t1 = t0 === void 0 ? {
            onError: _temp5
        } : t0;
        $[0] = t0;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2 = t1.onError;
    var t3;
    if ($[2] !== t2) {
        t3 = t2 === void 0 ? _temp22 : t2;
        $[2] = t2;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    var onError = t3;
    var queryClient = useQueryClient5();
    var superinterfaceContext = useSuperinterfaceContext();
    var threadContext = useSuperinterfaceContext();
    var t4;
    if ($[4] !== onError || $[5] !== queryClient || $[6] !== superinterfaceContext || $[7] !== threadContext) {
        t4 = mutationOptions2({
            queryClient: queryClient,
            threadContext: threadContext,
            superinterfaceContext: superinterfaceContext,
            onError: onError
        });
        $[4] = onError;
        $[5] = queryClient;
        $[6] = superinterfaceContext;
        $[7] = threadContext;
        $[8] = t4;
    } else {
        t4 = $[8];
    }
    var props = useMutation2(t4);
    var t5;
    if ($[9] !== props || $[10] !== threadContext.variables) {
        t5 = function t52() {
            var _props;
            for(var _len = arguments.length, t62 = new Array(_len), _key = 0; _key < _len; _key++){
                t62[_key] = arguments[_key];
            }
            var args = t62;
            var _args = _to_array(args), firstArg = _args[0], restArgs = _args.slice(1);
            return (_props = props).mutateAsync.apply(_props, [
                _objectSpread34(_objectSpread34({}, threadContext.variables), firstArg)
            ].concat(_to_consumable_array(restArgs)));
        };
        $[9] = props;
        $[10] = threadContext.variables;
        $[11] = t5;
    } else {
        t5 = $[11];
    }
    var t6;
    if ($[12] !== props || $[13] !== t5) {
        t6 = _objectSpread34(_objectSpread34({}, props), {}, {
            createFile: t5
        });
        $[12] = props;
        $[13] = t5;
        $[14] = t6;
    } else {
        t6 = $[14];
    }
    return t6;
};
function _temp5() {}
function _temp22() {}
// src/components/threads/Thread/MessageForm/Field/Files/Control.tsx
import { jsx as _jsx69, jsxs as _jsxs24 } from "react/jsx-runtime";
function ownKeys35(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread35(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys35(Object(t), true).forEach(function(r2) {
            _defineProperty35(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys35(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty35(e, r, t) {
    return (r = _toPropertyKey35(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey35(t) {
    var i = _toPrimitive35(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive35(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function asyncGeneratorStep8(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator8(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep8(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep8(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
function _asyncIterator(r) {
    var n, t, o, e = 2;
    for("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;){
        if (t && null != (n = r[t])) return n.call(r);
        if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));
        t = "@@asyncIterator", o = "@@iterator";
    }
    throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(r) {
    function AsyncFromSyncIteratorContinuation(r2) {
        if (Object(r2) !== r2) return Promise.reject(new TypeError(r2 + " is not an object."));
        var n = r2.done;
        return Promise.resolve(r2.value).then(function(r3) {
            return {
                value: r3,
                done: n
            };
        });
    }
    return AsyncFromSyncIterator = function AsyncFromSyncIterator2(r2) {
        this.s = r2, this.n = r2.next;
    }, AsyncFromSyncIterator.prototype = {
        s: null,
        n: null,
        next: function next() {
            return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
        },
        return: function _return(r2) {
            var n = this.s.return;
            return void 0 === n ? Promise.resolve({
                value: r2,
                done: true
            }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
        },
        throw: function _throw(r2) {
            var n = this.s.return;
            return void 0 === n ? Promise.reject(r2) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
        }
    }, new AsyncFromSyncIterator(r);
}
var accept = ".c,text/x-c,\n.cs,text/x-csharp,\n.cpp,text/x-c++,\n.doc,application/msword,\n.docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document,\n.html,text/html,\n.java,text/x-java,\n.json,application/json,\n.md,text/markdown,\n.pdf,application/pdf,\n.php,text/x-php,\n.pptx,application/vnd.openxmlformats-officedocument.presentationml.presentation,\n.py,text/x-python,\n.py,text/x-script.python,\n.rb,text/x-ruby,\n.tex,text/x-tex,\n.txt,text/plain,\n.css,text/css,\n.js,text/javascript,\n.sh,application/x-sh,\n.ts,application/typescript";
var Control2 = function(props) {
    var _useMessageFormContext = useMessageFormContext(), isDisabled = _useMessageFormContext.isDisabled, isLoading = _useMessageFormContext.isLoading, setFiles = _useMessageFormContext.setFiles;
    var createFile = useCreateFile().createFile;
    var addToast = useToasts().addToast;
    var onChange = useCallback3(/* @__PURE__ */ function() {
        var _ref = _asyncToGenerator8(function(event) {
            var fileObjects, newFiles, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, err;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fileObjects = event.target.files;
                        if (!fileObjects) return [
                            2
                        ];
                        newFiles = Array.from(fileObjects).map(function(fileObject) {
                            return {
                                id: optimisticId(),
                                filename: fileObject.name,
                                object: "file",
                                purpose: "assistants",
                                created_at: dayjs2().unix(),
                                bytes: fileObject.size,
                                status: "processed",
                                fileObject: fileObject
                            };
                        });
                        setFiles(function(prev) {
                            return _to_consumable_array(prev).concat(_to_consumable_array(newFiles.map(function(file) {
                                return omit4(file, [
                                    "fileObject"
                                ]);
                            })));
                        });
                        _iteratorAbruptCompletion = false;
                        _didIteratorError = false;
                        _state.label = 1;
                    case 1:
                        _state.trys.push([
                            1,
                            7,
                            8,
                            13
                        ]);
                        _loop = function _loop2() {
                            var newFile;
                            return _ts_generator(this, function(_state) {
                                switch(_state.label){
                                    case 0:
                                        newFile = _step.value;
                                        return [
                                            4,
                                            createFile({
                                                file: newFile.fileObject
                                            }, {
                                                onSuccess: function(_ref2) {
                                                    var file = _ref2.file;
                                                    return setFiles(function(prev) {
                                                        return _to_consumable_array(prev.filter(function(prevFile) {
                                                            return prevFile.id !== newFile.id;
                                                        })).concat([
                                                            file
                                                        ]);
                                                    });
                                                },
                                                onError: function() {
                                                    addToast({
                                                        type: "error",
                                                        message: "Could not upload file. Please try again."
                                                    });
                                                    setFiles(function(prev) {
                                                        return prev.filter(function(prevFile) {
                                                            return prevFile.id !== newFile.id;
                                                        });
                                                    });
                                                }
                                            })
                                        ];
                                    case 1:
                                        _state.sent();
                                        return [
                                            2
                                        ];
                                }
                            });
                        };
                        _iterator = _asyncIterator(newFiles);
                        _state.label = 2;
                    case 2:
                        return [
                            4,
                            _iterator.next()
                        ];
                    case 3:
                        if (!(_iteratorAbruptCompletion = !(_step = _state.sent()).done)) return [
                            3,
                            6
                        ];
                        return [
                            5,
                            _ts_values(_loop())
                        ];
                    case 4:
                        _state.sent();
                        _state.label = 5;
                    case 5:
                        _iteratorAbruptCompletion = false;
                        return [
                            3,
                            2
                        ];
                    case 6:
                        return [
                            3,
                            13
                        ];
                    case 7:
                        err = _state.sent();
                        _didIteratorError = true;
                        _iteratorError = err;
                        return [
                            3,
                            13
                        ];
                    case 8:
                        _state.trys.push([
                            8,
                            ,
                            11,
                            12
                        ]);
                        if (!(_iteratorAbruptCompletion && _iterator.return != null)) return [
                            3,
                            10
                        ];
                        return [
                            4,
                            _iterator.return()
                        ];
                    case 9:
                        _state.sent();
                        _state.label = 10;
                    case 10:
                        return [
                            3,
                            12
                        ];
                    case 11:
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                        return [
                            7
                        ];
                    case 12:
                        return [
                            7
                        ];
                    case 13:
                        return [
                            2
                        ];
                }
            });
        });
        return function(_x) {
            return _ref.apply(this, arguments);
        };
    }(), [
        addToast,
        createFile,
        setFiles
    ]);
    return /* @__PURE__ */ _jsx69(Flex22, _objectSpread35(_objectSpread35({
        pt: "2",
        pr: "2",
        flexGrow: "0"
    }, props), {}, {
        children: /* @__PURE__ */ _jsxs24(IconButton7, {
            type: "button",
            variant: "ghost",
            color: "gray",
            disabled: isDisabled || isLoading,
            style: {
                position: "relative",
                overflow: "hidden"
            },
            children: [
                /* @__PURE__ */ _jsx69(FilePlusIcon, {}),
                /* @__PURE__ */ _jsx69("input", {
                    type: "file",
                    multiple: true,
                    accept: accept,
                    onChange: onChange,
                    style: {
                        cursor: "pointer",
                        position: "absolute",
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        opacity: 0
                    }
                })
            ]
        })
    }));
};
// src/components/threads/Thread/MessageForm/Field/Files/index.tsx
var Files = {
    Preview: Preview,
    Control: Control2
};
// src/components/threads/Thread/MessageForm/Field/index.tsx
import { jsx as _jsx70 } from "react/jsx-runtime";
function ownKeys36(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread36(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys36(Object(t), true).forEach(function(r2) {
            _defineProperty36(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys36(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty36(e, r, t) {
    return (r = _toPropertyKey36(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey36(t) {
    var i = _toPrimitive36(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive36(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Root6 = function(_ref) {
    "use no memo";
    var children = _ref.children, className = _ref.className, style = _ref.style;
    var _useFormContext2 = useFormContext2(), errors = _useFormContext2.formState.errors;
    return /* @__PURE__ */ _jsx70(RadixContainer, {
        size: "2",
        flexGrow: "0",
        className: className,
        style: style,
        children: /* @__PURE__ */ _jsx70(Flex23, {
            direction: "column",
            flexShrink: "0",
            children: /* @__PURE__ */ _jsx70(Flex23, {
                direction: "column",
                flexShrink: "0",
                children: /* @__PURE__ */ _jsx70(Flex23, {
                    style: _objectSpread36({
                        borderRadius: "var(--radius-2)",
                        borderWidth: "1px",
                        borderStyle: "solid",
                        borderColor: errors.content ? "var(--red-9)" : "var(--gray-5)"
                    }, errors.content ? {
                        backgroundColor: "var(--red-2)"
                    } : {}),
                    p: "2",
                    pl: "3",
                    wrap: "wrap",
                    children: children
                })
            })
        })
    });
};
var Field = {
    Root: Root6,
    Control: Control,
    Files: Files
};
// src/components/threads/Thread/MessageForm/index.tsx
import { jsx as _jsx71, jsxs as _jsxs25 } from "react/jsx-runtime";
function ownKeys37(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread37(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys37(Object(t), true).forEach(function(r2) {
            _defineProperty37(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys37(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty37(e, r, t) {
    return (r = _toPropertyKey37(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey37(t) {
    var i = _toPrimitive37(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive37(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var MessageForm = function(props) {
    return /* @__PURE__ */ _jsx71(Root4, _objectSpread37(_objectSpread37({}, props), {}, {
        children: /* @__PURE__ */ _jsxs25(Field.Root, {
            children: [
                /* @__PURE__ */ _jsx71(Field.Control, {}),
                /* @__PURE__ */ _jsx71(Submit, {})
            ]
        })
    }));
};
MessageForm.Root = Root4;
MessageForm.Field = Field;
MessageForm.Submit = Submit;
// src/components/threads/Thread/Root/index.tsx
import { Flex as Flex25 } from "@radix-ui/themes";
// src/components/threads/Thread/Provider/index.tsx
var Provider2 = SuperinterfaceProvider;
// src/components/toasts/ToastsProvider/index.tsx
import { c as _c41 } from "react-compiler-runtime";
import { useState as useState4, useCallback as useCallback4 } from "react";
import * as Toast2 from "@radix-ui/react-toast";
// src/components/toasts/ToastsProvider/CustomToast.tsx
import * as Toast from "@radix-ui/react-toast";
import { Card as Card3, Text as Text8, Flex as Flex24 } from "@radix-ui/themes";
import { CheckCircledIcon as CheckCircledIcon2, CrossCircledIcon } from "@radix-ui/react-icons";
import { jsx as _jsx72, jsxs as _jsxs26 } from "react/jsx-runtime";
var CustomToast = function(_ref) {
    var toast = _ref.toast;
    return /* @__PURE__ */ _jsx72(Toast.Root, {
        children: /* @__PURE__ */ _jsx72(Card3, {
            children: /* @__PURE__ */ _jsx72(Toast.Title, {
                children: /* @__PURE__ */ _jsxs26(Flex24, {
                    children: [
                        /* @__PURE__ */ _jsx72(Flex24, {
                            pr: "2",
                            height: "14px",
                            align: "center",
                            children: toast.type === "success" ? /* @__PURE__ */ _jsx72(CheckCircledIcon2, {
                                color: "var(--accent-9)"
                            }) : /* @__PURE__ */ _jsx72(CrossCircledIcon, {
                                color: "var(--red-9)"
                            })
                        }),
                        /* @__PURE__ */ _jsx72(Text8, {
                            weight: "medium",
                            size: "1",
                            children: toast.message
                        })
                    ]
                })
            })
        })
    });
};
// src/components/toasts/ToastsProvider/index.tsx
import { jsx as _jsx73, jsxs as _jsxs27 } from "react/jsx-runtime";
var ToastsProvider = function(t0) {
    var $ = _c41(15);
    var children = t0.children, t1 = t0.bottom;
    var bottom = t1 === void 0 ? 0 : t1;
    var t2;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = [];
        $[0] = t2;
    } else {
        t2 = $[0];
    }
    var _useState4 = _sliced_to_array(useState4(t2), 2), toasts = _useState4[0], setToasts = _useState4[1];
    var t3;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = function(toast) {
            return setToasts(function(prevToasts) {
                return _to_consumable_array(prevToasts).concat([
                    toast
                ]);
            });
        };
        $[1] = t3;
    } else {
        t3 = $[1];
    }
    var addToast = t3;
    var t4;
    if ($[2] !== toasts) {
        t4 = {
            toasts: toasts,
            addToast: addToast
        };
        $[2] = toasts;
        $[3] = t4;
    } else {
        t4 = $[3];
    }
    var t5;
    if ($[4] !== toasts) {
        t5 = Array.from(toasts).map(_temp6);
        $[4] = toasts;
        $[5] = t5;
    } else {
        t5 = $[5];
    }
    var t6;
    if ($[6] !== bottom) {
        t6 = /* @__PURE__ */ _jsx73(Toast2.Viewport, {
            style: {
                position: "absolute",
                bottom: bottom,
                right: 0,
                display: "flex",
                flexDirection: "column",
                padding: "var(--space-5)",
                gap: "var(--space-3)",
                width: "390px",
                maxWidth: "100vw",
                margin: 0,
                listStyle: "none",
                zIndex: 99999999999999,
                outline: "none"
            }
        });
        $[6] = bottom;
        $[7] = t6;
    } else {
        t6 = $[7];
    }
    var t7;
    if ($[8] !== children || $[9] !== t5 || $[10] !== t6) {
        t7 = /* @__PURE__ */ _jsxs27(Toast2.Provider, {
            children: [
                children,
                t5,
                t6
            ]
        });
        $[8] = children;
        $[9] = t5;
        $[10] = t6;
        $[11] = t7;
    } else {
        t7 = $[11];
    }
    var t8;
    if ($[12] !== t4 || $[13] !== t7) {
        t8 = /* @__PURE__ */ _jsx73(ToastsContext.Provider, {
            value: t4,
            children: t7
        });
        $[12] = t4;
        $[13] = t7;
        $[14] = t8;
    } else {
        t8 = $[14];
    }
    return t8;
};
function _temp6(toast_0, index) {
    return /* @__PURE__ */ _jsx73(CustomToast, {
        toast: toast_0
    }, index);
}
// src/components/threads/Thread/Root/index.tsx
import { jsx as _jsx74 } from "react/jsx-runtime";
var _excluded4 = [
    "children",
    "style",
    "className"
];
function ownKeys38(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread38(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys38(Object(t), true).forEach(function(r2) {
            _defineProperty38(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys38(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty38(e, r, t) {
    return (r = _toPropertyKey38(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey38(t) {
    var i = _toPrimitive38(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive38(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties4(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose4(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose4(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
var Root8 = function(_ref) {
    var children = _ref.children, style = _ref.style, className = _ref.className, rest = _objectWithoutProperties4(_ref, _excluded4);
    return /* @__PURE__ */ _jsx74(ToastsProvider, {
        bottom: "var(--space-9)",
        children: /* @__PURE__ */ _jsx74(Provider2, _objectSpread38(_objectSpread38({}, rest), {}, {
            children: /* @__PURE__ */ _jsx74(Flex25, {
                direction: "column",
                flexGrow: "1",
                className: className,
                style: style,
                children: children
            })
        }))
    });
};
// src/components/threads/Thread/index.tsx
import { jsx as _jsx75, jsxs as _jsxs28 } from "react/jsx-runtime";
function ownKeys39(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread39(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys39(Object(t), true).forEach(function(r2) {
            _defineProperty39(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys39(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty39(e, r, t) {
    return (r = _toPropertyKey39(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey39(t) {
    var i = _toPrimitive39(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive39(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Thread = function(props) {
    return /* @__PURE__ */ _jsxs28(Root8, _objectSpread39(_objectSpread39({}, props), {}, {
        children: [
            /* @__PURE__ */ _jsx75(Messages, {}),
            /* @__PURE__ */ _jsx75(MessageForm, {})
        ]
    }));
};
Thread.Root = Root8;
Thread.Messages = Messages;
Thread.MessageForm = MessageForm;
// src/hooks/messages/useMessageContext/index.ts
import { useContext as useContext12 } from "react";
var useMessageContext = function() {
    return useContext12(MessageContext);
};
// src/hooks/assistants/useAssistant/index.ts
import { c as _c42 } from "react-compiler-runtime";
import { useMemo as useMemo14 } from "react";
import { useQuery } from "@tanstack/react-query";
// src/hooks/assistants/useAssistant/lib/queryOptions/index.ts
import { queryOptions as tanstackQueryOptions } from "@tanstack/react-query";
// src/hooks/assistants/useAssistant/lib/queryOptions/queryFn.ts
function asyncGeneratorStep9(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator9(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep9(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep9(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var queryFn = function(_ref) {
    var superinterfaceContext = _ref.superinterfaceContext;
    return /* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator9(function(_ref2) {
            var queryKey, _queryKey, _key, assistantId, params;
            return _ts_generator(this, function(_state) {
                queryKey = _ref2.queryKey;
                _queryKey = _sliced_to_array(queryKey, 2), _key = _queryKey[0], assistantId = _queryKey[1].assistantId;
                params = new URLSearchParams({
                    publicApiKey: superinterfaceContext.variables.publicApiKey
                });
                return [
                    2,
                    fetch("".concat(superinterfaceContext.baseUrl, "/assistants/").concat(assistantId, "?").concat(params)).then(/* @__PURE__ */ function() {
                        var _ref4 = _asyncToGenerator9(function(response) {
                            var errorResponse, error;
                            return _ts_generator(this, function(_state) {
                                switch(_state.label){
                                    case 0:
                                        if (!(response.status !== 200)) return [
                                            3,
                                            4
                                        ];
                                        _state.label = 1;
                                    case 1:
                                        _state.trys.push([
                                            1,
                                            3,
                                            ,
                                            4
                                        ]);
                                        return [
                                            4,
                                            response.json()
                                        ];
                                    case 2:
                                        errorResponse = _state.sent();
                                        throw new Error(errorResponse.error);
                                    case 3:
                                        error = _state.sent();
                                        throw new Error("Failed to fetch");
                                    case 4:
                                        return [
                                            2,
                                            response.json()
                                        ];
                                }
                            });
                        });
                        return function(_x2) {
                            return _ref4.apply(this, arguments);
                        };
                    }())
                ];
            });
        });
        return function(_x) {
            return _ref3.apply(this, arguments);
        };
    }();
};
// src/hooks/assistants/useAssistant/lib/queryOptions/index.ts
var queryOptions2 = function(_ref) {
    var assistantId = _ref.assistantId, superinterfaceContext = _ref.superinterfaceContext;
    return tanstackQueryOptions({
        queryKey: [
            "assistants",
            {
                assistantId: assistantId
            }
        ],
        queryFn: queryFn({
            superinterfaceContext: superinterfaceContext
        })
    });
};
// src/hooks/assistants/useAssistant/index.ts
function ownKeys40(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread40(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys40(Object(t), true).forEach(function(r2) {
            _defineProperty40(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys40(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty40(e, r, t) {
    return (r = _toPropertyKey40(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey40(t) {
    var i = _toPrimitive40(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive40(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var useAssistant = function(t0) {
    var $ = _c42(6);
    var assistantId = t0.assistantId;
    var superinterfaceContext = useSuperinterfaceContext();
    var t1;
    if ($[0] !== assistantId || $[1] !== superinterfaceContext) {
        t1 = queryOptions2({
            assistantId: assistantId,
            superinterfaceContext: superinterfaceContext
        });
        $[0] = assistantId;
        $[1] = superinterfaceContext;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    var props = useQuery(t1);
    var t2;
    var t3 = props.data ? props.data.assistant : null;
    var t4;
    if ($[3] !== props || $[4] !== t3) {
        t4 = _objectSpread40(_objectSpread40({}, props), {}, {
            assistant: t3
        });
        $[3] = props;
        $[4] = t3;
        $[5] = t4;
    } else {
        t4 = $[5];
    }
    t2 = t4;
    return t2;
};
// src/components/threads/ThreadDialog/Provider/index.tsx
import { c as _c43 } from "react-compiler-runtime";
import { useState as useState5 } from "react";
// src/contexts/threads/ThreadDialogContext/index.ts
import { createContext as createContext11 } from "react";
var ThreadDialogContext = /* @__PURE__ */ createContext11({
    isOpen: false,
    setIsOpen: function() {}
});
// src/hooks/threads/useThreadDialogContext/index.ts
import { useContext as useContext13 } from "react";
var useThreadDialogContext = function() {
    return useContext13(ThreadDialogContext);
};
// src/components/threads/ThreadDialog/Provider/index.tsx
import { jsx as _jsx76 } from "react/jsx-runtime";
var Provider4 = function(t0) {
    var $ = _c43(5);
    var children = t0.children;
    var threadDialogContext = useThreadDialogContext();
    var _useState5 = _sliced_to_array(useState5(threadDialogContext.isOpen), 2), isOpen = _useState5[0], setIsOpen = _useState5[1];
    var t1;
    if ($[0] !== isOpen) {
        t1 = {
            isOpen: isOpen,
            setIsOpen: setIsOpen
        };
        $[0] = isOpen;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2;
    if ($[2] !== children || $[3] !== t1) {
        t2 = /* @__PURE__ */ _jsx76(ThreadDialogContext.Provider, {
            value: t1,
            children: children
        });
        $[2] = children;
        $[3] = t1;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    return t2;
};
// src/components/threads/ThreadDialog/Root/index.tsx
import { jsx as _jsx77 } from "react/jsx-runtime";
var Root9 = function(_ref) {
    var children = _ref.children;
    return /* @__PURE__ */ _jsx77(Provider4, {
        children: children
    });
};
// src/components/threads/ThreadDialog/Trigger/index.tsx
import { c as _c44 } from "react-compiler-runtime";
import { Flex as Flex26 } from "@radix-ui/themes";
// src/components/threads/ThreadDialog/Trigger/Button.tsx
import { IconButton as IconButton8 } from "@radix-ui/themes";
import { ChatBubbleIcon } from "@radix-ui/react-icons";
import { jsx as _jsx78 } from "react/jsx-runtime";
function ownKeys41(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread41(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys41(Object(t), true).forEach(function(r2) {
            _defineProperty41(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys41(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty41(e, r, t) {
    return (r = _toPropertyKey41(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey41(t) {
    var i = _toPrimitive41(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive41(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Button4 = function(props) {
    return /* @__PURE__ */ _jsx78(IconButton8, _objectSpread41(_objectSpread41({
        size: "4",
        radius: "full"
    }, props), {}, {
        children: /* @__PURE__ */ _jsx78(ChatBubbleIcon, {})
    }));
};
// src/components/threads/ThreadDialog/Trigger/index.tsx
import { jsx as _jsx79 } from "react/jsx-runtime";
function ownKeys42(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread42(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys42(Object(t), true).forEach(function(r2) {
            _defineProperty42(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys42(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty42(e, r, t) {
    return (r = _toPropertyKey42(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey42(t) {
    var i = _toPrimitive42(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive42(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Root10 = function(t0) {
    var $ = _c44(14);
    var children = t0.children, style = t0.style, className = t0.className;
    var _useThreadDialogContext = useThreadDialogContext(), setIsOpen = _useThreadDialogContext.setIsOpen, isOpen = _useThreadDialogContext.isOpen;
    var t1 = isOpen ? "none" : "flex";
    var t2;
    if ($[0] !== t1) {
        t2 = {
            initial: t1,
            sm: "flex"
        };
        $[0] = t1;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    var t3;
    if ($[2] !== setIsOpen) {
        t3 = function() {
            return setIsOpen(_temp7);
        };
        $[2] = setIsOpen;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    var t4;
    if ($[4] !== style) {
        t4 = style !== null && style !== void 0 ? style : {};
        $[4] = style;
        $[5] = t4;
    } else {
        t4 = $[5];
    }
    var t5;
    if ($[6] !== t4) {
        t5 = _objectSpread42({
            zIndex: 9999999999
        }, t4);
        $[6] = t4;
        $[7] = t5;
    } else {
        t5 = $[7];
    }
    var t6;
    if ($[8] !== children || $[9] !== className || $[10] !== t2 || $[11] !== t3 || $[12] !== t5) {
        t6 = /* @__PURE__ */ _jsx79(Flex26, {
            display: t2,
            onClick: t3,
            direction: "column",
            flexShrink: "0",
            justify: "end",
            align: "end",
            position: "fixed",
            bottom: "24px",
            right: "24px",
            className: className,
            style: t5,
            children: children
        });
        $[8] = children;
        $[9] = className;
        $[10] = t2;
        $[11] = t3;
        $[12] = t5;
        $[13] = t6;
    } else {
        t6 = $[13];
    }
    return t6;
};
var Trigger = function(args) {
    return /* @__PURE__ */ _jsx79(Root10, _objectSpread42(_objectSpread42({}, args), {}, {
        children: /* @__PURE__ */ _jsx79(Button4, {})
    }));
};
Trigger.Root = Root10;
Trigger.Button = Button4;
function _temp7(prev) {
    return !prev;
}
// src/components/threads/ThreadDialog/Content/index.tsx
import { c as _c46 } from "react-compiler-runtime";
import { Card as Card4, Inset as Inset2, Flex as Flex28 } from "@radix-ui/themes";
// src/components/threads/ThreadDialog/Close/index.tsx
import { c as _c45 } from "react-compiler-runtime";
import { Cross1Icon } from "@radix-ui/react-icons";
import { IconButton as IconButton9, Flex as Flex27 } from "@radix-ui/themes";
import { jsx as _jsx80 } from "react/jsx-runtime";
var Close = function() {
    var $ = _c45(9);
    var _useThreadDialogContext = useThreadDialogContext(), setIsOpen = _useThreadDialogContext.setIsOpen, isOpen = _useThreadDialogContext.isOpen;
    var t0 = isOpen ? "flex" : "none";
    var t1;
    if ($[0] !== t0) {
        t1 = {
            initial: t0,
            sm: "none"
        };
        $[0] = t0;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2;
    if ($[2] !== setIsOpen) {
        t2 = function() {
            return setIsOpen(_temp8);
        };
        $[2] = setIsOpen;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    var t3;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = {
            zIndex: 9999999999
        };
        $[4] = t3;
    } else {
        t3 = $[4];
    }
    var t4;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
        t4 = /* @__PURE__ */ _jsx80(IconButton9, {
            size: "2",
            variant: "soft",
            children: /* @__PURE__ */ _jsx80(Cross1Icon, {})
        });
        $[5] = t4;
    } else {
        t4 = $[5];
    }
    var t5;
    if ($[6] !== t1 || $[7] !== t2) {
        t5 = /* @__PURE__ */ _jsx80(Flex27, {
            display: t1,
            onClick: t2,
            direction: "column",
            flexShrink: "0",
            justify: "end",
            align: "end",
            position: "absolute",
            top: "24px",
            right: "24px",
            style: t3,
            children: t4
        });
        $[6] = t1;
        $[7] = t2;
        $[8] = t5;
    } else {
        t5 = $[8];
    }
    return t5;
};
function _temp8(prev) {
    return !prev;
}
// src/components/threads/ThreadDialog/Content/index.tsx
import { jsx as _jsx81, jsxs as _jsxs29 } from "react/jsx-runtime";
function ownKeys43(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread43(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys43(Object(t), true).forEach(function(r2) {
            _defineProperty43(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys43(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty43(e, r, t) {
    return (r = _toPropertyKey43(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey43(t) {
    var i = _toPrimitive43(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive43(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Root11 = function(t0) {
    var $ = _c46(19);
    var children = t0.children, className = t0.className, style = t0.style;
    var isOpen = useThreadDialogContext().isOpen;
    if (!isOpen) {
        return null;
    }
    var t1;
    var t2;
    var t3;
    var t4;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = {
            initial: "0",
            sm: "72px"
        };
        t2 = {
            initial: "0",
            sm: "24px"
        };
        t3 = {
            initial: void 0,
            sm: "720px"
        };
        t4 = {
            initial: void 0,
            sm: "400px"
        };
        $[0] = t1;
        $[1] = t2;
        $[2] = t3;
        $[3] = t4;
    } else {
        t1 = $[0];
        t2 = $[1];
        t3 = $[2];
        t4 = $[3];
    }
    var t5;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t5 = {
            initial: "100%",
            sm: "calc(100% - 96px)"
        };
        $[4] = t5;
    } else {
        t5 = $[4];
    }
    var t6;
    if ($[5] !== style) {
        t6 = _objectSpread43({
            zIndex: 9999999999
        }, style);
        $[5] = style;
        $[6] = t6;
    } else {
        t6 = $[6];
    }
    var t7;
    var t8;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
        t7 = {
            initial: void 0,
            sm: "3"
        };
        t8 = {
            position: "relative",
            display: "flex",
            flexGrow: 1
        };
        $[7] = t7;
        $[8] = t8;
    } else {
        t7 = $[7];
        t8 = $[8];
    }
    var t9;
    if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
        t9 = {
            display: "flex",
            flexGrow: 1
        };
        $[9] = t9;
    } else {
        t9 = $[9];
    }
    var t10;
    if ($[10] !== children) {
        t10 = /* @__PURE__ */ _jsx81(Inset2, {
            clip: "padding-box",
            side: "all",
            pb: "current",
            style: t9,
            children: children
        });
        $[10] = children;
        $[11] = t10;
    } else {
        t10 = $[11];
    }
    var t11;
    if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
        t11 = /* @__PURE__ */ _jsx81(Close, {});
        $[12] = t11;
    } else {
        t11 = $[12];
    }
    var t12;
    if ($[13] !== t10) {
        t12 = /* @__PURE__ */ _jsxs29(Card4, {
            mb: t7,
            style: t8,
            children: [
                t10,
                t11
            ]
        });
        $[13] = t10;
        $[14] = t12;
    } else {
        t12 = $[14];
    }
    var t13;
    if ($[15] !== className || $[16] !== t12 || $[17] !== t6) {
        t13 = /* @__PURE__ */ _jsx81(Flex28, {
            className: className,
            direction: "column",
            justify: "end",
            position: "fixed",
            bottom: t1,
            right: t2,
            maxHeight: t3,
            maxWidth: t4,
            width: "100%",
            height: t5,
            style: t6,
            children: t12
        });
        $[15] = className;
        $[16] = t12;
        $[17] = t6;
        $[18] = t13;
    } else {
        t13 = $[18];
    }
    return t13;
};
var Messages2 = function(_ref) {
    var className = _ref.className, style = _ref.style;
    return /* @__PURE__ */ _jsx81(Thread.Messages, {
        className: className,
        style: _objectSpread43({
            paddingTop: "var(--space-5)",
            paddingRight: "var(--space-5)",
            paddingLeft: "var(--space-5)"
        }, style)
    });
};
var FormContainer = function(_ref2) {
    var children = _ref2.children, className = _ref2.className, style = _ref2.style;
    return /* @__PURE__ */ _jsx81(Flex28, {
        direction: "column",
        pl: "5",
        pr: "5",
        pb: "3",
        flexShrink: "0",
        className: className,
        style: style,
        children: children
    });
};
var Content7 = function(props) {
    return /* @__PURE__ */ _jsx81(Root11, _objectSpread43(_objectSpread43({}, props), {}, {
        children: /* @__PURE__ */ _jsxs29(Thread.Root, {
            children: [
                /* @__PURE__ */ _jsx81(Messages2, {}),
                /* @__PURE__ */ _jsx81(FormContainer, {
                    children: /* @__PURE__ */ _jsx81(Thread.MessageForm, {})
                })
            ]
        })
    }));
};
Content7.Root = Root11;
Content7.Messages = Messages2;
Content7.FormContainer = FormContainer;
// src/components/threads/ThreadDialog/index.tsx
import { jsx as _jsx82, jsxs as _jsxs30 } from "react/jsx-runtime";
var ThreadDialog = function() {
    return /* @__PURE__ */ _jsxs30(Root9, {
        children: [
            /* @__PURE__ */ _jsx82(Content7, {}),
            /* @__PURE__ */ _jsx82(Trigger, {})
        ]
    });
};
ThreadDialog.Root = Root9;
ThreadDialog.Trigger = Trigger;
ThreadDialog.Content = Content7;
// src/components/threads/AudioThread/Root/index.tsx
import { c as _c52 } from "react-compiler-runtime";
import { Flex as Flex29 } from "@radix-ui/themes";
// src/contexts/threads/AudioThreadContext/index.ts
import { createContext as createContext12 } from "react";
var AudioThreadContext = /* @__PURE__ */ createContext12({
    audioRuntime: null
});
// src/hooks/threads/useAudioThreadContext/index.ts
import { useContext as useContext14 } from "react";
var useAudioThreadContext = function() {
    return useContext14(AudioThreadContext);
};
// src/components/audioRuntimes/TtsAudioRuntimeProvider.tsx
import { c as _c51 } from "react-compiler-runtime";
// src/hooks/audioRuntimes/useTtsAudioRuntime/index.ts
import { c as _c50 } from "react-compiler-runtime";
import { useMemo as useMemo17 } from "react";
// src/hooks/misc/usePermission/index.ts
import { c as _c47 } from "react-compiler-runtime";
import { useEffect as useEffect7, useState as useState6 } from "react";
// src/hooks/misc/usePermission/util.ts
var noop = function() {};
function on(obj) {
    if (obj && obj.addEventListener) {
        var _obj;
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        (_obj = obj).addEventListener.apply(_obj, _to_consumable_array(args));
    }
}
function off(obj) {
    if (obj && obj.removeEventListener) {
        var _obj;
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
            args[_key2 - 1] = arguments[_key2];
        }
        (_obj = obj).removeEventListener.apply(_obj, _to_consumable_array(args));
    }
}
// src/hooks/misc/usePermission/index.ts
var usePermission = function(permissionDesc) {
    var $ = _c47(3);
    var _useState6 = _sliced_to_array(useState6(""), 2), state = _useState6[0], setState = _useState6[1];
    var t0;
    var t1;
    if ($[0] !== permissionDesc) {
        t0 = function() {
            var mounted;
            mounted = true;
            var permissionStatus;
            permissionStatus = null;
            var onChange = function() {
                if (!mounted) {
                    return;
                }
                setState(function() {
                    var _permissionStatus$sta, _permissionStatus;
                    return (_permissionStatus$sta = (_permissionStatus = permissionStatus) === null || _permissionStatus === void 0 ? void 0 : _permissionStatus.state) !== null && _permissionStatus$sta !== void 0 ? _permissionStatus$sta : "";
                });
            };
            navigator.permissions.query(permissionDesc).then(function(status) {
                permissionStatus = status;
                on(permissionStatus, "change", onChange);
                onChange();
            }).catch(noop);
            return function() {
                permissionStatus && off(permissionStatus, "change", onChange);
                mounted = false;
                permissionStatus = null;
            };
        };
        t1 = [
            permissionDesc
        ];
        $[0] = permissionDesc;
        $[1] = t0;
        $[2] = t1;
    } else {
        t0 = $[1];
        t1 = $[2];
    }
    useEffect7(t0, t1);
    return state;
};
// src/hooks/audioThreads/useRecorder/index.ts
import dayjs3 from "dayjs";
import { useAudioCapture } from "use-audio-capture";
import { useMemo as useMemo15, useRef as useRef7, useState as useState7, useCallback as useCallback5, useEffect as useEffect9 } from "react";
import { useAudioPlayer } from "react-use-audio-player";
// src/hooks/misc/useInterval.ts
import { c as _c48 } from "react-compiler-runtime";
import { useEffect as useEffect8, useRef as useRef6 } from "react";
var useInterval = function(callback, delay) {
    var $ = _c48(5);
    var savedCallback = useRef6(_temp9);
    var t0;
    if ($[0] !== callback) {
        t0 = function() {
            savedCallback.current = callback;
        };
        $[0] = callback;
        $[1] = t0;
    } else {
        t0 = $[1];
    }
    useEffect8(t0);
    var t1;
    var t2;
    if ($[2] !== delay) {
        t1 = function() {
            if (delay !== null) {
                var interval = setInterval(function() {
                    return savedCallback.current();
                }, delay || 0);
                return function() {
                    return clearInterval(interval);
                };
            }
        };
        t2 = [
            delay
        ];
        $[2] = delay;
        $[3] = t1;
        $[4] = t2;
    } else {
        t1 = $[3];
        t2 = $[4];
    }
    useEffect8(t1, t2);
};
function _temp9() {}
// src/hooks/audioThreads/useRecorder/index.ts
function ownKeys44(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread44(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys44(Object(t), true).forEach(function(r2) {
            _defineProperty44(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys44(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty44(e, r, t) {
    return (r = _toPropertyKey44(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey44(t) {
    var i = _toPrimitive44(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive44(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function asyncGeneratorStep10(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator10(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep10(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep10(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var useRecorder = function(_ref) {
    var isStopOnSilence = _ref.isStopOnSilence, _onStart = _ref.onStart, _onStop = _ref.onStop;
    var _useState7 = _sliced_to_array(useState7(null), 2), silenceStart = _useState7[0], setSilenceStart = _useState7[1];
    var _useState71 = _sliced_to_array(useState7(null), 2), noiseStart = _useState71[0], setNoiseStart = _useState71[1];
    var _useState72 = _sliced_to_array(useState7(null), 2), mediaStream = _useState72[0], setMediaStream = _useState72[1];
    var _useState73 = _sliced_to_array(useState7("idle"), 2), status = _useState73[0], setStatus = _useState73[1];
    var startAudioPlayer = useAudioPlayer();
    var endAudioPlayer = useAudioPlayer();
    var _useState74 = _sliced_to_array(useState7(false), 2), isLoaded = _useState74[0], setIsLoaded = _useState74[1];
    useEffect9(function() {
        if (isLoaded) return;
        setIsLoaded(true);
    }, [
        isLoaded,
        startAudioPlayer,
        endAudioPlayer
    ]);
    var audioCaptureProps = useAudioCapture({
        onStart: function(event, opts) {
            setStatus("recording");
            setMediaStream(opts.mediaStream);
            isInited.current = false;
            if (_onStart) _onStart(event, opts);
            setSilenceStart(null);
            setNoiseStart(null);
        },
        onStop: function() {
            var _onStop2 = _asyncToGenerator10(function() {
                var _arguments = arguments;
                return _ts_generator(this, function(_state) {
                    switch(_state.label){
                        case 0:
                            setStatus("stopped");
                            if (!_onStop) return [
                                3,
                                2
                            ];
                            return [
                                4,
                                _onStop.apply(void 0, _arguments)
                            ];
                        case 1:
                            _state.sent();
                            _state.label = 2;
                        case 2:
                            setSilenceStart(null);
                            setNoiseStart(null);
                            return [
                                2
                            ];
                    }
                });
            });
            function onStop() {
                return _onStop2.apply(this, arguments);
            }
            return onStop;
        }(),
        onPause: function() {
            setStatus("paused");
            setSilenceStart(null);
            setNoiseStart(null);
        },
        onResume: function() {
            setStatus("recording");
            setSilenceStart(null);
            setNoiseStart(null);
        }
    });
    var _useState75 = _sliced_to_array(useState7(null), 2), audioEngine = _useState75[0], setAudioEngine = _useState75[1];
    var isInited = useRef7(false);
    useEffect9(function() {
        if (!mediaStream) return;
        if (isInited.current) return;
        isInited.current = true;
        var audioContext = new AudioContext();
        setAudioEngine({
            source: audioContext.createMediaStreamSource(mediaStream),
            audioContext: audioContext
        });
    }, [
        isInited,
        mediaStream
    ]);
    var visualizationAnalyser = useMemo15(function() {
        if (!audioEngine) return null;
        var result = audioEngine.audioContext.createAnalyser();
        audioEngine.source.connect(result);
        return result;
    }, [
        audioEngine
    ]);
    var silenceAnalyser = useMemo15(function() {
        if (!audioEngine) return null;
        var result_0 = audioEngine.audioContext.createAnalyser();
        result_0.minDecibels = -60;
        audioEngine.source.connect(result_0);
        return result_0;
    }, [
        audioEngine
    ]);
    var handleSilence = useCallback5(function() {
        if (!silenceAnalyser) return;
        var frequencyData = new Uint8Array(silenceAnalyser.frequencyBinCount);
        silenceAnalyser.getByteFrequencyData(frequencyData);
        var isSilent = frequencyData.every(function(f) {
            return f === 0;
        });
        setSilenceStart(function(silenceStart_0) {
            if (isSilent) return silenceStart_0 || dayjs3();
            return null;
        });
        setNoiseStart(function(noiseStart_0) {
            if (isSilent) return noiseStart_0;
            return noiseStart_0 || dayjs3();
        });
        requestAnimationFrame(function() {
            return handleSilence();
        });
    }, [
        silenceAnalyser,
        setNoiseStart,
        setSilenceStart
    ]);
    useEffect9(function() {
        if (!isStopOnSilence) return;
        requestAnimationFrame(function() {
            return handleSilence();
        });
    }, [
        handleSilence,
        isStopOnSilence
    ]);
    useInterval(function() {
        if (!isStopOnSilence) return;
        if (status !== "recording") return;
        if (!silenceStart) return;
        if (!noiseStart) return;
        if (!silenceStart.isBefore(dayjs3().subtract(1.5, "second"))) return;
        audioCaptureProps.stop();
    }, 300);
    return _objectSpread44(_objectSpread44({}, audioCaptureProps), {}, {
        status: status,
        visualizationAnalyser: visualizationAnalyser
    });
};
// src/hooks/audioThreads/useMessageAudio/index.ts
import { c as _c49 } from "react-compiler-runtime";
import { useMemo as useMemo16, useRef as useRef8, useState as useState8, useEffect as useEffect10, useCallback as useCallback6 } from "react";
import nlp from "compromise";
import { Howler } from "howler";
import { useAudioPlayer as useAudioPlayer2 } from "react-use-audio-player";
// src/hooks/audioThreads/useMessageAudio/lib/input.ts
import { isEmpty as isEmpty3 } from "radash";
var input = function(_ref) {
    var message = _ref.message;
    var textContents = message.content.filter(function(c) {
        return c.type === "text";
    });
    var result = textContents.map(function(c) {
        return c.text.value;
    }).join(" ");
    if (isEmpty3(result)) return null;
    return result;
};
// src/hooks/audioThreads/useMessageAudio/lib/isHtmlAudioSupported.ts
import { detect } from "detect-browser";
var _detect;
var unsupportedNames = [
    "safari",
    "ios"
];
var isHtmlAudioSupported = !unsupportedNames.includes(((_detect = detect()) === null || _detect === void 0 ? void 0 : _detect.name) || "");
// src/hooks/audioThreads/useMessageAudio/index.ts
function ownKeys45(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread45(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys45(Object(t), true).forEach(function(r2) {
            _defineProperty45(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys45(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty45(e, r, t) {
    return (r = _toPropertyKey45(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey45(t) {
    var i = _toPrimitive45(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive45(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var FULL_SENTENCE_REGEX = /[\.?!]$/;
var getMessageSentences = function(_ref) {
    var messageId = _ref.messageId, input2 = _ref.input;
    var sentences = nlp(input2).sentences().json();
    return sentences.map(function(sentence) {
        return {
            messageId: messageId,
            sentence: sentence.text
        };
    });
};
var useMessageAudio = function(t0) {
    var _latestMessageProps$l;
    var $ = _c49(50);
    var _onEnd = t0.onEnd, passedPlay = t0.play;
    var _useState8 = _sliced_to_array(useState8(false), 2), isAudioPlayed = _useState8[0], setIsAudioPlayed = _useState8[1];
    var t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = [];
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    var _useState81 = _sliced_to_array(useState8(t1), 2), stoppedMessageIds = _useState81[0], setStoppedMessageIds = _useState81[1];
    var t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = [];
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    var _useState82 = _sliced_to_array(useState8(t2), 2), playedMessageSentences = _useState82[0], setPlayedMessageSentences = _useState82[1];
    var audioPlayer = useAudioPlayer2();
    var nextAudioPlayer = useAudioPlayer2();
    var superinterfaceContext = useSuperinterfaceContext();
    var _useState83 = _sliced_to_array(useState8(false), 2), isPlaying = _useState83[0], setIsPlaying = _useState83[1];
    var latestMessageProps = useLatestMessage();
    var t3;
    bb0: {
        if (!latestMessageProps.latestMessage) {
            var _t;
            if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
                _t = [];
                $[2] = _t;
            } else {
                _t = $[2];
            }
            t3 = _t;
            break bb0;
        }
        if (latestMessageProps.latestMessage.role !== "assistant") {
            var _t2;
            if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
                _t2 = [];
                $[3] = _t2;
            } else {
                _t2 = $[3];
            }
            t3 = _t2;
            break bb0;
        }
        if (stoppedMessageIds.includes(latestMessageProps.latestMessage.id)) {
            var _t3;
            if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
                _t3 = [];
                $[4] = _t3;
            } else {
                _t3 = $[4];
            }
            t3 = _t3;
            break bb0;
        }
        var _t4;
        if ($[5] !== latestMessageProps.latestMessage || $[6] !== playedMessageSentences) {
            var input2 = input({
                message: latestMessageProps.latestMessage
            });
            if (!input2) {
                var _t5;
                if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
                    _t5 = [];
                    $[9] = _t5;
                } else {
                    _t5 = $[9];
                }
                t3 = _t5;
                break bb0;
            }
            var messageSentences = getMessageSentences({
                messageId: latestMessageProps.latestMessage.id,
                input: input2
            });
            var _t6;
            if ($[10] !== playedMessageSentences) {
                _t6 = function(ms) {
                    return !playedMessageSentences.find(function(pms) {
                        return pms.messageId === ms.messageId && pms.sentence === ms.sentence;
                    });
                };
                $[10] = playedMessageSentences;
                $[11] = _t6;
            } else {
                _t6 = $[11];
            }
            _t4 = messageSentences.filter(_t6);
            $[5] = latestMessageProps.latestMessage;
            $[6] = playedMessageSentences;
            $[7] = _t4;
            $[8] = t3;
        } else {
            _t4 = $[7];
            t3 = $[8];
        }
        t3 = _t4;
    }
    var unplayedMessageSentences = t3;
    var t4;
    if ($[12] !== audioPlayer || $[13] !== isAudioPlayed || $[14] !== nextAudioPlayer || $[15] !== superinterfaceContext.baseUrl || $[16] !== superinterfaceContext.variables || $[17] !== unplayedMessageSentences) {
        t4 = function(t52) {
            var input_0 = t52.input, onPlay = t52.onPlay, onStop = t52.onStop, onEnd_0 = t52.onEnd;
            var searchParams = new URLSearchParams(_objectSpread45({
                input: input_0
            }, superinterfaceContext.variables));
            audioPlayer.load("".concat(superinterfaceContext.baseUrl, "/audio-runtimes/tts?").concat(searchParams), {
                format: "mp3",
                autoplay: isAudioPlayed,
                html5: isHtmlAudioSupported,
                onplay: onPlay,
                onstop: onStop,
                onload: function() {
                    var nextUnplayedMessageSentence = unplayedMessageSentences[1];
                    if (!nextUnplayedMessageSentence) {
                        return;
                    }
                    var isNextFullSentence = FULL_SENTENCE_REGEX.test(nextUnplayedMessageSentence.sentence);
                    if (!isNextFullSentence) {
                        return;
                    }
                    var nextSearchParams = new URLSearchParams(_objectSpread45({
                        input: nextUnplayedMessageSentence.sentence
                    }, superinterfaceContext.variables));
                    nextAudioPlayer.load("".concat(superinterfaceContext.baseUrl, "/audio-runtimes/tts?").concat(nextSearchParams), {
                        format: "mp3",
                        autoplay: false,
                        html5: isHtmlAudioSupported
                    });
                },
                onend: onEnd_0
            });
        };
        $[12] = audioPlayer;
        $[13] = isAudioPlayed;
        $[14] = nextAudioPlayer;
        $[15] = superinterfaceContext.baseUrl;
        $[16] = superinterfaceContext.variables;
        $[17] = unplayedMessageSentences;
        $[18] = t4;
    } else {
        t4 = $[18];
    }
    var defaultPlay = t4;
    var t5;
    t5 = passedPlay || defaultPlay;
    var play = t5;
    var t6;
    if ($[19] !== audioPlayer.playing || $[20] !== isPlaying || $[21] !== latestMessageProps.latestMessage || $[22] !== _onEnd || $[23] !== play || $[24] !== unplayedMessageSentences) {
        t6 = function() {
            if (isPlaying) {
                return;
            }
            if (audioPlayer.playing) {
                return;
            }
            if (!latestMessageProps.latestMessage) {
                return;
            }
            if (latestMessageProps.latestMessage.role !== "assistant") {
                return;
            }
            var firstUnplayedMessageSentence = unplayedMessageSentences[0];
            if (!firstUnplayedMessageSentence) {
                return;
            }
            var isFullSentence = isOptimistic({
                id: latestMessageProps.latestMessage.id
            }) || latestMessageProps.latestMessage.status !== "in_progress" || FULL_SENTENCE_REGEX.test(firstUnplayedMessageSentence.sentence);
            if (!isFullSentence) {
                return;
            }
            setIsPlaying(true);
            setPlayedMessageSentences(function(prev) {
                return _to_consumable_array(prev).concat([
                    firstUnplayedMessageSentence
                ]);
            });
            var input_1 = firstUnplayedMessageSentence.sentence;
            play({
                input: input_1,
                onPlay: function() {
                    setIsAudioPlayed(true);
                },
                onStop: function() {
                    setStoppedMessageIds(function(prev_0) {
                        return _to_consumable_array(prev_0).concat([
                            firstUnplayedMessageSentence.messageId
                        ]);
                    });
                    setIsPlaying(false);
                },
                onEnd: function() {
                    setIsPlaying(false);
                    if (unplayedMessageSentences.length === 1 && latestMessageProps.latestMessage.status !== "in_progress") {
                        _onEnd();
                    }
                }
            });
        };
        $[19] = audioPlayer.playing;
        $[20] = isPlaying;
        $[21] = latestMessageProps.latestMessage;
        $[22] = _onEnd;
        $[23] = play;
        $[24] = unplayedMessageSentences;
        $[25] = t6;
    } else {
        t6 = $[25];
    }
    var t7;
    if ($[26] !== audioPlayer || $[27] !== isPlaying || $[28] !== latestMessageProps || $[29] !== nextAudioPlayer || $[30] !== _onEnd || $[31] !== play || $[32] !== playedMessageSentences || $[33] !== superinterfaceContext || $[34] !== unplayedMessageSentences) {
        t7 = [
            unplayedMessageSentences,
            isPlaying,
            superinterfaceContext,
            latestMessageProps,
            audioPlayer,
            nextAudioPlayer,
            playedMessageSentences,
            _onEnd,
            play
        ];
        $[26] = audioPlayer;
        $[27] = isPlaying;
        $[28] = latestMessageProps;
        $[29] = nextAudioPlayer;
        $[30] = _onEnd;
        $[31] = play;
        $[32] = playedMessageSentences;
        $[33] = superinterfaceContext;
        $[34] = unplayedMessageSentences;
        $[35] = t7;
    } else {
        t7 = $[35];
    }
    useEffect10(t6, t7);
    var t8;
    if ($[36] !== audioPlayer) {
        t8 = [
            audioPlayer
        ];
        $[36] = audioPlayer;
        $[37] = t8;
    } else {
        t8 = $[37];
    }
    useEffect10(_temp10, t8);
    var _useState84 = _sliced_to_array(useState8(null), 2), audioEngine = _useState84[0], setAudioEngine = _useState84[1];
    var isAudioEngineInited = useRef8(false);
    var t9;
    if ($[38] !== audioPlayer.playing) {
        t9 = function() {
            if (!audioPlayer.playing) {
                return;
            }
            if (isAudioEngineInited.current) {
                return;
            }
            isAudioEngineInited.current = true;
            if (isHtmlAudioSupported) {
                var audioContext = new AudioContext();
                setAudioEngine({
                    source: audioContext.createMediaElementSource(Howler._howls[0]._sounds[0]._node),
                    audioContext: audioContext
                });
            } else {
                setAudioEngine({
                    source: Howler.masterGain,
                    audioContext: Howler.ctx
                });
            }
        };
        $[38] = audioPlayer.playing;
        $[39] = t9;
    } else {
        t9 = $[39];
    }
    var t10;
    if ($[40] !== audioPlayer) {
        t10 = [
            audioPlayer,
            isAudioEngineInited
        ];
        $[40] = audioPlayer;
        $[41] = t10;
    } else {
        t10 = $[41];
    }
    useEffect10(t9, t10);
    var t11;
    bb1: {
        if (!audioEngine) {
            t11 = null;
            break bb1;
        }
        var result;
        if ($[42] !== audioEngine.audioContext || $[43] !== audioEngine.source) {
            result = audioEngine.audioContext.createAnalyser();
            audioEngine.source.connect(audioEngine.audioContext.destination);
            audioEngine.source.connect(result);
            $[42] = audioEngine.audioContext;
            $[43] = audioEngine.source;
            $[44] = result;
        } else {
            result = $[44];
        }
        t11 = result;
    }
    var visualizationAnalyser = t11;
    var t12;
    t12 = isPlaying || unplayedMessageSentences.length > 0 || ((_latestMessageProps$l = latestMessageProps.latestMessage) === null || _latestMessageProps$l === void 0 ? void 0 : _latestMessageProps$l.status) === "in_progress";
    var isPending = t12;
    var t13;
    if ($[45] !== audioPlayer || $[46] !== isAudioPlayed || $[47] !== isPending || $[48] !== visualizationAnalyser) {
        t13 = _objectSpread45(_objectSpread45({
            isPending: isPending,
            isAudioPlayed: isAudioPlayed
        }, audioPlayer), {}, {
            visualizationAnalyser: visualizationAnalyser
        });
        $[45] = audioPlayer;
        $[46] = isAudioPlayed;
        $[47] = isPending;
        $[48] = visualizationAnalyser;
        $[49] = t13;
    } else {
        t13 = $[49];
    }
    return t13;
};
function _temp10() {
    if (isHtmlAudioSupported) {
        var _Howler$_howls$;
        if (!(Howler !== null && Howler !== void 0 && (_Howler$_howls$ = Howler._howls[0]) !== null && _Howler$_howls$ !== void 0 && (_Howler$_howls$ = _Howler$_howls$._sounds[0]) !== null && _Howler$_howls$ !== void 0 && _Howler$_howls$._node)) {
            return;
        }
        Howler._howls[0]._sounds[0]._node.crossOrigin = "anonymous";
    }
}
// src/hooks/audioRuntimes/useTtsAudioRuntime/index.ts
import { useQueryClient as useQueryClient6 } from "@tanstack/react-query";
// src/hooks/audioRuntimes/useTtsAudioRuntime/blobToData.ts
var blobToData = function(blob) {
    return new Promise(function(resolve) {
        var reader = new FileReader();
        reader.onloadend = function() {
            return resolve(reader.result);
        };
        reader.readAsDataURL(blob);
    });
};
// src/hooks/audioRuntimes/useTtsAudioRuntime/index.ts
function asyncGeneratorStep11(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator11(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep11(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep11(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var useTtsAudioRuntime = function(t0) {
    var $ = _c50(30);
    var play = t0.play;
    var addToast = useToasts().addToast;
    var queryClient = useQueryClient6();
    var threadContext = useSuperinterfaceContext();
    var t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = {
            name: "microphone"
        };
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    var microphonePermission = usePermission(t1);
    var createMessageProps = useCreateMessage({
        onError: function(error) {
            createMessageDefaultOnError({
                queryClient: queryClient,
                addToast: addToast,
                threadContext: threadContext
            })(error);
            recorderProps.start();
        }
    });
    var t2;
    if ($[1] !== createMessageProps) {
        t2 = {
            isStopOnSilence: true,
            onStart: _temp11,
            onStop: function() {
                var _onStop = _asyncToGenerator11(function(_event, chunks) {
                    var blob, audioContent;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                blob = new Blob(chunks, {
                                    type: chunks[0].type
                                });
                                return [
                                    4,
                                    blobToData(blob)
                                ];
                            case 1:
                                audioContent = _state.sent();
                                return [
                                    2,
                                    createMessageProps.createMessage({
                                        audioContent: audioContent
                                    })
                                ];
                        }
                    });
                });
                function onStop(_x, _x2) {
                    return _onStop.apply(this, arguments);
                }
                return onStop;
            }()
        };
        $[1] = createMessageProps;
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    var recorderProps = useRecorder(t2);
    var t3;
    if ($[3] !== microphonePermission || $[4] !== recorderProps) {
        t3 = function() {
            if (microphonePermission === "granted") {
                recorderProps.start();
            }
        };
        $[3] = microphonePermission;
        $[4] = recorderProps;
        $[5] = t3;
    } else {
        t3 = $[5];
    }
    var t4;
    if ($[6] !== play || $[7] !== t3) {
        t4 = {
            play: play,
            onEnd: t3
        };
        $[6] = play;
        $[7] = t3;
        $[8] = t4;
    } else {
        t4 = $[8];
    }
    var messageAudioProps = useMessageAudio(t4);
    recorderProps;
    recorderProps;
    recorderProps;
    recorderProps;
    recorderProps;
    recorderProps;
    recorderProps;
    var t5;
    var t6 = recorderProps;
    var t7 = recorderProps;
    var t8 = recorderProps;
    var t9 = recorderProps;
    var t10 = recorderProps;
    var t11 = recorderProps;
    var t12;
    if ($[9] !== createMessageProps.isPending || $[10] !== t10.visualizationAnalyser || $[11] !== t11.status || $[12] !== t6.start || $[13] !== t7.stop || $[14] !== t8.pause || $[15] !== t9.resume) {
        t12 = {
            start: t6.start,
            stop: t7.stop,
            pause: t8.pause,
            resume: t9.resume,
            isPending: createMessageProps.isPending,
            visualizationAnalyser: t10.visualizationAnalyser,
            rawStatus: t11.status
        };
        $[9] = createMessageProps.isPending;
        $[10] = t10.visualizationAnalyser;
        $[11] = t11.status;
        $[12] = t6.start;
        $[13] = t7.stop;
        $[14] = t8.pause;
        $[15] = t9.resume;
        $[16] = t12;
    } else {
        t12 = $[16];
    }
    var t13;
    if ($[17] !== messageAudioProps.isAudioPlayed || $[18] !== messageAudioProps.isPending || $[19] !== messageAudioProps.isReady || $[20] !== messageAudioProps.pause || $[21] !== messageAudioProps.paused || $[22] !== messageAudioProps.play || $[23] !== messageAudioProps.playing || $[24] !== messageAudioProps.stop || $[25] !== messageAudioProps.visualizationAnalyser) {
        t13 = {
            play: messageAudioProps.play,
            pause: messageAudioProps.pause,
            stop: messageAudioProps.stop,
            visualizationAnalyser: messageAudioProps.visualizationAnalyser,
            playing: messageAudioProps.playing,
            paused: messageAudioProps.paused,
            isPending: messageAudioProps.isPending,
            isReady: messageAudioProps.isReady,
            isAudioPlayed: messageAudioProps.isAudioPlayed,
            rawStatus: void 0
        };
        $[17] = messageAudioProps.isAudioPlayed;
        $[18] = messageAudioProps.isPending;
        $[19] = messageAudioProps.isReady;
        $[20] = messageAudioProps.pause;
        $[21] = messageAudioProps.paused;
        $[22] = messageAudioProps.play;
        $[23] = messageAudioProps.playing;
        $[24] = messageAudioProps.stop;
        $[25] = messageAudioProps.visualizationAnalyser;
        $[26] = t13;
    } else {
        t13 = $[26];
    }
    var t14;
    if ($[27] !== t12 || $[28] !== t13) {
        t14 = {
            ttsAudioRuntime: {
                user: t12,
                assistant: t13
            }
        };
        $[27] = t12;
        $[28] = t13;
        $[29] = t14;
    } else {
        t14 = $[29];
    }
    t5 = t14;
    return t5;
};
function _temp11() {
    return _temp23.apply(this, arguments);
}
function _temp23() {
    _temp23 = _asyncToGenerator11(function() {
        return _ts_generator(this, function(_state) {
            return [
                2
            ];
        });
    });
    return _temp23.apply(this, arguments);
}
// src/components/audioRuntimes/TtsAudioRuntimeProvider.tsx
import { jsx as _jsx83 } from "react/jsx-runtime";
var TtsAudioRuntimeProvider = function(t0) {
    var $ = _c51(7);
    var children = t0.children, play = t0.play;
    var t1;
    if ($[0] !== play) {
        t1 = {
            play: play
        };
        $[0] = play;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var ttsAudioRuntime = useTtsAudioRuntime(t1).ttsAudioRuntime;
    var t2;
    if ($[2] !== ttsAudioRuntime) {
        t2 = {
            audioRuntime: ttsAudioRuntime
        };
        $[2] = ttsAudioRuntime;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    var t3;
    if ($[4] !== children || $[5] !== t2) {
        t3 = /* @__PURE__ */ _jsx83(AudioThreadContext.Provider, {
            value: t2,
            children: children
        });
        $[4] = children;
        $[5] = t2;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    return t3;
};
// src/components/threads/AudioThread/Root/index.tsx
import { jsx as _jsx84 } from "react/jsx-runtime";
var _excluded5 = [
    "children"
];
var _excluded22 = [
    "children",
    "play",
    "className",
    "style"
];
function ownKeys46(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread46(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys46(Object(t), true).forEach(function(r2) {
            _defineProperty46(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys46(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty46(e, r, t) {
    return (r = _toPropertyKey46(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey46(t) {
    var i = _toPrimitive46(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive46(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties5(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose5(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose5(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
var Content8 = function(_ref) {
    var children = _ref.children, className = _ref.className, style = _ref.style;
    return /* @__PURE__ */ _jsx84(Flex29, {
        direction: "column",
        flexGrow: "1",
        p: "9",
        className: className,
        style: style,
        children: children
    });
};
var AudioRuntimeProvider = function(t0) {
    var $ = _c52(3);
    var children = t0.children, play = t0.play;
    var audioThreadContext = useAudioThreadContext();
    if (audioThreadContext.audioRuntime) {
        return children;
    }
    var t1;
    if ($[0] !== children || $[1] !== play) {
        t1 = /* @__PURE__ */ _jsx84(TtsAudioRuntimeProvider, {
            play: play,
            children: children
        });
        $[0] = children;
        $[1] = play;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    return t1;
};
var Provider5 = function(t0) {
    var $ = _c52(9);
    var children;
    var rest;
    if ($[0] !== t0) {
        var _t = t0;
        children = _t.children;
        rest = _objectWithoutProperties5(_t, _excluded5);
        _t;
        $[0] = t0;
        $[1] = children;
        $[2] = rest;
    } else {
        children = $[1];
        rest = $[2];
    }
    var audioThreadContext = useAudioThreadContext();
    var t1;
    if ($[3] !== audioThreadContext || $[4] !== rest) {
        t1 = _objectSpread46(_objectSpread46({}, audioThreadContext), rest);
        $[3] = audioThreadContext;
        $[4] = rest;
        $[5] = t1;
    } else {
        t1 = $[5];
    }
    var t2;
    if ($[6] !== children || $[7] !== t1) {
        t2 = /* @__PURE__ */ _jsx84(AudioThreadContext.Provider, {
            value: t1,
            children: children
        });
        $[6] = children;
        $[7] = t1;
        $[8] = t2;
    } else {
        t2 = $[8];
    }
    return t2;
};
var Root12 = function(_ref2) {
    var children = _ref2.children, play = _ref2.play, className = _ref2.className, style = _ref2.style, rest = _objectWithoutProperties5(_ref2, _excluded22);
    return /* @__PURE__ */ _jsx84(Provider5, _objectSpread46(_objectSpread46({}, rest), {}, {
        children: /* @__PURE__ */ _jsx84(AudioRuntimeProvider, {
            play: play,
            children: /* @__PURE__ */ _jsx84(ToastsProvider, {
                children: /* @__PURE__ */ _jsx84(Content8, {
                    className: className,
                    style: style,
                    children: children
                })
            })
        })
    }));
};
// src/components/threads/AudioThread/Visualization/index.tsx
import { useContext as useContext15, useState as useState10, useCallback as useCallback8, useEffect as useEffect12 } from "react";
import _9 from "lodash";
import { Flex as Flex31 } from "@radix-ui/themes";
// src/components/threads/AudioThread/BarsVisualizer/index.tsx
import _8 from "lodash";
import { Flex as Flex30, Grid } from "@radix-ui/themes";
import { useState as useState9, useEffect as useEffect11, useCallback as useCallback7 } from "react";
import { cluster } from "radash";
import { jsx as _jsx85 } from "react/jsx-runtime";
var barCount = 4;
var BarsVisualizer = function(_ref) {
    var visualizationAnalyser = _ref.visualizationAnalyser, backgroundColor = _ref.backgroundColor, height = _ref.height, barWidth = _ref.barWidth;
    var _useState9 = _sliced_to_array(useState9([]), 2), barHeights = _useState9[0], setBarHeights = _useState9[1];
    var draw = useCallback7(function(_ref2) {
        var visualizationAnalyser_0 = _ref2.visualizationAnalyser;
        if (!visualizationAnalyser_0) {
            setBarHeights(Array(barCount).fill(0));
            return;
        }
        var frequencyData = new Uint8Array(visualizationAnalyser_0.frequencyBinCount / 15);
        visualizationAnalyser_0.getByteFrequencyData(frequencyData);
        var clusteredFrequencyData = cluster(frequencyData, frequencyData.length / barCount);
        setBarHeights(clusteredFrequencyData.map(function(frequencyDataCluster) {
            return _8.mean(frequencyDataCluster) / 255 * 100;
        }));
        requestAnimationFrame(function() {
            return draw({
                visualizationAnalyser: visualizationAnalyser_0
            });
        });
    }, []);
    useEffect11(function() {
        draw({
            visualizationAnalyser: visualizationAnalyser
        });
    }, [
        draw,
        visualizationAnalyser
    ]);
    return /* @__PURE__ */ _jsx85(Grid, {
        columns: "".concat(barCount),
        gap: "1",
        width: "auto",
        style: {
            // TODO not sure why we need this
            gridTemplateColumns: "repeat(4, minmax(0, 1fr))"
        },
        children: barHeights.map(function(barHeight, index) {
            return /* @__PURE__ */ _jsx85(Flex30, {
                direction: "column",
                align: "center",
                justify: "center",
                height: height,
                children: /* @__PURE__ */ _jsx85(Flex30, {
                    minHeight: "50%",
                    maxHeight: "100%",
                    height: "".concat(barHeight + 20, "%"),
                    width: barWidth,
                    style: {
                        backgroundColor: backgroundColor,
                        borderRadius: "var(--radius-6)"
                    }
                })
            }, index);
        })
    });
};
// src/hooks/audioThreads/useStatus/index.ts
import { c as _c53 } from "react-compiler-runtime";
import { useMemo as useMemo18 } from "react";
var useStatus = function() {
    var $ = _c53(2);
    var audioRuntime = useAudioThreadContext().audioRuntime;
    var t0;
    bb0: {
        if (audioRuntime.user.rawStatus === "recording") {
            t0 = "recording";
            break bb0;
        }
        if (audioRuntime.user.isPending) {
            t0 = "creatingMessage";
            break bb0;
        }
        if (audioRuntime.assistant.paused || !audioRuntime.assistant.isAudioPlayed) {
            t0 = "playerPaused";
            break bb0;
        }
        if (audioRuntime.assistant.playing || audioRuntime.assistant.isPending) {
            t0 = "playing";
            break bb0;
        }
        if (!audioRuntime.assistant.isAudioPlayed && !audioRuntime.assistant.isReady) {
            t0 = "loading";
            break bb0;
        }
        if (audioRuntime.user.rawStatus === "idle") {
            t0 = "idle";
            break bb0;
        }
        if (audioRuntime.user.rawStatus === "paused") {
            t0 = "recorderPaused";
            break bb0;
        }
        t0 = "loading";
    }
    var status = t0;
    var t1;
    if ($[0] !== status) {
        t1 = {
            status: status
        };
        $[0] = status;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    return t1;
};
// src/components/threads/AudioThread/Visualization/index.tsx
import { jsx as _jsx86, jsxs as _jsxs31 } from "react/jsx-runtime";
function ownKeys47(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread47(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys47(Object(t), true).forEach(function(r2) {
            _defineProperty47(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys47(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty47(e, r, t) {
    return (r = _toPropertyKey47(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey47(t) {
    var i = _toPrimitive47(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive47(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Visualization = function(props) {
    var status = useStatus().status;
    var audioThreadContext = useAudioThreadContext();
    var assistantNameContext = useContext15(AssistantNameContext);
    var _useState10 = _sliced_to_array(useState10(0), 2), scale = _useState10[0], setScale = _useState10[1];
    var draw = useCallback8(function(_ref) {
        var visualizationAnalyser = _ref.visualizationAnalyser;
        if (!visualizationAnalyser) {
            setScale(1);
            return;
        }
        var frequencyData = new Uint8Array(visualizationAnalyser.frequencyBinCount / 15);
        visualizationAnalyser.getByteFrequencyData(frequencyData);
        setScale(1 + _9.mean(frequencyData) / 255 / 10);
        requestAnimationFrame(function() {
            return draw({
                visualizationAnalyser: visualizationAnalyser
            });
        });
    }, []);
    useEffect12(function() {
        draw({
            visualizationAnalyser: audioThreadContext.audioRuntime.user.visualizationAnalyser
        });
    }, [
        draw,
        audioThreadContext
    ]);
    return /* @__PURE__ */ _jsxs31(Flex31, _objectSpread47(_objectSpread47({
        direction: "column",
        align: "center",
        justify: "center",
        mb: "3",
        flexGrow: "1"
    }, props), {}, {
        children: [
            /* @__PURE__ */ _jsx86(Flex31, {
                align: "center",
                justify: "center",
                height: "200px",
                width: "200px",
                style: {
                    backgroundColor: status === "playing" ? "var(--accent-4)" : "var(--gray-4)",
                    borderRadius: "9999px",
                    scale: scale
                },
                children: /* @__PURE__ */ _jsx86(BarsVisualizer, {
                    visualizationAnalyser: audioThreadContext.audioRuntime.assistant.visualizationAnalyser,
                    backgroundColor: status === "playing" ? "var(--accent-11)" : "var(--gray-11)",
                    height: "40px",
                    barWidth: "24px"
                })
            }),
            /* @__PURE__ */ _jsxs31(Flex31, {
                ml: "-22.5px",
                gap: "3",
                pt: "5",
                children: [
                    /* @__PURE__ */ _jsx86(AssistantAvatar, {}),
                    /* @__PURE__ */ _jsx86(Name, {
                        children: assistantNameContext
                    })
                ]
            })
        ]
    }));
};
// src/components/threads/AudioThread/Status/index.tsx
import { c as _c54 } from "react-compiler-runtime";
// src/components/threads/AudioThread/Status/StatusMessages.tsx
import { Flex as Flex32, Text as Text9 } from "@radix-ui/themes";
import { jsx as _jsx87, jsxs as _jsxs32 } from "react/jsx-runtime";
var html = function(_ref) {
    var texts = _ref.texts;
    return "\n  .status-messages-texts:after {\n    content: '".concat(texts[0], "';\n    animation: texts ").concat(texts.length * 5, "s linear infinite;\n  }\n\n  @keyframes texts {\n    ").concat(texts.map(function(_10, i) {
        return "\n      ".concat(i * 100 / texts.length, '% {\n        content: "').concat(texts[i], '";\n      }\n    ');
    }).join(""), "\n  }");
};
var StatusMessages = function(_ref2) {
    var texts = _ref2.texts, className = _ref2.className, style = _ref2.style;
    return /* @__PURE__ */ _jsxs32(Flex32, {
        justify: "center",
        pb: "5",
        className: className,
        style: style,
        children: [
            /* @__PURE__ */ _jsx87(Text9, {
                size: "2",
                weight: "regular",
                color: "gray",
                className: "status-messages-texts"
            }),
            /* @__PURE__ */ _jsx87("style", {
                dangerouslySetInnerHTML: {
                    __html: html({
                        texts: texts
                    })
                }
            })
        ]
    });
};
// src/components/threads/AudioThread/Status/index.tsx
import { jsx as _jsx88 } from "react/jsx-runtime";
function ownKeys48(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread48(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys48(Object(t), true).forEach(function(r2) {
            _defineProperty48(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys48(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty48(e, r, t) {
    return (r = _toPropertyKey48(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey48(t) {
    var i = _toPrimitive48(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive48(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Status = function(props) {
    var $ = _c54(12);
    var status = useStatus().status;
    if (status === "recording") {
        var _t;
        if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
            _t = [
                "Start speaking",
                "Listening",
                "Finish speaking to send",
                "Click the button below to send manually"
            ];
            $[0] = _t;
        } else {
            _t = $[0];
        }
        var _t2;
        if ($[1] !== props) {
            _t2 = /* @__PURE__ */ _jsx88(StatusMessages, _objectSpread48({
                texts: _t
            }, props));
            $[1] = props;
            $[2] = _t2;
        } else {
            _t2 = $[2];
        }
        return _t2;
    }
    if ([
        "recorderPaused",
        "idle",
        "playerPaused"
    ].includes(status)) {
        var _t3;
        if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
            _t3 = [
                "Click the button below to activate"
            ];
            $[3] = _t3;
        } else {
            _t3 = $[3];
        }
        var _t4;
        if ($[4] !== props) {
            _t4 = /* @__PURE__ */ _jsx88(StatusMessages, _objectSpread48({
                texts: _t3
            }, props));
            $[4] = props;
            $[5] = _t4;
        } else {
            _t4 = $[5];
        }
        return _t4;
    }
    if (status === "playing") {
        var _t5;
        if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
            _t5 = [
                "Click the button below to interrupt"
            ];
            $[6] = _t5;
        } else {
            _t5 = $[6];
        }
        var _t6;
        if ($[7] !== props) {
            _t6 = /* @__PURE__ */ _jsx88(StatusMessages, _objectSpread48({
                texts: _t5
            }, props));
            $[7] = props;
            $[8] = _t6;
        } else {
            _t6 = $[8];
        }
        return _t6;
    }
    var t0;
    if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = [
            "Thinking"
        ];
        $[9] = t0;
    } else {
        t0 = $[9];
    }
    var t1;
    if ($[10] !== props) {
        t1 = /* @__PURE__ */ _jsx88(StatusMessages, _objectSpread48({
            texts: t0
        }, props));
        $[10] = props;
        $[11] = t1;
    } else {
        t1 = $[11];
    }
    return t1;
};
// src/components/threads/AudioThread/Form/index.tsx
import { c as _c56 } from "react-compiler-runtime";
import { Flex as Flex34 } from "@radix-ui/themes";
// src/components/threads/AudioThread/Form/MicIcon.tsx
import { jsx as _jsx89 } from "react/jsx-runtime";
function ownKeys49(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread49(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys49(Object(t), true).forEach(function(r2) {
            _defineProperty49(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys49(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty49(e, r, t) {
    return (r = _toPropertyKey49(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey49(t) {
    var i = _toPrimitive49(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive49(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var MicIcon = function(props) {
    return /* @__PURE__ */ _jsx89("svg", _objectSpread49(_objectSpread49({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        stroke: "currentColor",
        strokeWidth: 0,
        viewBox: "0 0 384 512",
        height: "15",
        width: "15"
    }, props), {}, {
        children: /* @__PURE__ */ _jsx89("path", {
            stroke: "none",
            d: "M192 0c-53 0-96 43-96 96v160c0 53 43 96 96 96s96-43 96-96V96c0-53-43-96-96-96zM64 216c0-13.3-10.7-24-24-24s-24 10.7-24 24v40c0 89.1 66.2 162.7 152 174.4V464h-48c-13.3 0-24 10.7-24 24s10.7 24 24 24h144c13.3 0 24-10.7 24-24s-10.7-24-24-24h-48v-33.6c85.8-11.7 152-85.3 152-174.4v-40c0-13.3-10.7-24-24-24s-24 10.7-24 24v40c0 70.7-57.3 128-128 128S64 326.7 64 256v-40z"
        })
    }));
};
// src/components/threads/AudioThread/Form/ActionButton/index.tsx
import { c as _c55 } from "react-compiler-runtime";
import { Flex as Flex33, IconButton as IconButton10 } from "@radix-ui/themes";
import { StopIcon as StopIcon2, PauseIcon as PauseIcon2, ArrowUpIcon as ArrowUpIcon3, ResumeIcon } from "@radix-ui/react-icons";
import { jsx as _jsx90, jsxs as _jsxs33 } from "react/jsx-runtime";
var ActionButton = function() {
    var $ = _c55(27);
    var status = useStatus().status;
    var audioThreadContext = useAudioThreadContext();
    var superinterfaceContext = useSuperinterfaceContext();
    if (status === "recording") {
        var _t;
        if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
            _t = /* @__PURE__ */ _jsx90(PauseIcon2, {});
            $[0] = _t;
        } else {
            _t = $[0];
        }
        var t1;
        if ($[1] !== audioThreadContext.audioRuntime.user.pause) {
            t1 = /* @__PURE__ */ _jsx90(Flex33, {
                mr: "3",
                ml: "-7",
                children: /* @__PURE__ */ _jsx90(IconButton10, {
                    onClick: audioThreadContext.audioRuntime.user.pause,
                    color: "gray",
                    variant: "soft",
                    size: "1",
                    children: _t
                })
            });
            $[1] = audioThreadContext.audioRuntime.user.pause;
            $[2] = t1;
        } else {
            t1 = $[2];
        }
        var t2;
        if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
            t2 = /* @__PURE__ */ _jsx90(ArrowUpIcon3, {});
            $[3] = t2;
        } else {
            t2 = $[3];
        }
        var t3;
        if ($[4] !== audioThreadContext.audioRuntime.user.stop) {
            t3 = /* @__PURE__ */ _jsx90(IconButton10, {
                onClick: audioThreadContext.audioRuntime.user.stop,
                highContrast: true,
                variant: "soft",
                size: "4",
                children: t2
            });
            $[4] = audioThreadContext.audioRuntime.user.stop;
            $[5] = t3;
        } else {
            t3 = $[5];
        }
        var t4;
        if ($[6] !== t1 || $[7] !== t3) {
            t4 = /* @__PURE__ */ _jsxs33(Flex33, {
                align: "center",
                children: [
                    t1,
                    t3
                ]
            });
            $[6] = t1;
            $[7] = t3;
            $[8] = t4;
        } else {
            t4 = $[8];
        }
        return t4;
    }
    if (status === "recorderPaused") {
        var _t2;
        if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
            _t2 = /* @__PURE__ */ _jsx90(ResumeIcon, {});
            $[9] = _t2;
        } else {
            _t2 = $[9];
        }
        var _t3;
        if ($[10] !== audioThreadContext.audioRuntime.user.resume) {
            _t3 = /* @__PURE__ */ _jsx90(IconButton10, {
                onClick: audioThreadContext.audioRuntime.user.resume,
                color: "red",
                size: "4",
                children: _t2
            });
            $[10] = audioThreadContext.audioRuntime.user.resume;
            $[11] = _t3;
        } else {
            _t3 = $[11];
        }
        return _t3;
    }
    if (status === "idle") {
        var _t4;
        if ($[12] !== audioThreadContext.audioRuntime.user) {
            _t4 = /* @__PURE__ */ _jsx90(IconButton10, {
                onClick: function() {
                    return audioThreadContext.audioRuntime.user.start();
                },
                size: "4",
                color: "red"
            });
            $[12] = audioThreadContext.audioRuntime.user;
            $[13] = _t4;
        } else {
            _t4 = $[13];
        }
        return _t4;
    }
    if (status === "playing") {
        var _t5;
        if ($[14] !== audioThreadContext.audioRuntime.assistant || $[15] !== audioThreadContext.audioRuntime.user || $[16] !== superinterfaceContext.createMessageAbortControllerRef.current) {
            _t5 = function() {
                var _superinterfaceContex;
                audioThreadContext.audioRuntime.assistant.stop();
                (_superinterfaceContex = superinterfaceContext.createMessageAbortControllerRef.current) === null || _superinterfaceContex === void 0 || _superinterfaceContex.abort();
                audioThreadContext.audioRuntime.user.start();
            };
            $[14] = audioThreadContext.audioRuntime.assistant;
            $[15] = audioThreadContext.audioRuntime.user;
            $[16] = superinterfaceContext.createMessageAbortControllerRef.current;
            $[17] = _t5;
        } else {
            _t5 = $[17];
        }
        var _t6;
        if ($[18] === Symbol.for("react.memo_cache_sentinel")) {
            _t6 = /* @__PURE__ */ _jsx90(StopIcon2, {});
            $[18] = _t6;
        } else {
            _t6 = $[18];
        }
        var _t7;
        if ($[19] !== _t5) {
            _t7 = /* @__PURE__ */ _jsx90(IconButton10, {
                onClick: _t5,
                size: "4",
                color: "gray",
                variant: "soft",
                children: _t6
            });
            $[19] = _t5;
            $[20] = _t7;
        } else {
            _t7 = $[20];
        }
        return _t7;
    }
    if (status === "playerPaused") {
        var _t8;
        if ($[21] !== audioThreadContext.audioRuntime.assistant) {
            _t8 = function() {
                return audioThreadContext.audioRuntime.assistant.play();
            };
            $[21] = audioThreadContext.audioRuntime.assistant;
            $[22] = _t8;
        } else {
            _t8 = $[22];
        }
        var _t9;
        if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
            _t9 = /* @__PURE__ */ _jsx90(ResumeIcon, {});
            $[23] = _t9;
        } else {
            _t9 = $[23];
        }
        var _t10;
        if ($[24] !== _t8) {
            _t10 = /* @__PURE__ */ _jsx90(IconButton10, {
                onClick: _t8,
                size: "4",
                children: _t9
            });
            $[24] = _t8;
            $[25] = _t10;
        } else {
            _t10 = $[25];
        }
        return _t10;
    }
    var t0;
    if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = /* @__PURE__ */ _jsx90(IconButton10, {
            size: "4",
            variant: "soft",
            disabled: true
        });
        $[26] = t0;
    } else {
        t0 = $[26];
    }
    return t0;
};
// src/components/threads/AudioThread/Form/index.tsx
import { jsx as _jsx91, jsxs as _jsxs34 } from "react/jsx-runtime";
function ownKeys50(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread50(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys50(Object(t), true).forEach(function(r2) {
            _defineProperty50(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys50(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty50(e, r, t) {
    return (r = _toPropertyKey50(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey50(t) {
    var i = _toPrimitive50(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive50(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var Form = function(props) {
    var $ = _c56(17);
    var status = useStatus().status;
    var audioThreadContext = useAudioThreadContext();
    var t0 = status === "recording" ? "var(--accent-11)" : "var(--gray-11)";
    var t1;
    if ($[0] !== t0) {
        t1 = /* @__PURE__ */ _jsx91(Flex34, {
            ml: "-22.5px",
            mr: "2",
            align: "center",
            children: /* @__PURE__ */ _jsx91(MicIcon, {
                style: {
                    color: t0
                }
            })
        });
        $[0] = t0;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2 = status === "recording" ? "var(--accent-4)" : "var(--gray-4)";
    var t3;
    if ($[2] !== t2) {
        t3 = {
            backgroundColor: t2,
            borderRadius: "var(--radius-6)"
        };
        $[2] = t2;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    var t4 = status === "recording" ? "var(--accent-11)" : "var(--gray-11)";
    var t5;
    if ($[4] !== audioThreadContext.audioRuntime.user.visualizationAnalyser || $[5] !== t4) {
        t5 = /* @__PURE__ */ _jsx91(BarsVisualizer, {
            visualizationAnalyser: audioThreadContext.audioRuntime.user.visualizationAnalyser,
            backgroundColor: t4,
            height: "20px",
            barWidth: "12px"
        });
        $[4] = audioThreadContext.audioRuntime.user.visualizationAnalyser;
        $[5] = t4;
        $[6] = t5;
    } else {
        t5 = $[6];
    }
    var t6;
    if ($[7] !== t3 || $[8] !== t5) {
        t6 = /* @__PURE__ */ _jsx91(Flex34, {
            px: "2",
            py: "1",
            style: t3,
            children: t5
        });
        $[7] = t3;
        $[8] = t5;
        $[9] = t6;
    } else {
        t6 = $[9];
    }
    var t7;
    if ($[10] !== t1 || $[11] !== t6) {
        t7 = /* @__PURE__ */ _jsxs34(Flex34, {
            pb: "3",
            align: "center",
            children: [
                t1,
                t6
            ]
        });
        $[10] = t1;
        $[11] = t6;
        $[12] = t7;
    } else {
        t7 = $[12];
    }
    var t8;
    if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
        t8 = /* @__PURE__ */ _jsx91(ActionButton, {});
        $[13] = t8;
    } else {
        t8 = $[13];
    }
    var t9;
    if ($[14] !== props || $[15] !== t7) {
        t9 = /* @__PURE__ */ _jsxs34(Flex34, _objectSpread50(_objectSpread50({
            direction: "column",
            align: "center"
        }, props), {}, {
            children: [
                t7,
                t8
            ]
        }));
        $[14] = props;
        $[15] = t7;
        $[16] = t9;
    } else {
        t9 = $[16];
    }
    return t9;
};
// src/components/threads/AudioThread/index.tsx
import { jsx as _jsx92, jsxs as _jsxs35 } from "react/jsx-runtime";
function ownKeys51(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread51(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys51(Object(t), true).forEach(function(r2) {
            _defineProperty51(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys51(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty51(e, r, t) {
    return (r = _toPropertyKey51(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey51(t) {
    var i = _toPrimitive51(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive51(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var AudioThread = function(props) {
    return /* @__PURE__ */ _jsxs35(Root12, _objectSpread51(_objectSpread51({}, props), {}, {
        children: [
            /* @__PURE__ */ _jsx92(Visualization, {}),
            /* @__PURE__ */ _jsx92(Status, {}),
            /* @__PURE__ */ _jsx92(Form, {})
        ]
    }));
};
AudioThread.Root = Root12;
AudioThread.Visualization = Visualization;
AudioThread.Status = Status;
AudioThread.Form = Form;
// src/components/threads/AudioThreadDialog/index.tsx
import { jsx as _jsx93, jsxs as _jsxs36 } from "react/jsx-runtime";
function ownKeys52(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread52(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys52(Object(t), true).forEach(function(r2) {
            _defineProperty52(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys52(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
function _defineProperty52(e, r, t) {
    return (r = _toPropertyKey52(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
    }) : e[r] = t, e;
}
function _toPropertyKey52(t) {
    var i = _toPrimitive52(t, "string");
    return "symbol" == (typeof i === "undefined" ? "undefined" : _type_of(i)) ? i : i + "";
}
function _toPrimitive52(t, r) {
    if ("object" != (typeof t === "undefined" ? "undefined" : _type_of(t)) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (typeof i === "undefined" ? "undefined" : _type_of(i))) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var AudioThreadDialog = function(props) {
    return /* @__PURE__ */ _jsxs36(Root9, _objectSpread52(_objectSpread52({}, props), {}, {
        children: [
            /* @__PURE__ */ _jsx93(Content7.Root, {
                children: /* @__PURE__ */ _jsx93(AudioThread, {})
            }),
            /* @__PURE__ */ _jsx93(Trigger, {})
        ]
    }));
};
AudioThreadDialog.Root = Root9;
AudioThreadDialog.Trigger = Trigger;
AudioThreadDialog.Content = Content7;
// src/hooks/audioRuntimes/useWebrtcAudioRuntime/index.ts
import { useEffect as useEffect13, useMemo as useMemo19, useRef as useRef9, useState as useState11 } from "react";
function asyncGeneratorStep12(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n2) {
        return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator12(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n2) {
                asyncGeneratorStep12(a, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
                asyncGeneratorStep12(a, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
        });
    };
}
var sentTypes = [
    "session.created",
    "response.done",
    "conversation.item.input_audio_transcription.completed"
];
var handleThreadEvent = function(_ref) {
    var event = _ref.event, superinterfaceContext = _ref.superinterfaceContext;
    if (event.data.event === "thread.created") {
        threadCreated({
            value: event.data,
            superinterfaceContext: superinterfaceContext
        });
    } else if (event.data.event === "thread.run.requires_action") {
        threadRunRequiresAction({
            value: event.data,
            superinterfaceContext: superinterfaceContext
        });
    }
};
var createAnalyser = function(_ref2) {
    var mediaStream = _ref2.mediaStream;
    var audioCtx = new AudioContext();
    var source = audioCtx.createMediaStreamSource(mediaStream);
    var analyser = audioCtx.createAnalyser();
    source.connect(analyser);
    return analyser;
};
var handleOpenaiEvent = function(_ref3) {
    var event = _ref3.event, openaiEventsDataChannel = _ref3.openaiEventsDataChannel;
    openaiEventsDataChannel.send(JSON.stringify(event.data));
};
var handleEvent = function(_ref4) {
    var event = _ref4.event, superinterfaceContext = _ref4.superinterfaceContext, openaiEventsDataChannel = _ref4.openaiEventsDataChannel;
    if (event.type === "openaiEvent") {
        return handleOpenaiEvent({
            event: event,
            openaiEventsDataChannel: openaiEventsDataChannel
        });
    } else if (event.type === "threadEvent") {
        return handleThreadEvent({
            event: event,
            superinterfaceContext: superinterfaceContext
        });
    }
};
var useWebrtcAudioRuntime = function() {
    var startSessionIfNeeded = function startSessionIfNeeded() {
        return _startSessionIfNeeded.apply(this, arguments);
    };
    var initRealtimeSession = function initRealtimeSession() {
        return _initRealtimeSession.apply(this, arguments);
    };
    var buildAnalyzers = function buildAnalyzers(_ref5) {
        var localStream = _ref5.localStream, remoteStream = _ref5.remoteStream;
        try {
            userAnalyserRef.current = createAnalyser({
                mediaStream: localStream
            });
            assistantAnalyserRef.current = createAnalyser({
                mediaStream: remoteStream
            });
        } catch (err_0) {
            console.warn("Could not build analyzers:", err_0);
        }
    };
    var _useState11 = _sliced_to_array(useState11("idle"), 2), recorderStatus = _useState11[0], setRecorderStatus = _useState11[1];
    var superinterfaceContext = useSuperinterfaceContext();
    var _useState111 = _sliced_to_array(useState11(false), 2), userIsPending = _useState111[0], setUserIsPending = _useState111[1];
    var _useState112 = _sliced_to_array(useState11(false), 2), assistantPlaying = _useState112[0], setAssistantPlaying = _useState112[1];
    var _useState113 = _sliced_to_array(useState11(false), 2), assistantPaused = _useState113[0], setAssistantPaused = _useState113[1];
    var _useState114 = _sliced_to_array(useState11(true), 2), assistantIsPending = _useState114[0], setAssistantIsPending = _useState114[1];
    var _useState115 = _sliced_to_array(useState11(false), 2), assistantIsReady = _useState115[0], setAssistantIsReady = _useState115[1];
    var _useState116 = _sliced_to_array(useState11(false), 2), assistantAudioPlayed = _useState116[0], setAssistantAudioPlayed = _useState116[1];
    var sessionStartedRef = useRef9(false);
    var pcRef = useRef9(null);
    var localStreamRef = useRef9(null);
    var remoteStreamRef = useRef9(null);
    var userAnalyserRef = useRef9(null);
    var assistantAnalyserRef = useRef9(null);
    var assistantAudioElRef = useRef9(null);
    useEffect13(function() {
        return function() {
            if (pcRef.current) {
                pcRef.current.close();
                pcRef.current = null;
            }
            if (assistantAudioElRef.current) {
                assistantAudioElRef.current.srcObject = null;
            }
        };
    }, []);
    function _startSessionIfNeeded() {
        _startSessionIfNeeded = _asyncToGenerator12(function() {
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (sessionStartedRef.current) return [
                            2
                        ];
                        sessionStartedRef.current = true;
                        return [
                            4,
                            initRealtimeSession()
                        ];
                    case 1:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        });
        return _startSessionIfNeeded.apply(this, arguments);
    }
    function _initRealtimeSession() {
        _initRealtimeSession = _asyncToGenerator12(function() {
            var peerConn, audioEl, openaiEventsDataChannel, ms, offer, searchParams_0, sdpResponse, answerSdp, answer, err1;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _state.trys.push([
                            0,
                            7,
                            ,
                            8
                        ]);
                        setUserIsPending(true);
                        peerConn = new RTCPeerConnection({
                            iceServers: [
                                {
                                    urls: "stun:stun.l.google.com:19302"
                                },
                                {
                                    urls: "stun:stun1.l.google.com:19302"
                                },
                                {
                                    urls: "stun:stun2.l.google.com:19302"
                                },
                                {
                                    urls: "stun:stun3.l.google.com:19302"
                                },
                                {
                                    urls: "stun:stun4.l.google.com:19302"
                                },
                                {
                                    urls: "stun:global.stun.twilio.com:3478"
                                }
                            ]
                        });
                        pcRef.current = peerConn;
                        audioEl = document.createElement("audio");
                        audioEl.autoplay = true;
                        assistantAudioElRef.current = audioEl;
                        peerConn.ontrack = function(evt) {
                            remoteStreamRef.current = evt.streams[0];
                            audioEl.srcObject = evt.streams[0];
                            setAssistantIsPending(false);
                            setAssistantPlaying(true);
                            setAssistantPaused(false);
                            setAssistantAudioPlayed(true);
                        };
                        openaiEventsDataChannel = peerConn.createDataChannel("oai-events");
                        openaiEventsDataChannel.addEventListener("message", /* @__PURE__ */ function() {
                            var _ref8 = _asyncToGenerator12(function(e) {
                                var parsedData, searchParams, eventsResponse, reader, decoder, _ref, value, done, buffer, lines, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, event, ref;
                                return _ts_generator(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            parsedData = JSON.parse(e.data);
                                            if (!sentTypes.includes(parsedData.type)) return [
                                                2
                                            ];
                                            if (parsedData.type === "response.done" && parsedData.response.status !== "completed") return [
                                                2
                                            ];
                                            searchParams = new URLSearchParams(variableParams({
                                                variables: superinterfaceContext.variables,
                                                superinterfaceContext: superinterfaceContext
                                            }));
                                            return [
                                                4,
                                                fetch("".concat(superinterfaceContext.baseUrl, "/audio-runtimes/webrtc/events?").concat(searchParams), {
                                                    method: "POST",
                                                    headers: {
                                                        "Content-Type": "application/json"
                                                    },
                                                    body: e.data
                                                })
                                            ];
                                        case 1:
                                            eventsResponse = _state.sent();
                                            if (!eventsResponse.body) {
                                                throw new Error("No body in events response");
                                            }
                                            reader = eventsResponse.body.getReader();
                                            decoder = new TextDecoder("utf-8");
                                            return [
                                                4,
                                                reader.read()
                                            ];
                                        case 2:
                                            _ref = _state.sent(), value = _ref.value, done = _ref.done;
                                            buffer = "";
                                            _state.label = 3;
                                        case 3:
                                            if (!!done) return [
                                                3,
                                                5
                                            ];
                                            buffer += decoder.decode(value, {
                                                stream: true
                                            });
                                            lines = buffer.split("\n");
                                            buffer = lines.pop() || "";
                                            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                            try {
                                                for(_iterator = lines[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                                    line = _step.value;
                                                    if (line.trim()) {
                                                        try {
                                                            event = JSON.parse(line);
                                                            handleEvent({
                                                                event: event,
                                                                superinterfaceContext: superinterfaceContext,
                                                                openaiEventsDataChannel: openaiEventsDataChannel
                                                            });
                                                        } catch (error) {
                                                            console.error("JSON parse error:", error, "Line:", line);
                                                        }
                                                    }
                                                }
                                            } catch (err) {
                                                _didIteratorError = true;
                                                _iteratorError = err;
                                            } finally{
                                                try {
                                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                        _iterator.return();
                                                    }
                                                } finally{
                                                    if (_didIteratorError) {
                                                        throw _iteratorError;
                                                    }
                                                }
                                            }
                                            return [
                                                4,
                                                reader.read()
                                            ];
                                        case 4:
                                            ref = _state.sent(), value = ref.value, done = ref.done, ref;
                                            return [
                                                3,
                                                3
                                            ];
                                        case 5:
                                            return [
                                                2
                                            ];
                                    }
                                });
                            });
                            return function(_x) {
                                return _ref8.apply(this, arguments);
                            };
                        }());
                        return [
                            4,
                            navigator.mediaDevices.getUserMedia({
                                audio: true
                            })
                        ];
                    case 1:
                        ms = _state.sent();
                        localStreamRef.current = ms;
                        ms.getTracks().forEach(function(t) {
                            peerConn.addTrack(t, ms);
                        });
                        setRecorderStatus("idle");
                        return [
                            4,
                            peerConn.createOffer()
                        ];
                    case 2:
                        offer = _state.sent();
                        return [
                            4,
                            peerConn.setLocalDescription(offer)
                        ];
                    case 3:
                        _state.sent();
                        searchParams_0 = new URLSearchParams(variableParams({
                            variables: superinterfaceContext.variables,
                            superinterfaceContext: superinterfaceContext
                        }));
                        return [
                            4,
                            fetch("".concat(superinterfaceContext.baseUrl, "/audio-runtimes/webrtc?").concat(searchParams_0), {
                                method: "POST",
                                body: offer.sdp,
                                headers: {
                                    "Content-Type": "application/sdp"
                                }
                            })
                        ];
                    case 4:
                        sdpResponse = _state.sent();
                        if (!sdpResponse.ok) {
                            throw new Error("Server responded with status ".concat(sdpResponse.status));
                        }
                        return [
                            4,
                            sdpResponse.text()
                        ];
                    case 5:
                        answerSdp = _state.sent();
                        answer = {
                            type: "answer",
                            sdp: answerSdp
                        };
                        return [
                            4,
                            peerConn.setRemoteDescription(answer)
                        ];
                    case 6:
                        _state.sent();
                        buildAnalyzers({
                            localStream: ms,
                            remoteStream: remoteStreamRef.current
                        });
                        setUserIsPending(false);
                        setAssistantIsPending(false);
                        setAssistantIsReady(true);
                        setAssistantPlaying(true);
                        return [
                            3,
                            8
                        ];
                    case 7:
                        err1 = _state.sent();
                        console.error("Error initRealtimeSession:", err1);
                        setUserIsPending(false);
                        setRecorderStatus("stopped");
                        setAssistantPlaying(false);
                        setAssistantPaused(false);
                        setAssistantIsPending(false);
                        setAssistantIsReady(false);
                        setAssistantAudioPlayed(false);
                        return [
                            3,
                            8
                        ];
                    case 8:
                        return [
                            2
                        ];
                }
            });
        });
        return _initRealtimeSession.apply(this, arguments);
    }
    var start = /* @__PURE__ */ function() {
        var _ref6 = _asyncToGenerator12(function() {
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            startSessionIfNeeded()
                        ];
                    case 1:
                        _state.sent();
                        setAssistantPaused(false);
                        setAssistantPlaying(true);
                        if (assistantAudioElRef.current) {
                            assistantAudioElRef.current.play().catch(function(err_1) {
                                console.error("Assistant play error:", err_1);
                            });
                        }
                        if (localStreamRef.current) {
                            localStreamRef.current.getAudioTracks().forEach(function(t_0) {
                                return t_0.enabled = true;
                            });
                        }
                        return [
                            2
                        ];
                }
            });
        });
        return function start2() {
            return _ref6.apply(this, arguments);
        };
    }();
    var pause = /* @__PURE__ */ function() {
        var _ref7 = _asyncToGenerator12(function() {
            return _ts_generator(this, function(_state) {
                if (!sessionStartedRef.current) return [
                    2
                ];
                setAssistantPaused(true);
                setAssistantPlaying(false);
                if (localStreamRef.current) {
                    localStreamRef.current.getAudioTracks().forEach(function(t_1) {
                        return t_1.enabled = false;
                    });
                }
                return [
                    2
                ];
            });
        });
        return function pause2() {
            return _ref7.apply(this, arguments);
        };
    }();
    return useMemo19(function() {
        return {
            webrtcAudioRuntime: {
                user: {
                    start: function() {
                        var _start = _asyncToGenerator12(function() {
                            return _ts_generator(this, function(_state) {
                                return [
                                    2
                                ];
                            });
                        });
                        function start2() {
                            return _start.apply(this, arguments);
                        }
                        return start2;
                    }(),
                    pause: pause,
                    resume: start,
                    stop: pause,
                    isPending: userIsPending,
                    visualizationAnalyser: userAnalyserRef.current,
                    rawStatus: recorderStatus
                },
                assistant: {
                    play: start,
                    pause: pause,
                    stop: pause,
                    visualizationAnalyser: assistantAnalyserRef.current,
                    playing: assistantPlaying,
                    paused: assistantPaused,
                    isPending: assistantIsPending,
                    isReady: assistantIsReady,
                    isAudioPlayed: assistantAudioPlayed,
                    rawStatus: void 0
                }
            }
        };
    }, [
        recorderStatus,
        userIsPending,
        assistantPlaying,
        assistantPaused,
        assistantIsPending,
        assistantIsReady,
        assistantAudioPlayed
    ]);
};
// src/components/audioRuntimes/WebrtcAudioRuntimeProvider.tsx
import { c as _c57 } from "react-compiler-runtime";
import { jsx as _jsx94 } from "react/jsx-runtime";
var WebrtcAudioRuntimeProvider = function(t0) {
    var $ = _c57(5);
    var children = t0.children;
    var webrtcAudioRuntime = useWebrtcAudioRuntime().webrtcAudioRuntime;
    var t1;
    if ($[0] !== webrtcAudioRuntime) {
        t1 = {
            audioRuntime: webrtcAudioRuntime
        };
        $[0] = webrtcAudioRuntime;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2;
    if ($[2] !== children || $[3] !== t1) {
        t2 = /* @__PURE__ */ _jsx94(AudioThreadContext.Provider, {
            value: t1,
            children: children
        });
        $[2] = children;
        $[3] = t1;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    return t2;
};
// src/components/markdown/MarkdownProvider/index.tsx
import { c as _c58 } from "react-compiler-runtime";
import { useMemo as useMemo20 } from "react";
import { jsx as _jsx95 } from "react/jsx-runtime";
var _excluded6 = [
    "children"
];
function _objectWithoutProperties6(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose6(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose6(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
var MarkdownProvider = function(t0) {
    var $ = _c58(9);
    var children;
    var rest;
    if ($[0] !== t0) {
        var _t = t0;
        children = _t.children;
        rest = _objectWithoutProperties6(_t, _excluded6);
        _t;
        $[0] = t0;
        $[1] = children;
        $[2] = rest;
    } else {
        children = $[1];
        rest = $[2];
    }
    var prevMarkdownContext = useMarkdownContext();
    var t1;
    var t2;
    if ($[3] !== prevMarkdownContext || $[4] !== rest) {
        t2 = merge(prevMarkdownContext, rest);
        $[3] = prevMarkdownContext;
        $[4] = rest;
        $[5] = t2;
    } else {
        t2 = $[5];
    }
    t1 = t2;
    var value = t1;
    var t3;
    if ($[6] !== children || $[7] !== value) {
        t3 = /* @__PURE__ */ _jsx95(MarkdownContext.Provider, {
            value: value,
            children: children
        });
        $[6] = children;
        $[7] = value;
        $[8] = t3;
    } else {
        t3 = $[8];
    }
    return t3;
};
// src/components/annotations/SourceAnnotation/index.tsx
import { c as _c61 } from "react-compiler-runtime";
// src/components/annotations/SourceAnnotation/FileCitation/index.tsx
import { c as _c60 } from "react-compiler-runtime";
import { useState as useState12 } from "react";
import { QuoteIcon as QuoteIcon2 } from "@radix-ui/react-icons";
import { Dialog, VisuallyHidden, IconButton as IconButton11 } from "@radix-ui/themes";
// src/components/annotations/SourceAnnotation/FileCitation/Content.tsx
import { c as _c59 } from "react-compiler-runtime";
import { Flex as Flex35, Card as Card5, Inset as Inset3 } from "@radix-ui/themes";
import { jsx as _jsx96 } from "react/jsx-runtime";
var Content9 = function(t0) {
    var $ = _c59(5);
    var fileId = t0.fileId;
    var superinterfaceContext = useSuperinterfaceContext();
    var nextSearchParams = new URLSearchParams(superinterfaceContext.variables);
    var t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = {
            display: "flex",
            flexGrow: "1"
        };
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    var t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = {
            display: "flex",
            flexGrow: "1"
        };
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    var t3 = "".concat(superinterfaceContext.baseUrl, "/files/").concat(fileId, "/contents?").concat(nextSearchParams);
    var t4;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t4 = {
            width: "100%",
            height: "100%"
        };
        $[2] = t4;
    } else {
        t4 = $[2];
    }
    var t5;
    if ($[3] !== t3) {
        t5 = /* @__PURE__ */ _jsx96(Flex35, {
            direction: "column",
            flexGrow: "1",
            gap: "3",
            children: /* @__PURE__ */ _jsx96(Card5, {
                style: t1,
                children: /* @__PURE__ */ _jsx96(Inset3, {
                    clip: "padding-box",
                    style: t2,
                    children: /* @__PURE__ */ _jsx96(Flex35, {
                        flexGrow: "1",
                        children: /* @__PURE__ */ _jsx96("embed", {
                            src: t3,
                            style: t4
                        })
                    })
                })
            })
        });
        $[3] = t3;
        $[4] = t5;
    } else {
        t5 = $[4];
    }
    return t5;
};
// src/components/annotations/SourceAnnotation/FileCitation/index.tsx
import { jsx as _jsx97, jsxs as _jsxs37, Fragment as _Fragment5 } from "react/jsx-runtime";
var FileCitation = function(t0) {
    var $ = _c60(18);
    var annotation = t0.annotation;
    var _useState12 = _sliced_to_array(useState12(null), 2), activeFileId = _useState12[0], setActiveFileId = _useState12[1];
    var t1;
    if ($[0] !== annotation.file_citation.file_id) {
        t1 = function() {
            setActiveFileId(annotation.file_citation.file_id);
        };
        $[0] = annotation.file_citation.file_id;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var t2;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = /* @__PURE__ */ _jsx97(QuoteIcon2, {});
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    var t3;
    if ($[3] !== t1) {
        t3 = /* @__PURE__ */ _jsx97(IconButton11, {
            variant: "soft",
            color: "gray",
            size: "1",
            onClick: t1,
            children: t2
        });
        $[3] = t1;
        $[4] = t3;
    } else {
        t3 = $[4];
    }
    var t4 = !!activeFileId;
    var t5;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
        t5 = function(open) {
            if (!open) {
                setActiveFileId(null);
            }
        };
        $[5] = t5;
    } else {
        t5 = $[5];
    }
    var t6;
    if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
        t6 = {
            display: "flex",
            flexDirection: "column"
        };
        $[6] = t6;
    } else {
        t6 = $[6];
    }
    var t7;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
        t7 = /* @__PURE__ */ _jsx97(VisuallyHidden, {
            asChild: true,
            children: /* @__PURE__ */ _jsx97(Dialog.Title, {
                children: "Source"
            })
        });
        $[7] = t7;
    } else {
        t7 = $[7];
    }
    var t8;
    if ($[8] !== activeFileId) {
        t8 = activeFileId && /* @__PURE__ */ _jsx97(Content9, {
            fileId: activeFileId
        });
        $[8] = activeFileId;
        $[9] = t8;
    } else {
        t8 = $[9];
    }
    var t9;
    if ($[10] !== t8) {
        t9 = /* @__PURE__ */ _jsxs37(Dialog.Content, {
            width: "1000px",
            height: "90vh",
            maxWidth: "calc(100vw - 2 * var(--space-4))",
            "aria-describedby": void 0,
            style: t6,
            children: [
                t7,
                t8
            ]
        });
        $[10] = t8;
        $[11] = t9;
    } else {
        t9 = $[11];
    }
    var t10;
    if ($[12] !== t4 || $[13] !== t9) {
        t10 = /* @__PURE__ */ _jsx97(Dialog.Root, {
            open: t4,
            onOpenChange: t5,
            children: t9
        });
        $[12] = t4;
        $[13] = t9;
        $[14] = t10;
    } else {
        t10 = $[14];
    }
    var t11;
    if ($[15] !== t10 || $[16] !== t3) {
        t11 = /* @__PURE__ */ _jsxs37(_Fragment5, {
            children: [
                t3,
                t10
            ]
        });
        $[15] = t10;
        $[16] = t3;
        $[17] = t11;
    } else {
        t11 = $[17];
    }
    return t11;
};
// src/components/annotations/SourceAnnotation/index.tsx
import { jsx as _jsx98 } from "react/jsx-runtime";
var _excluded7 = [
    "children"
];
function _objectWithoutProperties7(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose7(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose7(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
var SourceAnnotation = function(t0) {
    var $ = _c61(10);
    var children;
    var rest;
    if ($[0] !== t0) {
        var _t = t0;
        children = _t.children;
        rest = _objectWithoutProperties7(_t, _excluded7);
        _t;
        $[0] = t0;
        $[1] = children;
        $[2] = rest;
    } else {
        children = $[1];
        rest = $[2];
    }
    var t1;
    if ($[3] !== rest) {
        var _rest$dataAnnotation;
        t1 = JSON.parse((_rest$dataAnnotation = rest["data-annotation"]) !== null && _rest$dataAnnotation !== void 0 ? _rest$dataAnnotation : "{}");
        $[3] = rest;
        $[4] = t1;
    } else {
        t1 = $[4];
    }
    var annotation = t1;
    if (annotation.type === "file_citation") {
        var t2;
        if ($[5] !== annotation) {
            t2 = /* @__PURE__ */ _jsx98(FileCitation, {
                annotation: annotation
            });
            $[5] = annotation;
            $[6] = t2;
        } else {
            t2 = $[6];
        }
        return t2;
    } else {
        if (annotation.type === "file_path") {
            var _t2;
            if ($[7] !== annotation || $[8] !== children) {
                _t2 = /* @__PURE__ */ _jsx98(FilePathAnnotation, {
                    annotation: annotation,
                    children: children
                });
                $[7] = annotation;
                $[8] = children;
                $[9] = _t2;
            } else {
                _t2 = $[9];
            }
            return _t2;
        }
    }
    return null;
};
// src/components/avatars/Avatar.tsx
import { c as _c64 } from "react-compiler-runtime";
// src/lib/enums/index.ts
var IconAvatarName = /* @__PURE__ */ function(IconAvatarName2) {
    IconAvatarName2["BACKPACK"] = "BACKPACK";
    IconAvatarName2["ROCKET"] = "ROCKET";
    IconAvatarName2["MAGIC_WAND"] = "MAGIC_WAND";
    IconAvatarName2["CUBE"] = "CUBE";
    IconAvatarName2["TARGET"] = "TARGET";
    IconAvatarName2["DISC"] = "DISC";
    IconAvatarName2["GLOBE"] = "GLOBE";
    IconAvatarName2["STAR"] = "STAR";
    IconAvatarName2["LIGHTNING_BOLT"] = "LIGHTNING_BOLT";
    IconAvatarName2["FACE"] = "FACE";
    IconAvatarName2["PERSON"] = "PERSON";
    IconAvatarName2["HEART"] = "HEART";
    return IconAvatarName2;
}({});
var AvatarType = /* @__PURE__ */ function(AvatarType2) {
    AvatarType2["ICON"] = "ICON";
    AvatarType2["IMAGE"] = "IMAGE";
    return AvatarType2;
}({});
// src/components/avatars/Avatar.tsx
import { Avatar as RadixAvatar } from "@radix-ui/themes";
// src/components/imageAvatars/ImageAvatar/index.tsx
import { c as _c62 } from "react-compiler-runtime";
import { Avatar as Avatar4 } from "@radix-ui/themes";
// src/components/imageAvatars/ImageAvatar/lib/optimizedSrc/path.ts
var width = function(_ref) {
    var size = _ref.size;
    if (size === "1") {
        return 48;
    } else if (size === "2") {
        return 64;
    } else if (size === "3") {
        return 96;
    } else if (size === "4") {
        return 96;
    } else if (size === "5") {
        return 128;
    } else if (size === "6") {
        return 256;
    } else if (size === "7") {
        return 256;
    } else if (size === "8") {
        return 256;
    } else if (size === "9") {
        return 384;
    }
    return 384;
};
var path = function(_ref2) {
    var imageAvatar = _ref2.imageAvatar, size = _ref2.size;
    return "/_next/image?url=".concat(encodeURIComponent(imageAvatar.url), "&w=").concat(width({
        size: size
    }), "&q=95");
};
// src/components/imageAvatars/ImageAvatar/lib/optimizedSrc/host.ts
var host = function(_ref) {
    var superinterfaceContext = _ref.superinterfaceContext;
    if (!superinterfaceContext.baseUrl) return "";
    if (!/^https?:\/\//i.test(superinterfaceContext.baseUrl)) return "";
    return new URL(superinterfaceContext.baseUrl).origin;
};
// src/components/imageAvatars/ImageAvatar/lib/optimizedSrc/index.ts
var optimizedSrc = function(_ref) {
    var imageAvatar = _ref.imageAvatar, size = _ref.size, superinterfaceContext = _ref.superinterfaceContext;
    if (!imageAvatar.url) return "";
    if (imageAvatar.url.endsWith(".svg")) return imageAvatar.url;
    return "".concat(host({
        superinterfaceContext: superinterfaceContext
    })).concat(path({
        imageAvatar: imageAvatar,
        size: size
    }));
};
// src/components/imageAvatars/ImageAvatar/index.tsx
import { jsx as _jsx99 } from "react/jsx-runtime";
var ImageAvatar = function(t0) {
    var $ = _c62(9);
    var imageAvatar = t0.imageAvatar, size = t0.size, className = t0.className, style = t0.style;
    var superinterfaceContext = useSuperinterfaceContext();
    var t1;
    if ($[0] !== imageAvatar || $[1] !== size || $[2] !== superinterfaceContext) {
        t1 = optimizedSrc({
            imageAvatar: imageAvatar,
            size: size,
            superinterfaceContext: superinterfaceContext
        });
        $[0] = imageAvatar;
        $[1] = size;
        $[2] = superinterfaceContext;
        $[3] = t1;
    } else {
        t1 = $[3];
    }
    var t2;
    if ($[4] !== className || $[5] !== size || $[6] !== style || $[7] !== t1) {
        t2 = /* @__PURE__ */ _jsx99(Avatar4, {
            className: className,
            style: style,
            fallback: "",
            src: t1,
            size: size
        });
        $[4] = className;
        $[5] = size;
        $[6] = style;
        $[7] = t1;
        $[8] = t2;
    } else {
        t2 = $[8];
    }
    return t2;
};
// src/components/iconAvatars/IconAvatar.tsx
import { c as _c63 } from "react-compiler-runtime";
import { useMemo as useMemo21 } from "react";
import { Avatar as Avatar5 } from "@radix-ui/themes";
// src/lib/iconAvatars/iconAvatarComponents.ts
import { BackpackIcon, RocketIcon, MagicWandIcon, CubeIcon, TargetIcon, DiscIcon, GlobeIcon, StarIcon, LightningBoltIcon as LightningBoltIcon2, FaceIcon, PersonIcon as PersonIcon2, HeartIcon } from "@radix-ui/react-icons";
var _obj;
var iconAvatarComponents = (_obj = {}, _define_property(_obj, IconAvatarName.BACKPACK, BackpackIcon), _define_property(_obj, IconAvatarName.ROCKET, RocketIcon), _define_property(_obj, IconAvatarName.MAGIC_WAND, MagicWandIcon), _define_property(_obj, IconAvatarName.CUBE, CubeIcon), _define_property(_obj, IconAvatarName.TARGET, TargetIcon), _define_property(_obj, IconAvatarName.DISC, DiscIcon), _define_property(_obj, IconAvatarName.GLOBE, GlobeIcon), _define_property(_obj, IconAvatarName.STAR, StarIcon), _define_property(_obj, IconAvatarName.LIGHTNING_BOLT, LightningBoltIcon2), _define_property(_obj, IconAvatarName.FACE, FaceIcon), _define_property(_obj, IconAvatarName.PERSON, PersonIcon2), _define_property(_obj, IconAvatarName.HEART, HeartIcon), _obj);
// src/components/iconAvatars/IconAvatar.tsx
import { jsx as _jsx100 } from "react/jsx-runtime";
var IconAvatar = function(t0) {
    var $ = _c63(7);
    var iconAvatar = t0.iconAvatar, size = t0.size, className = t0.className, style = t0.style;
    var t1;
    t1 = iconAvatarComponents[iconAvatar.name];
    var Component = t1;
    var t2;
    if ($[0] !== Component) {
        t2 = Component ? /* @__PURE__ */ _jsx100(Component, {}) : "";
        $[0] = Component;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    var t3;
    if ($[2] !== className || $[3] !== size || $[4] !== style || $[5] !== t2) {
        t3 = /* @__PURE__ */ _jsx100(Avatar5, {
            className: className,
            style: style,
            size: size,
            fallback: t2
        });
        $[2] = className;
        $[3] = size;
        $[4] = style;
        $[5] = t2;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    return t3;
};
// src/components/avatars/Avatar.tsx
import { jsx as _jsx101 } from "react/jsx-runtime";
var Avatar6 = function(t0) {
    var $ = _c64(14);
    var avatar = t0.avatar, t1 = t0.size, className = t0.className, style = t0.style;
    var size = t1 === void 0 ? "1" : t1;
    if (avatar) {
        if (avatar.type === AvatarType.IMAGE && avatar.imageAvatar) {
            var _t;
            if ($[0] !== avatar.imageAvatar || $[1] !== className || $[2] !== size || $[3] !== style) {
                _t = /* @__PURE__ */ _jsx101(ImageAvatar, {
                    imageAvatar: avatar.imageAvatar,
                    size: size,
                    className: className,
                    style: style
                });
                $[0] = avatar.imageAvatar;
                $[1] = className;
                $[2] = size;
                $[3] = style;
                $[4] = _t;
            } else {
                _t = $[4];
            }
            return _t;
        }
        if (avatar.type === AvatarType.ICON && avatar.iconAvatar) {
            var _t2;
            if ($[5] !== avatar.iconAvatar || $[6] !== className || $[7] !== size || $[8] !== style) {
                _t2 = /* @__PURE__ */ _jsx101(IconAvatar, {
                    iconAvatar: avatar.iconAvatar,
                    size: size,
                    className: className,
                    style: style
                });
                $[5] = avatar.iconAvatar;
                $[6] = className;
                $[7] = size;
                $[8] = style;
                $[9] = _t2;
            } else {
                _t2 = $[9];
            }
            return _t2;
        }
    }
    var t2;
    if ($[10] !== className || $[11] !== size || $[12] !== style) {
        t2 = /* @__PURE__ */ _jsx101(RadixAvatar, {
            fallback: "",
            size: size,
            className: className,
            style: style
        });
        $[10] = className;
        $[11] = size;
        $[12] = style;
        $[13] = t2;
    } else {
        t2 = $[13];
    }
    return t2;
};
// src/components/components/ComponentsProvider.tsx
import { c as _c65 } from "react-compiler-runtime";
import { useMemo as useMemo22 } from "react";
// src/hooks/components/useComponents.ts
import { useContext as useContext16 } from "react";
var useComponents = function() {
    return useContext16(ComponentsContext);
};
// src/components/components/ComponentsProvider.tsx
import { jsx as _jsx102 } from "react/jsx-runtime";
var _excluded8 = [
    "children"
];
function _objectWithoutProperties8(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose8(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose8(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
var ComponentsProvider = function(t0) {
    var $ = _c65(9);
    var children;
    var rest;
    if ($[0] !== t0) {
        var _t = t0;
        children = _t.children;
        rest = _objectWithoutProperties8(_t, _excluded8);
        _t;
        $[0] = t0;
        $[1] = children;
        $[2] = rest;
    } else {
        children = $[1];
        rest = $[2];
    }
    var prevComponents = useComponents();
    var t1;
    var t2;
    if ($[3] !== prevComponents || $[4] !== rest) {
        t2 = merge(prevComponents, rest);
        $[3] = prevComponents;
        $[4] = rest;
        $[5] = t2;
    } else {
        t2 = $[5];
    }
    t1 = t2;
    var value = t1;
    var t3;
    if ($[6] !== children || $[7] !== value) {
        t3 = /* @__PURE__ */ _jsx102(ComponentsContext.Provider, {
            value: value,
            children: children
        });
        $[6] = children;
        $[7] = value;
        $[8] = t3;
    } else {
        t3 = $[8];
    }
    return t3;
};
// src/components/assistants/AssistantProvider/index.tsx
import { c as _c66 } from "react-compiler-runtime";
import { jsx as _jsx103 } from "react/jsx-runtime";
var AssistantProvider = function(t0) {
    var _assistant$name;
    var $ = _c66(10);
    var children = t0.children;
    var superinterfaceContext = useSuperinterfaceContext();
    var t1;
    if ($[0] !== superinterfaceContext.variables.assistantId) {
        t1 = {
            assistantId: superinterfaceContext.variables.assistantId
        };
        $[0] = superinterfaceContext.variables.assistantId;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    var assistant = useAssistant(t1).assistant;
    var t2 = (_assistant$name = assistant === null || assistant === void 0 ? void 0 : assistant.name) !== null && _assistant$name !== void 0 ? _assistant$name : "";
    var t3 = assistant === null || assistant === void 0 ? void 0 : assistant.avatar;
    var t4;
    if ($[2] !== t3) {
        t4 = /* @__PURE__ */ _jsx103(Avatar6, {
            avatar: t3
        });
        $[2] = t3;
        $[3] = t4;
    } else {
        t4 = $[3];
    }
    var t5;
    if ($[4] !== children || $[5] !== t4) {
        t5 = /* @__PURE__ */ _jsx103(AssistantAvatarContext.Provider, {
            value: t4,
            children: children
        });
        $[4] = children;
        $[5] = t4;
        $[6] = t5;
    } else {
        t5 = $[6];
    }
    var t6;
    if ($[7] !== t2 || $[8] !== t5) {
        t6 = /* @__PURE__ */ _jsx103(AssistantNameContext.Provider, {
            value: t2,
            children: t5
        });
        $[7] = t2;
        $[8] = t5;
        $[9] = t6;
    } else {
        t6 = $[9];
    }
    return t6;
};
export { AssistantAvatarContext, AssistantNameContext, AssistantProvider, AudioThread, AudioThreadDialog, Avatar6 as Avatar, ComponentsProvider, FunctionBase, FunctionComponentsContext, MarkdownContext, MarkdownProvider, MessageContent, RunStep, SourceAnnotation, Suggestions, SuperinterfaceProvider, Thread, ThreadDialog, ThreadDialogContext, TtsAudioRuntimeProvider, UserAvatarContext, WebrtcAudioRuntimeProvider, useAssistant, useAudioThreadContext, useComponents, useCreateFile, useCreateMessage, useIsMutatingMessage, useLatestMessage, useMarkdownContext, useMessageContext, useMessageFormContext, useMessages, useSuperinterfaceContext, useSuperinterfaceContext as useThreadContext, useThreadDialogContext, useTtsAudioRuntime, useWebrtcAudioRuntime };
//# sourceMappingURL=index.js.map